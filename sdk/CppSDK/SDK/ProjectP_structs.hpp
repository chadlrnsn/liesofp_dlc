#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ProjectP

#include "Basic.hpp"

#include "ControlRig_structs.hpp"
#include "Engine_structs.hpp"
#include "ProjectPContentInfo_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Enum ProjectP.ELHitFxLocationType
// NumValues: 0x0003
enum class ELHitFxLocationType : uint8
{
	Default                                  = 0,
	Spark                                    = 1,
	ELHitFxLocationType_MAX                  = 2,
};

// Enum ProjectP.ELAssistUseItemSlotType
// NumValues: 0x0006
enum class ELAssistUseItemSlotType : uint8
{
	None                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	Max                                      = 5,
};

// Enum ProjectP.ELWeaponStateChangeType
// NumValues: 0x0004
enum class ELWeaponStateChangeType : uint8
{
	Pick                                     = 0,
	Drop                                     = 1,
	Break                                    = 2,
	ELWeaponStateChangeType_MAX              = 3,
};

// Enum ProjectP.EPNGameState
// NumValues: 0x000A
enum class EPNGameState : uint8
{
	NONE                                     = 0,
	PSO                                      = 1,
	INIT                                     = 2,
	INTRO                                    = 3,
	LOGIN                                    = 4,
	LOBBY                                    = 5,
	PLAY                                     = 6,
	NEWGAMEPLUS                              = 7,
	GALLERY                                  = 8,
	EPNGameState_MAX                         = 9,
};

// Enum ProjectP.ELLobbyMenu
// NumValues: 0x0007
enum class ELLobbyMenu : uint8
{
	None                                     = 0,
	NewGame                                  = 1,
	Continue                                 = 2,
	LoadGame                                 = 3,
	DeleteSaveData                           = 4,
	GetAccountData                           = 5,
	ELLobbyMenu_MAX                          = 6,
};

// Enum ProjectP.ELFrenzyConsumeReason
// NumValues: 0x0005
enum class ELFrenzyConsumeReason : uint8
{
	None                                     = 0,
	Blade_Art                                = 1,
	Handle_Art                               = 2,
	SlaveArm_Art                             = 3,
	ELFrenzyConsumeReason_MAX                = 4,
};

// Enum ProjectP.ELConditionState
// NumValues: 0x0003
enum class ELConditionState : uint8
{
	Enter                                    = 0,
	Exit                                     = 1,
	ELConditionState_MAX                     = 2,
};

// Enum ProjectP.ELGameStartSequenceState
// NumValues: 0x000E
enum class ELGameStartSequenceState : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	PrecompilePSO                            = 2,
	LoadAccount                              = 3,
	LoadAccountWait                          = 4,
	LoadCharacterSaveGameWait                = 5,
	PreLoadData                              = 6,
	PreLoadDataComplete                      = 7,
	Language                                 = 8,
	Brightness                               = 9,
	AutoSaveAlert                            = 10,
	DemoVersionAlert                         = 11,
	AllCompleted                             = 12,
	ELGameStartSequenceState_MAX             = 13,
};

// Enum ProjectP.ELCameraWorkBlendState
// NumValues: 0x0004
enum class ELCameraWorkBlendState : uint8
{
	BlendIn                                  = 0,
	BlendInFully                             = 1,
	BlendOut                                 = 2,
	ELCameraWorkBlendState_MAX               = 3,
};

// Enum ProjectP.ELDLCItemReceiveResult
// NumValues: 0x0006
enum class ELDLCItemReceiveResult : uint8
{
	Success                                  = 0,
	InventoryFull                            = 1,
	AlreadyHave                              = 2,
	InvalidInfo                              = 3,
	InvalidData                              = 4,
	ELDLCItemReceiveResult_MAX               = 5,
};

// Enum ProjectP.ELAbnormalCaptureType
// NumValues: 0x0006
enum class ELAbnormalCaptureType : uint8
{
	None                                     = 0,
	ContentCondition                         = 1,
	Moment                                   = 2,
	TickCondition                            = 4,
	All                                      = 7,
	ELAbnormalCaptureType_MAX                = 8,
};

// Enum ProjectP.EAbnormalFXType
// NumValues: 0x0004
enum class EAbnormalFXType : uint8
{
	EAbnormalFXType_Attach                   = 0,
	EAbnormalFXType_Loop                     = 1,
	EAbnormalFXType_Detach                   = 2,
	EAbnormalFXType_MAX                      = 3,
};

// Enum ProjectP.ELDiePhysicsType
// NumValues: 0x0006
enum class ELDiePhysicsType : uint8
{
	None                                     = 0,
	Ragdoll                                  = 1,
	PhysicsWithAnim                          = 2,
	PhysicsWithAnimToRagdoll                 = 3,
	AnimToRagdoll                            = 4,
	ELDiePhysicsType_MAX                     = 5,
};

// Enum ProjectP.ELAngleRangeType_2Way
// NumValues: 0x0003
enum class ELAngleRangeType_2Way : uint8
{
	F                                        = 0,
	B                                        = 1,
	ELAngleRangeType_MAX                     = 2,
};

// Enum ProjectP.ELAngleRangeType_4Way
// NumValues: 0x0005
enum class ELAngleRangeType_4Way : uint8
{
	F                                        = 0,
	L                                        = 1,
	R                                        = 2,
	B                                        = 3,
	ELAngleRangeType_MAX                     = 4,
};

// Enum ProjectP.ELAngleRangeType
// NumValues: 0x0009
enum class ELAngleRangeType : uint8
{
	FR                                       = 0,
	RF                                       = 1,
	RB                                       = 2,
	BR                                       = 3,
	BL                                       = 4,
	LB                                       = 5,
	LF                                       = 6,
	FL                                       = 7,
	ELAngleRangeType_MAX                     = 8,
};

// Enum ProjectP.ELAnimRootMotionScaleOperationType
// NumValues: 0x0006
enum class ELAnimRootMotionScaleOperationType : uint8
{
	None                                     = 0,
	Multiply                                 = 1,
	Add                                      = 2,
	Overwrite                                = 3,
	Freeze                                   = 4,
	Max                                      = 5,
};

// Enum ProjectP.ELAnimRateScaleOperationType
// NumValues: 0x0006
enum class ELAnimRateScaleOperationType : uint8
{
	None                                     = 0,
	Multiply                                 = 1,
	Add                                      = 2,
	Overwrite                                = 3,
	Freeze                                   = 4,
	Max                                      = 5,
};

// Enum ProjectP.ELAbsoluteRootMotionModeType
// NumValues: 0x0004
enum class ELAbsoluteRootMotionModeType : uint8
{
	None                                     = 0,
	AbsoluteFromStart                        = 1,
	AbsoluteFromStart_UseManualTime          = 2,
	ELAbsoluteRootMotionModeType_MAX         = 3,
};

// Enum ProjectP.ELAITimerFunctionType
// NumValues: 0x0005
enum class ELAITimerFunctionType : uint8
{
	Start                                    = 0,
	Pause                                    = 1,
	Resume                                   = 2,
	Clear                                    = 3,
	ELAITimerFunctionType_MAX                = 4,
};

// Enum ProjectP.ELMoveMotionBlendDirection
// NumValues: 0x0006
enum class ELMoveMotionBlendDirection : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Back                                     = 2,
	Right                                    = 3,
	Left                                     = 4,
	ELMoveMotionBlendDirection_MAX           = 5,
};

// Enum ProjectP.ELAnimLookAtType
// NumValues: 0x0005
enum class ELAnimLookAtType : uint8
{
	StopHead                                 = 0,
	StopUpperBody                            = 1,
	Head                                     = 2,
	UpperBody                                = 3,
	ELAnimLookAtType_MAX                     = 4,
};

// Enum ProjectP.ELAnimRotateBodyType
// NumValues: 0x0004
enum class ELAnimRotateBodyType : uint8
{
	None                                     = 0,
	Head                                     = 1,
	UpperBody                                = 2,
	ELAnimRotateBodyType_MAX                 = 3,
};

// Enum ProjectP.ELTrailConditionType
// NumValues: 0x0006
enum class ELTrailConditionType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Frenzy                                   = 2,
	Knife                                    = 3,
	Blunt                                    = 4,
	ELTrailConditionType_MAX                 = 5,
};

// Enum ProjectP.ELBodyWetReasonType
// NumValues: 0x0003
enum class ELBodyWetReasonType : uint8
{
	Sink                                     = 0,
	WaterDrop                                = 1,
	ELBodyWetReasonType_MAX                  = 2,
};

// Enum ProjectP.ELBodyWetDirectionType
// NumValues: 0x0004
enum class ELBodyWetDirectionType : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Reverse                                  = 2,
	ELBodyWetDirectionType_MAX               = 3,
};

// Enum ProjectP.ELBodyStainCategory
// NumValues: 0x0009
enum class ELBodyStainCategory : uint8
{
	None                                     = 0,
	Wet_Leg                                  = 1,
	Wet_Body                                 = 2,
	Instant                                  = 3,
	Category_1                               = 4,
	Category_2                               = 5,
	Category_3                               = 6,
	Category_4                               = 7,
	ELBodyStainCategory_MAX                  = 8,
};

// Enum ProjectP.ETestTaskResultType
// NumValues: 0x0004
enum class ETestTaskResultType : uint8
{
	Success                                  = 0,
	Fail                                     = 1,
	Abort                                    = 2,
	ETestTaskResultType_MAX                  = 3,
};

// Enum ProjectP.ELBTreeStateConditionType
// NumValues: 0x0003
enum class ELBTreeStateConditionType : uint8
{
	NoCondition                              = 0,
	HP                                       = 1,
	ELBTreeStateConditionType_MAX            = 2,
};

// Enum ProjectP.ELCameraModifierPriority
// NumValues: 0x0006
enum class ELCameraModifierPriority : uint8
{
	General                                  = 0,
	LockOn                                   = 1,
	Monster                                  = 2,
	World                                    = 3,
	Dialog                                   = 4,
	ELCameraModifierPriority_MAX             = 5,
};

// Enum ProjectP.ELCarcassBodyObjectOverlapState
// NumValues: 0x0004
enum class ELCarcassBodyObjectOverlapState : uint8
{
	None                                     = 0,
	Safe                                     = 1,
	Unsafe                                   = 2,
	ELCarcassBodyObjectOverlapState_MAX      = 3,
};

// Enum ProjectP.ELHUDEventNotifyType
// NumValues: 0x0003
enum class ELHUDEventNotifyType : uint8
{
	CommonEvent                              = 0,
	SlaveArmSkill                            = 1,
	ELHUDEventNotifyType_MAX                 = 2,
};

// Enum ProjectP.ELAnimNotifyTrackType
// NumValues: 0x0004
enum class ELAnimNotifyTrackType : uint8
{
	None                                     = 0,
	FXandSound                               = 1,
	Humanity                                 = 2,
	ELAnimNotifyTrackType_MAX                = 3,
};

// Enum ProjectP.ELFxAnimNotifyType
// NumValues: 0x0004
enum class ELFxAnimNotifyType : uint8
{
	None                                     = 0,
	Fx                                       = 1,
	Sound                                    = 2,
	ELFxAnimNotifyType_MAX                   = 3,
};

// Enum ProjectP.ELDamageVolumeType
// NumValues: 0x0004
enum class ELDamageVolumeType : uint8
{
	Immediate                                = 0,
	Time                                     = 1,
	Endless                                  = 2,
	ELDamageVolumeType_MAX                   = 3,
};

// Enum ProjectP.ELNpcSpotDieType
// NumValues: 0x000B
enum class ELNpcSpotDieType : uint8
{
	None                                     = 0,
	UiFadeOut                                = 1,
	LevelSequence                            = 2,
	Movie                                    = 3,
	Dialog                                   = 4,
	Etc                                      = 5,
	Etc_ItemAlert                            = 6,
	Etc_BossAlert                            = 7,
	Etc_ChangeWeather                        = 8,
	Etc_Monologue                            = 9,
	ELNpcSpotDieType_MAX                     = 10,
};

// Enum ProjectP.ELExplosionMeshType
// NumValues: 0x0008
enum class ELExplosionMeshType : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Arm_R                                    = 2,
	Arm_L                                    = 3,
	Upper                                    = 4,
	Lower                                    = 5,
	All                                      = 6,
	ELExplosionMeshType_MAX                  = 7,
};

// Enum ProjectP.ETEST_ExplodeType
// NumValues: 0x0007
enum class ETEST_ExplodeType : uint8
{
	None                                     = 0,
	Head                                     = 1,
	Arm_R                                    = 2,
	Arm_L                                    = 3,
	Chest                                    = 4,
	All                                      = 5,
	ETEST_MAX                                = 6,
};

// Enum ProjectP.ELSpawnTransformType
// NumValues: 0x0005
enum class ELSpawnTransformType : uint8
{
	None                                     = 0,
	MoveTargetTeleport                       = 1,
	LatestTransform                          = 2,
	RespawnTeleport                          = 3,
	ELSpawnTransformType_MAX                 = 4,
};

// Enum ProjectP.ELNPCSuicideType
// NumValues: 0x0004
enum class ELNPCSuicideType : uint8
{
	DeadMotion                               = 0,
	Hide                                     = 1,
	Explosive                                = 2,
	ELNPCSuicideType_MAX                     = 3,
};

// Enum ProjectP.ELKillZoneType
// NumValues: 0x0004
enum class ELKillZoneType : uint8
{
	PC                                       = 0,
	NPC                                      = 1,
	ALL                                      = 2,
	ELKillZoneType_MAX                       = 3,
};

// Enum ProjectP.ELAIMoveSpeedType
// NumValues: 0x0003
enum class ELAIMoveSpeedType : uint8
{
	Walk                                     = 0,
	Run                                      = 1,
	ELAIMoveSpeedType_MAX                    = 2,
};

// Enum ProjectP.ELAIMoveDirection
// NumValues: 0x0007
enum class ELAIMoveDirection : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Forward                                  = 3,
	Backward                                 = 4,
	RunForward                               = 5,
	ELAIMoveDirection_MAX                    = 6,
};

// Enum ProjectP.ELCharacterCollisionType
// NumValues: 0x0008
enum class ELCharacterCollisionType : uint8
{
	None                                     = 0,
	PC                                       = 1,
	NPC                                      = 2,
	NPC_Ignore                               = 3,
	NPC_Small                                = 4,
	NPC_Big                                  = 5,
	PC_Slave                                 = 6,
	ELCharacterCollisionType_MAX             = 7,
};

// Enum ProjectP.ELAppearanceType
// NumValues: 0x0007
enum class ELAppearanceType : uint8
{
	None                                     = 0,
	DieToReStart                             = 1,
	Reconnect                                = 2,
	TeleportEnd_First                        = 3,
	TeleportEnd_Normal                       = 4,
	TeleportEnd_Portal                       = 5,
	ELAppearanceType_MAX                     = 6,
};

// Enum ProjectP.ELInteractResult
// NumValues: 0x0004
enum class ELInteractResult : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Failure                                  = 2,
	ELInteractResult_MAX                     = 3,
};

// Enum ProjectP.ELPropInteractState
// NumValues: 0x0004
enum class ELPropInteractState : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Inverse                                  = 2,
	ELPropInteractState_MAX                  = 3,
};

// Enum ProjectP.ELLookAtUpperBodyType
// NumValues: 0x0003
enum class ELLookAtUpperBodyType : uint8
{
	Bone                                     = 0,
	Slope                                    = 1,
	ELLookAtUpperBodyType_MAX                = 2,
};

// Enum ProjectP.ELSocketTraceType
// NumValues: 0x0004
enum class ELSocketTraceType : uint8
{
	Default                                  = 0,
	Repulse                                  = 1,
	RepulseForWeaponOnly                     = 2,
	ELSocketTraceType_MAX                    = 3,
};

// Enum ProjectP.ELMaterialVaryingPlayType
// NumValues: 0x0003
enum class ELMaterialVaryingPlayType : uint8
{
	PlayForward                              = 0,
	PlayReverse                              = 1,
	ELMaterialVaryingPlayType_MAX            = 2,
};

// Enum ProjectP.ELMeshSelectionType
// NumValues: 0x0015
enum class ELMeshSelectionType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Character                                = 2,
	Body                                     = 3,
	SlaveArm                                 = 4,
	Weapon_R                                 = 5,
	Blade_R                                  = 6,
	Handle_R                                 = 7,
	Weapon_L                                 = 8,
	Blade_L                                  = 9,
	Handle_L                                 = 10,
	Weapon_EX1                               = 11,
	Blade_EX1                                = 12,
	Handle_EX1                               = 13,
	Weapon_EX2                               = 14,
	Blade_EX2                                = 15,
	Handle_EX2                               = 16,
	Weapon_EX3                               = 17,
	Blade_EX3                                = 18,
	Handle_EX3                               = 19,
	ELMeshSelectionType_MAX                  = 20,
};

// Enum ProjectP.ELCollisionState
// NumValues: 0x0009
enum class ELCollisionState : uint8
{
	Default                                  = 0,
	Dying                                    = 1,
	Dead                                     = 2,
	Ghost                                    = 3,
	Penetrate                                = 4,
	PenetrateFly                             = 5,
	Grabbed                                  = 6,
	Grabbed_NotAttached                      = 7,
	ELCollisionState_MAX                     = 8,
};

// Enum ProjectP.ELCallBackResultType
// NumValues: 0x000A
enum class ELCallBackResultType : uint8
{
	FailedByNotFindData                      = 0,
	FailedByInvalidData                      = 1,
	FailedByMaxCount                         = 2,
	FailedByConditionCheck                   = 3,
	SuccessByMaxCount                        = 4,
	Success                                  = 5,
	FailedByUnmatchEventType                 = 6,
	FailedByUnmatchParam                     = 7,
	FailedByUnsucceedPercentage              = 8,
	ELCallBackResultType_MAX                 = 9,
};

// Enum ProjectP.ELMeshComponentUsage
// NumValues: 0x0004
enum class ELMeshComponentUsage : uint8
{
	Socket                                   = 0,
	Material                                 = 1,
	Hidden                                   = 2,
	ELMeshComponentUsage_MAX                 = 3,
};

// Enum ProjectP.ELPCActionKeyType
// NumValues: 0x000F
enum class ELPCActionKeyType : uint8
{
	None                                     = 0,
	ButtonDown                               = 1,
	ButtonLeft                               = 2,
	ButtonUp                                 = 3,
	ButtonRight                              = 4,
	LeftTrigger                              = 5,
	LeftShoulder                             = 6,
	RightTrigger                             = 7,
	RightSholder                             = 8,
	LockOn                                   = 9,
	DPadLeft                                 = 10,
	DPadRight                                = 11,
	DPadUp                                   = 12,
	DPadDown                                 = 13,
	ELPCActionKeyType_MAX                    = 14,
};

// Enum ProjectP.ELGameSubSystemActiveType
// NumValues: 0x0008
enum class ELGameSubSystemActiveType : uint8
{
	None                                     = 0,
	Login                                    = 1,
	Init                                     = 2,
	Lobby                                    = 4,
	Play                                     = 8,
	NewGamePlus                              = 16,
	All                                      = 31,
	ELGameSubSystemActiveType_MAX            = 32,
};

// Enum ProjectP.ELiftObjectType
// NumValues: 0x0006
enum class ELiftObjectType : uint8
{
	Elevator                                 = 0,
	PointA_Door                              = 1,
	PointB_Door                              = 2,
	PointA_Trigger                           = 3,
	PointB_Trigger                           = 4,
	Max                                      = 5,
};

// Enum ProjectP.ELSpotType
// NumValues: 0x0012
enum class ELSpotType : uint8
{
	None                                     = 0,
	Npc                                      = 1,
	Prop                                     = 2,
	PropItem                                 = 3,
	TeleportObject                           = 4,
	ShapeObject                              = 5,
	Ladder                                   = 6,
	Lift                                     = 7,
	Destruction                              = 8,
	Volume                                   = 9,
	LevelSequence                            = 10,
	BossRoom                                 = 11,
	Projectile                               = 12,
	Door                                     = 13,
	ExiledNpc                                = 14,
	HelpMate                                 = 15,
	DynamicShapeObject                       = 16,
	Max                                      = 17,
};

// Enum ProjectP.ELGameDataType
// NumValues: 0x0008
enum class ELGameDataType : uint8
{
	None                                     = 0,
	Account                                  = 1,
	Character                                = 2,
	Option                                   = 3,
	AccountAndCharacter                      = 4,
	SecondAccount                            = 5,
	SecondCharacter                          = 6,
	ELGameDataType_MAX                       = 7,
};

// Enum ProjectP.ELEasingType
// NumValues: 0x000F
enum class ELEasingType : uint8
{
	Linear                                   = 0,
	Step                                     = 1,
	SinusoidalIn                             = 2,
	SinusoidalOut                            = 3,
	SinusoidalInOut                          = 4,
	EaseIn                                   = 5,
	EaseOut                                  = 6,
	EaseInOut                                = 7,
	ExpoIn                                   = 8,
	ExpoOut                                  = 9,
	ExpoInOut                                = 10,
	CircularIn                               = 11,
	CircularOut                              = 12,
	CircularInOut                            = 13,
	ELEasingType_MAX                         = 14,
};

// Enum ProjectP.ENotifyType
// NumValues: 0x0006
enum class ENotifyType : uint8
{
	Common                                   = 0,
	Hit                                      = 1,
	Fx                                       = 2,
	Projectile                               = 3,
	AnimPlayRate                             = 4,
	ENotifyType_MAX                          = 5,
};

// Enum ProjectP.EExecutePin
// NumValues: 0x0003
enum class EExecutePin : uint8
{
	Success                                  = 0,
	Fail                                     = 1,
	EExecutePin_MAX                          = 2,
};

// Enum ProjectP.ELPackageOfferMethod
// NumValues: 0x0003
enum class ELPackageOfferMethod : uint8
{
	Drop                                     = 0,
	Auto                                     = 1,
	ELPackageOfferMethod_MAX                 = 2,
};

// Enum ProjectP.ELPackageOfferReason
// NumValues: 0x0004
enum class ELPackageOfferReason : uint8
{
	Die                                      = 0,
	MotionNotify                             = 1,
	PropsInteraction                         = 2,
	ELPackageOfferReason_MAX                 = 3,
};

// Enum ProjectP.ELPackageOwnerType
// NumValues: 0x0005
enum class ELPackageOwnerType : uint8
{
	Monster                                  = 0,
	Props                                    = 1,
	Talk                                     = 2,
	Player                                   = 3,
	ELPackageOwnerType_MAX                   = 4,
};

// Enum ProjectP.ELImmuneSourceType
// NumValues: 0x0006
enum class ELImmuneSourceType : uint8
{
	None                                     = 0,
	Character                                = 1,
	Skill                                    = 2,
	ActionEvent                              = 3,
	ActionClass                              = 4,
	ELImmuneSourceType_MAX                   = 5,
};

// Enum ProjectP.ELStatCalcType
// NumValues: 0x0003
enum class ELStatCalcType : uint8
{
	Value                                    = 0,
	Ratio                                    = 1,
	ELStatCalcType_MAX                       = 2,
};

// Enum ProjectP.ELStatDataType
// NumValues: 0x0004
enum class ELStatDataType : uint8
{
	Equip                                    = 0,
	Buff                                     = 1,
	MaxMultiplier                            = 2,
	ELStatDataType_MAX                       = 3,
};

// Enum ProjectP.ELFirstStatDataType
// NumValues: 0x0006
enum class ELFirstStatDataType : uint8
{
	Default                                  = 0,
	Character                                = 1,
	Equip                                    = 2,
	Buff                                     = 3,
	Total                                    = 4,
	ELFirstStatDataType_MAX                  = 5,
};

// Enum ProjectP.EPNFaction
// NumValues: 0x0005
enum class EPNFaction : uint8
{
	Neutral                                  = 0,
	Player                                   = 1,
	Monster                                  = 2,
	AllEnemy                                 = 3,
	EPNFaction_MAX                           = 4,
};

// Enum ProjectP.EPNWidgetType
// NumValues: 0x0008
enum class EPNWidgetType : uint8
{
	None                                     = 0,
	Intro                                    = 1,
	Title                                    = 2,
	Loading                                  = 3,
	CombatHUD                                = 4,
	SystemMenu                               = 5,
	YouDie                                   = 6,
	Max                                      = 7,
};

// Enum ProjectP.EDataTableType
// NumValues: 0x0029
enum class EDataTableType : uint8
{
	None                                     = 0,
	Widget                                   = 1,
	KeyPreset                                = 2,
	SwingSFX                                 = 3,
	HitFX                                    = 4,
	HitSFX                                   = 5,
	SplashBloodFX                            = 6,
	PreloadAsset                             = 7,
	CameraShake                              = 8,
	SmashFX                                  = 9,
	DialogSound                              = 10,
	PhysicalSurfaceFX                        = 11,
	PhysicalSurfaceSound                     = 12,
	ActionGroup                              = 13,
	NPCAsset                                 = 14,
	FootStepFX                               = 15,
	ItemCostume                              = 16,
	CharacterSound                           = 17,
	FxAttachCommon                           = 18,
	WeaponAsset                              = 19,
	LoadingScreen                            = 20,
	LoadingScreenImage                       = 21,
	WeatherFx                                = 22,
	PartsAsset                               = 23,
	VaryingAsset                             = 24,
	BladeTrail                               = 25,
	Gallery                                  = 26,
	DitherFade                               = 27,
	SparkFx                                  = 28,
	SparkSound                               = 29,
	RepulseFx                                = 30,
	RepulseSound                             = 31,
	DeadExplosion                            = 32,
	WeatherSound                             = 33,
	EnvSound                                 = 34,
	SoundCue                                 = 35,
	HitLevel                                 = 36,
	SwingSFX_NPC                             = 37,
	BGMSound                                 = 38,
	Max                                      = 39,
	AllTables                                = 40,
};

// Enum ProjectP.ELLandPositionSelectType
// NumValues: 0x0004
enum class ELLandPositionSelectType : uint8
{
	TargetPosition                           = 0,
	TargetOffset                             = 1,
	SelfOffset                               = 2,
	ELLandPositionSelectType_MAX             = 3,
};

// Enum ProjectP.ELRewardType
// NumValues: 0x0004
enum class ELRewardType : uint8
{
	None                                     = 0,
	DLC                                      = 1,
	PatchReward                              = 2,
	ELRewardType_MAX                         = 3,
};

// Enum ProjectP.EDayTimeType
// NumValues: 0x0004
enum class EDayTimeType : uint8
{
	Sun                                      = 0,
	Moon                                     = 1,
	SunAndMoon                               = 2,
	EDayTimeType_MAX                         = 3,
};

// Enum ProjectP.ELManagedNiagaraUsage
// NumValues: 0x0002
enum class ELManagedNiagaraUsage : uint8
{
	Keeping                                  = 0,
	ELManagedNiagaraUsage_MAX                = 1,
};

// Enum ProjectP.ELFXCommandEventType
// NumValues: 0x0005
enum class ELFXCommandEventType : uint8
{
	None                                     = 0,
	DeactiveOnDead                           = 1,
	DeactiveOnPhase                          = 2,
	DeactiveOnRespawn                        = 4,
	ELFXCommandEventType_MAX                 = 5,
};

// Enum ProjectP.ELFxParamterContentType
// NumValues: 0x0005
enum class ELFxParamterContentType : uint8
{
	None                                     = 0,
	Blade_Length                             = 1,
	Capsule_size                             = 2,
	NpcFxSize                                = 3,
	ELFxParamterContentType_MAX              = 4,
};

// Enum ProjectP.ELItemGainResult
// NumValues: 0x0007
enum class ELItemGainResult : uint8
{
	Success                                  = 0,
	AlreadyExists                            = 1,
	OverMaxCount                             = 2,
	OverMaxSlotCount                         = 3,
	CannotMoveToLocker                       = 4,
	Invalid                                  = 5,
	ELItemGainResult_MAX                     = 6,
};

// Enum ProjectP.ELGuardingObjectType
// NumValues: 0x0004
enum class ELGuardingObjectType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Character                                = 2,
	ELGuardingObjectType_MAX                 = 3,
};

// Enum ProjectP.ELItemUseOccurredFrom
// NumValues: 0x0005
enum class ELItemUseOccurredFrom : uint8
{
	Belt                                     = 0,
	Pouch                                    = 1,
	Inventory                                = 2,
	AlterCreated                             = 3,
	ELItemUseOccurredFrom_MAX                = 4,
};

// Enum ProjectP.ELSlavearmAlterProcessState
// NumValues: 0x0004
enum class ELSlavearmAlterProcessState : uint8
{
	None                                     = 0,
	Hold                                     = 1,
	Success                                  = 2,
	ELSlavearmAlterProcessState_MAX          = 3,
};

// Enum ProjectP.ELLinkedNpcSpotExecuteType
// NumValues: 0x0004
enum class ELLinkedNpcSpotExecuteType : uint8
{
	WakeUp                                   = 0,
	FloatingStop                             = 1,
	SpawnIdleEnd                             = 2,
	ELLinkedNpcSpotExecuteType_MAX           = 3,
};

// Enum ProjectP.ELFatalIndicatorState
// NumValues: 0x0006
enum class ELFatalIndicatorState : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Active_In_Range                          = 2,
	Success                                  = 3,
	Fail                                     = 4,
	ELFatalIndicatorState_MAX                = 5,
};

// Enum ProjectP.ELConditionalAnimBranch
// NumValues: 0x0003
enum class ELConditionalAnimBranch : uint8
{
	E_FALSE                                  = 0,
	E_TRUE                                   = 1,
	E_MAX                                    = 2,
};

// Enum ProjectP.ELFxHitGuardType
// NumValues: 0x0006
enum class ELFxHitGuardType : uint8
{
	None                                     = 0,
	Guard                                    = 1,
	PerfectGuard                             = 2,
	GuardParry                               = 3,
	DashParry                                = 4,
	ELFxHitGuardType_MAX                     = 5,
};

// Enum ProjectP.ELDamageBranchType
// NumValues: 0x0007
enum class ELDamageBranchType : uint8
{
	Gauge                                    = 0,
	Attack                                   = 1,
	AttackRatio                              = 2,
	Defence                                  = 3,
	DamageIncreaseRatio                      = 4,
	DamageReductionRatio                     = 5,
	ELDamageBranchType_MAX                   = 6,
};

// Enum ProjectP.EReflexMode
// NumValues: 0x0004
enum class EReflexMode : uint8
{
	Off                                      = 0,
	On                                       = 1,
	Boost                                    = 2,
	EReflexMode_MAX                          = 3,
};

// Enum ProjectP.EXeSSMode
// NumValues: 0x0006
enum class EXeSSMode : uint8
{
	Off                                      = 0,
	UltraQuality                             = 1,
	Quality                                  = 2,
	Balanced                                 = 3,
	Performance                              = 4,
	EXeSSMode_MAX                            = 5,
};

// Enum ProjectP.EFSR2Mode
// NumValues: 0x0006
enum class EFSR2Mode : uint8
{
	Off                                      = 0,
	Quality                                  = 1,
	Balanced                                 = 2,
	Performance                              = 3,
	UltraPerformance                         = 4,
	EFSR2Mode_MAX                            = 5,
};

// Enum ProjectP.EFSR1Mode
// NumValues: 0x0006
enum class EFSR1Mode : uint8
{
	Off                                      = 0,
	UltraQuality                             = 1,
	Quality                                  = 2,
	Balanced                                 = 3,
	Performance                              = 4,
	EFSR1Mode_MAX                            = 5,
};

// Enum ProjectP.EDLSSMode
// NumValues: 0x0008
enum class EDLSSMode : uint8
{
	Off                                      = 0,
	Auto                                     = 1,
	UltraQuality                             = 2,
	Quality                                  = 3,
	Balanced                                 = 4,
	Performance                              = 5,
	UltraPerformance                         = 6,
	EDLSSMode_MAX                            = 7,
};

// Enum ProjectP.ELStatControlType
// NumValues: 0x0005
enum class ELStatControlType : uint8
{
	StatControlType_Stat                     = 0,
	StatControlType_GaugeCurrent             = 1,
	StatControlType_GaugeMax                 = 2,
	StatControlType_None                     = 3,
	StatControlType_MAX                      = 4,
};

// Enum ProjectP.ELStatGaugeState
// NumValues: 0x0005
enum class ELStatGaugeState : uint8
{
	None                                     = 0,
	Recovering                               = 1,
	Suppressing_Then_Recover                 = 2,
	Suppressing_Then_Full_Charge             = 3,
	ELStatGaugeState_MAX                     = 4,
};

// Enum ProjectP.ELGameDataExecuteType
// NumValues: 0x0005
enum class ELGameDataExecuteType : uint8
{
	SaveGameInLobby                          = 0,
	SaveGameInPlay                           = 1,
	LoadGameInLobby                          = 2,
	LoadGameInPlay                           = 3,
	ELGameDataExecuteType_MAX                = 4,
};

// Enum ProjectP.ELGameObjectState
// NumValues: 0x0004
enum class ELGameObjectState : uint8
{
	None                                     = 0,
	Active                                   = 1,
	Inactive                                 = 2,
	Max                                      = 3,
};

// Enum ProjectP.ELPreloadUsage
// NumValues: 0x0007
enum class ELPreloadUsage : uint8
{
	None                                     = 0,
	SYSTEM                                   = 1,
	PC                                       = 2,
	NPC                                      = 3,
	PROP                                     = 4,
	UI                                       = 5,
	ELPreloadUsage_MAX                       = 6,
};

// Enum ProjectP.ELGameCommandCategory
// NumValues: 0x0002
enum class ELGameCommandCategory : uint8
{
	Default                                  = 0,
	ELGameCommandCategory_MAX                = 1,
};

// Enum ProjectP.ELGrabReleaseMotionType
// NumValues: 0x0003
enum class ELGrabReleaseMotionType : uint8
{
	SkillHit                                 = 0,
	Montage                                  = 1,
	ELGrabReleaseMotionType_MAX              = 2,
};

// Enum ProjectP.ELHitCollisionCheckType
// NumValues: 0x0006
enum class ELHitCollisionCheckType : uint8
{
	Box                                      = 0,
	Capsule                                  = 1,
	Sphere                                   = 2,
	Cylinder                                 = 3,
	None                                     = 4,
	ELHitCollisionCheckType_MAX              = 5,
};

// Enum ProjectP.ELHitLevelTable_SwingPower
// NumValues: 0x0007
enum class ELHitLevelTable_SwingPower : uint8
{
	None                                     = 0,
	VeryLight                                = 1,
	Light                                    = 2,
	Medium                                   = 3,
	Heavy                                    = 4,
	VeryHeavy                                = 5,
	ELHitLevelTable_MAX                      = 6,
};

// Enum ProjectP.ELHitLevelTable_SkillHitType
// NumValues: 0x0007
enum class ELHitLevelTable_SkillHitType : uint8
{
	Character                                = 0,
	Weapon                                   = 1,
	SlaveArm                                 = 2,
	Projectile                               = 3,
	DynamicVolume                            = 4,
	Undefined                                = 5,
	ELHitLevelTable_MAX                      = 6,
};

// Enum ProjectP.ELHitLevelTable_Attacker
// NumValues: 0x0005
enum class ELHitLevelTable_Attacker : uint8
{
	PC                                       = 0,
	NPC                                      = 1,
	DynamicVolume                            = 2,
	Undefined                                = 3,
	ELHitLevelTable_MAX                      = 4,
};

// Enum ProjectP.ELHitProcObjectType
// NumValues: 0x0006
enum class ELHitProcObjectType : uint8
{
	Unknown                                  = 0,
	PC                                       = 1,
	NPC                                      = 2,
	DamageVolume                             = 3,
	Projectile                               = 4,
	ELHitProcObjectType_MAX                  = 5,
};

// Enum ProjectP.ELHandleCorrectResultGrade
// NumValues: 0x000A
enum class ELHandleCorrectResultGrade : uint8
{
	E_NONE                                   = 0,
	E_D                                      = 1,
	E_C                                      = 2,
	E_B                                      = 3,
	E_A                                      = 4,
	E_S                                      = 5,
	E_UPPER_FAIL                             = 6,
	E_UNDER_FAIL                             = 7,
	E_INVALID                                = 8,
	E_MAX                                    = 9,
};

// Enum ProjectP.ELConsumeItemSlavearmAtlerableState
// NumValues: 0x0004
enum class ELConsumeItemSlavearmAtlerableState : uint8
{
	Invalid                                  = 0,
	Disable                                  = 1,
	Enable                                   = 2,
	ELConsumeItemSlavearmAtlerableState_MAX  = 3,
};

// Enum ProjectP.ELLiftObjectState
// NumValues: 0x0005
enum class ELLiftObjectState : uint8
{
	UnUsed                                   = 0,
	Broken                                   = 1,
	Lock                                     = 2,
	Usable                                   = 3,
	ELLiftObjectState_MAX                    = 4,
};

// Enum ProjectP.ELDoorState
// NumValues: 0x0004
enum class ELDoorState : uint8
{
	UnUsed                                   = 0,
	Close                                    = 1,
	Open                                     = 2,
	ELDoorState_MAX                          = 3,
};

// Enum ProjectP.ELFogGateState
// NumValues: 0x0007
enum class ELFogGateState : uint8
{
	UnUsed                                   = 0,
	BlockAfterWaiting                        = 1,
	Block                                    = 2,
	Opening                                  = 3,
	Closing                                  = 4,
	Disappear                                = 5,
	ELFogGateState_MAX                       = 6,
};

// Enum ProjectP.ELSequenceTargetType
// NumValues: 0x0005
enum class ELSequenceTargetType : uint8
{
	None                                     = 0,
	Player                                   = 1,
	Instigator                               = 2,
	SpotUniqueID                             = 3,
	ELSequenceTargetType_MAX                 = 4,
};

// Enum ProjectP.EStreamingLayer
// NumValues: 0x0004
enum class EStreamingLayer : uint8
{
	High                                     = 0,
	Low                                      = 1,
	Both                                     = 2,
	EStreamingLayer_MAX                      = 3,
};

// Enum ProjectP.ELockDeterminedTargetChangedType
// NumValues: 0x0005
enum class ELockDeterminedTargetChangedType : uint8
{
	TargetExist                              = 0,
	NotFoundTarget                           = 1,
	MoveToNextTarget                         = 2,
	TryTargetLostAndFoundNewTarget           = 3,
	ELockDeterminedTargetChangedType_MAX     = 4,
};

// Enum ProjectP.ELockOnLocationType
// NumValues: 0x0004
enum class ELockOnLocationType : uint8
{
	Actor                                    = 0,
	ActorBone                                = 1,
	ActorLower                               = 2,
	ELockOnLocationType_MAX                  = 3,
};

// Enum ProjectP.ELockOnNearbyTargetDirection
// NumValues: 0x0006
enum class ELockOnNearbyTargetDirection : uint8
{
	Center                                   = 0,
	Left                                     = 1,
	Right                                    = 2,
	Up                                       = 3,
	Down                                     = 4,
	ELockOnNearbyTargetDirection_MAX         = 5,
};

// Enum ProjectP.ELCharacterExitType
// NumValues: 0x0005
enum class ELCharacterExitType : uint8
{
	None                                     = 0,
	LookHide                                 = 1,
	Invisible                                = 2,
	Despawn                                  = 3,
	ELCharacterExitType_MAX                  = 4,
};

// Enum ProjectP.ELAIFloatValueType
// NumValues: 0x0003
enum class ELAIFloatValueType : uint8
{
	Abs                                      = 0,
	Rate                                     = 1,
	ELAIFloatValueType_MAX                   = 2,
};

// Enum ProjectP.ELAIUseSkillCountType
// NumValues: 0x0004
enum class ELAIUseSkillCountType : uint8
{
	OnlyAIUseSkillCount                      = 0,
	OnlySkillLinkUseSkillCount               = 1,
	All                                      = 2,
	ELAIUseSkillCountType_MAX                = 3,
};

// Enum ProjectP.ELAIRangeCheckFailReason
// NumValues: 0x0009
enum class ELAIRangeCheckFailReason : uint8
{
	None                                     = 0,
	Dist                                     = 1,
	Angle                                    = 2,
	Path_Direct                              = 3,
	Path_Direct_Navi                         = 4,
	Path_Navi                                = 5,
	Path_Direct_Projectile                   = 6,
	Etc                                      = 7,
	ELAIRangeCheckFailReason_MAX             = 8,
};

// Enum ProjectP.ELAIChangeMoveType
// NumValues: 0x0003
enum class ELAIChangeMoveType : uint8
{
	Normal                                   = 0,
	Sprint                                   = 1,
	ELAIChangeMoveType_MAX                   = 2,
};

// Enum ProjectP.ELAIHitDamageType
// NumValues: 0x0005
enum class ELAIHitDamageType : uint8
{
	None                                     = 0,
	OnlyDamage                               = 1,
	OnlyHitAction                            = 2,
	All                                      = 3,
	ELAIHitDamageType_MAX                    = 4,
};

// Enum ProjectP.ELAITakeDamageType
// NumValues: 0x0005
enum class ELAITakeDamageType : uint8
{
	None                                     = 0,
	OnlyDamage                               = 1,
	OnlyHitAction                            = 2,
	All                                      = 3,
	ELAITakeDamageType_MAX                   = 4,
};

// Enum ProjectP.ELAISense
// NumValues: 0x0008
enum class ELAISense : uint8
{
	None                                     = 0,
	Sight                                    = 1,
	Damage                                   = 2,
	DamageForce                              = 3,
	Sensitive                                = 4,
	Warning                                  = 5,
	WarningDamage                            = 6,
	Max                                      = 7,
};

// Enum ProjectP.ELAIActorClassType
// NumValues: 0x0004
enum class ELAIActorClassType : uint8
{
	PC                                       = 0,
	NPC                                      = 1,
	Prop                                     = 2,
	ELAIActorClassType_MAX                   = 3,
};

// Enum ProjectP.ELAISendWorldTriggerType
// NumValues: 0x0003
enum class ELAISendWorldTriggerType : uint8
{
	NPC                                      = 0,
	WorldEvent                               = 1,
	ELAISendWorldTriggerType_MAX             = 2,
};

// Enum ProjectP.ELAITargetPointType
// NumValues: 0x0003
enum class ELAITargetPointType : uint8
{
	Point1                                   = 0,
	Point2                                   = 1,
	ELAITargetPointType_MAX                  = 2,
};

// Enum ProjectP.ELAIDirectionType
// NumValues: 0x0005
enum class ELAIDirectionType : uint8
{
	Movement                                 = 0,
	PrimaryTarget                            = 1,
	Home                                     = 2,
	MovementReverse                          = 3,
	ELAIDirectionType_MAX                    = 4,
};

// Enum ProjectP.ELAITargetType
// NumValues: 0x0007
enum class ELAITargetType : uint8
{
	Self                                     = 0,
	PrimaryTarget                            = 1,
	Home                                     = 2,
	Master                                   = 3,
	TargetPoint1                             = 4,
	TargetPoint2                             = 5,
	ELAITargetType_MAX                       = 6,
};

// Enum ProjectP.ELLogicalCondition
// NumValues: 0x0002
enum class ELLogicalCondition : uint8
{
	InHitAction                              = 0,
	ELLogicalCondition_MAX                   = 1,
};

// Enum ProjectP.ELModifyCooltimeTargetType
// NumValues: 0x0003
enum class ELModifyCooltimeTargetType : uint8
{
	GlobalCooltime                           = 0,
	SkillCooltime                            = 1,
	ELModifyCooltimeTargetType_MAX           = 2,
};

// Enum ProjectP.ELModifyCooltimeChangeType
// NumValues: 0x0003
enum class ELModifyCooltimeChangeType : uint8
{
	Current                                  = 0,
	MinMax                                   = 1,
	ELModifyCooltimeChangeType_MAX           = 2,
};

// Enum ProjectP.ELAIRangeMinMaxType
// NumValues: 0x0004
enum class ELAIRangeMinMaxType : uint8
{
	None                                     = 0,
	Min                                      = 1,
	Max                                      = 2,
	Both                                     = 3,
};

// Enum ProjectP.ELAISkillRangeMinMaxType
// NumValues: 0x0003
enum class ELAISkillRangeMinMaxType : uint8
{
	Min                                      = 0,
	Max                                      = 1,
	Both                                     = 2,
};

// Enum ProjectP.ELNPCSpotTriggerType
// NumValues: 0x0007
enum class ELNPCSpotTriggerType : uint8
{
	UseSkill                                 = 0,
	RemovePauseAI                            = 1,
	TriggerPathWay                           = 2,
	WakeUp                                   = 3,
	SpawnIdleEnd                             = 4,
	FloatingStop                             = 5,
	ELNPCSpotTriggerType_MAX                 = 6,
};

// Enum ProjectP.ELQueryTargetConditionType
// NumValues: 0x0005
enum class ELQueryTargetConditionType : uint8
{
	IsDeadPC                                 = 0,
	IsReactionHit                            = 1,
	IsReactionKnockback                      = 2,
	IsReactionDown                           = 3,
	ELQueryTargetConditionType_MAX           = 4,
};

// Enum ProjectP.ELGoldenTreeState
// NumValues: 0x0005
enum class ELGoldenTreeState : uint8
{
	Normal                                   = 0,
	Booster                                  = 1,
	Harvestable                              = 2,
	Harvestable_Boostly                      = 3,
	ELGoldenTreeState_MAX                    = 4,
};

// Enum ProjectP.ELFramerateLimit
// NumValues: 0x000B
enum class ELFramerateLimit : uint8
{
	ELFramerateLimit_Unlimit                 = 0,
	ELFramerateLimit_30                      = 1,
	ELFramerateLimit_40                      = 2,
	ELFramerateLimit_60                      = 3,
	ELFramerateLimit_72                      = 4,
	ELFramerateLimit_75                      = 5,
	ELFramerateLimit_120                     = 6,
	ELFramerateLimit_144                     = 7,
	ELFramerateLimit_165                     = 8,
	ELFramerateLimit_240                     = 9,
	ELFramerateLimit_MAX                     = 10,
};

// Enum ProjectP.ELHUDVisible
// NumValues: 0x0003
enum class ELHUDVisible : uint8
{
	On                                       = 0,
	Off                                      = 1,
	ELHUDVisible_MAX                         = 2,
};

// Enum ProjectP.ELScalabilityDefaultLevel
// NumValues: 0x0005
enum class ELScalabilityDefaultLevel : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Epic                                     = 3,
	ELScalabilityDefaultLevel_MAX            = 4,
};

// Enum ProjectP.ELScalabilityLevel
// NumValues: 0x0006
enum class ELScalabilityLevel : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Epic                                     = 3,
	Custom                                   = 4,
	ELScalabilityLevel_MAX                   = 5,
};

// Enum ProjectP.ELInputOptionType
// NumValues: 0x0005
enum class ELInputOptionType : uint8
{
	CurrentController                        = 0,
	GamePad                                  = 1,
	Keyboard                                 = 2,
	All                                      = 3,
	ELInputOptionType_MAX                    = 4,
};

// Enum ProjectP.EScalabilityType
// NumValues: 0x0016
enum class EScalabilityType : uint8
{
	RenderScale                              = 0,
	Viewdistance                             = 1,
	Antialiasing                             = 2,
	Postprocess                              = 3,
	Shadow                                   = 4,
	Texture                                  = 5,
	Effects                                  = 6,
	Foliage                                  = 7,
	Shading                                  = 8,
	Anisotropy                               = 9,
	Atmosphere                               = 10,
	AmbientOcclusion                         = 11,
	Reflection                               = 12,
	FSR                                      = 13,
	RayTracing                               = 14,
	FrameRate                                = 15,
	Resolution                               = 16,
	DynamicResMode                           = 17,
	DynamicResMin                            = 18,
	DynamicResMax                            = 19,
	DynamicResTimeUS                         = 20,
	EScalabilityType_MAX                     = 21,
};

// Enum ProjectP.EPlayStyleOption
// NumValues: 0x0003
enum class EPlayStyleOption : uint8
{
	VisualStyle                              = 0,
	ActionStyle                              = 1,
	EPlayStyleOption_MAX                     = 2,
};

// Enum ProjectP.ECameraDirectOption
// NumValues: 0x0003
enum class ECameraDirectOption : uint8
{
	Vertical                                 = 0,
	Horizontal                               = 1,
	ECameraDirectOption_MAX                  = 2,
};

// Enum ProjectP.ELPatchRewardItemReceiveResult
// NumValues: 0x0006
enum class ELPatchRewardItemReceiveResult : uint8
{
	Success                                  = 0,
	InventoryFull                            = 1,
	AlreadyHave                              = 2,
	InvalidInfo                              = 3,
	InvalidData                              = 4,
	ELPatchRewardItemReceiveResult_MAX       = 5,
};

// Enum ProjectP.ELLookAtHeadState
// NumValues: 0x0005
enum class ELLookAtHeadState : uint8
{
	Idle                                     = 0,
	DialogTalker                             = 1,
	Prop                                     = 2,
	WatchHolding                             = 3,
	ELLookAtHeadState_MAX                    = 4,
};

// Enum ProjectP.ELAudioListenerPositionType
// NumValues: 0x0006
enum class ELAudioListenerPositionType : uint8
{
	Character                                = 0,
	Camera                                   = 1,
	StatRoom                                 = 2,
	CustomLocation                           = 3,
	AudioListenerPosComponent                = 4,
	ELAudioListenerPositionType_MAX          = 5,
};

// Enum ProjectP.ELPhysicsState
// NumValues: 0x0009
enum class ELPhysicsState : uint8
{
	None                                     = 0,
	NoPhysics                                = 1,
	PhysicalAnimation                        = 2,
	RagDoll                                  = 3,
	Explosion                                = 4,
	RagDollFreeze                            = 5,
	Reset                                    = 6,
	ChangePhysicsAsset                       = 7,
	Max                                      = 8,
};

// Enum ProjectP.ELPhysicalSurfaceFXConditionType
// NumValues: 0x0003
enum class ELPhysicalSurfaceFXConditionType : uint8
{
	Default                                  = 0,
	WaterVolume                              = 1,
	ELPhysicalSurfaceFXConditionType_MAX     = 2,
};

// Enum ProjectP.ELLaunchActivityErrorType
// NumValues: 0x0004
enum class ELLaunchActivityErrorType : uint8
{
	None                                     = 0,
	DeleteSaveData                           = 1,
	BreakSaveData                            = 2,
	ELLaunchActivityErrorType_MAX            = 3,
};

// Enum ProjectP.ELPickWeaponChangeMotionType
// NumValues: 0x0003
enum class ELPickWeaponChangeMotionType : uint8
{
	DoChange                                 = 0,
	NotChange                                = 1,
	ELPickWeaponChangeMotionType_MAX         = 2,
};

// Enum ProjectP.ELShopProductType
// NumValues: 0x0004
enum class ELShopProductType : uint8
{
	None                                     = 0,
	Buy                                      = 1,
	Special                                  = 2,
	ELShopProductType_MAX                    = 3,
};

// Enum ProjectP.ELChaseProjectileState
// NumValues: 0x0005
enum class ELChaseProjectileState : uint8
{
	None                                     = 0,
	Detecting                                = 1,
	Chasing                                  = 2,
	Abandon                                  = 3,
	ELChaseProjectileState_MAX               = 4,
};

// Enum ProjectP.ELProjectileMoveStep
// NumValues: 0x0005
enum class ELProjectileMoveStep : uint8
{
	None                                     = 0,
	Init                                     = 1,
	Mid                                      = 2,
	Final                                    = 3,
	ELProjectileMoveStep_MAX                 = 4,
};

// Enum ProjectP.ELProjectileDestroyConditionType
// NumValues: 0x0003
enum class ELProjectileDestroyConditionType : uint8
{
	Disappear                                = 0,
	Explode                                  = 1,
	ELProjectileDestroyConditionType_MAX     = 2,
};

// Enum ProjectP.EProjectileSpawnGenerateEnumType
// NumValues: 0x0003
enum class EProjectileSpawnGenerateEnumType : uint8
{
	OnExplode                                = 0,
	Periodic                                 = 1,
	EProjectileSpawnGenerateEnumType_MAX     = 2,
};

// Enum ProjectP.ELProjectileDestroyReason
// NumValues: 0x0009
enum class ELProjectileDestroyReason : uint8
{
	None                                     = 0,
	LifeTimeOver                             = 1,
	DistanceOver                             = 2,
	CharacterHit                             = 3,
	DestructibleHit                          = 4,
	BlockHit                                 = 5,
	CustomHit                                = 6,
	RootOwnerDeath                           = 7,
	ELProjectileDestroyReason_MAX            = 8,
};

// Enum ProjectP.EProjectileHitGenerateEnumType
// NumValues: 0x0005
enum class EProjectileHitGenerateEnumType : uint8
{
	HitTarget                                = 0,
	OnOverlap                                = 1,
	OnExplode                                = 2,
	Periodic                                 = 3,
	EProjectileHitGenerateEnumType_MAX       = 4,
};

// Enum ProjectP.ELAdditionalDestructionTargetType
// NumValues: 0x0004
enum class ELAdditionalDestructionTargetType : uint8
{
	ALL                                      = 0,
	PC                                       = 1,
	NPC                                      = 2,
	ELAdditionalDestructionTargetType_MAX    = 3,
};

// Enum ProjectP.ELAdditionalDestructionType
// NumValues: 0x0004
enum class ELAdditionalDestructionType : uint8
{
	None                                     = 0,
	VolumeEnter                              = 1,
	VolumeExit                               = 2,
	ELAdditionalDestructionType_MAX          = 3,
};

// Enum ProjectP.ELPropVolumeEvent
// NumValues: 0x0004
enum class ELPropVolumeEvent : uint8
{
	NONE                                     = 0,
	ENTER                                    = 1,
	EXIT                                     = 2,
	ELPropVolumeEvent_MAX                    = 3,
};

// Enum ProjectP.ELLinkedPropExecuteType
// NumValues: 0x0005
enum class ELLinkedPropExecuteType : uint8
{
	ChangePropState                          = 0,
	PropInteractionStart                     = 1,
	PropInteractionEnd                       = 2,
	CrashDestructObject                      = 3,
	ELLinkedPropExecuteType_MAX              = 4,
};

// Enum ProjectP.ELQuartzSlotStatusType
// NumValues: 0x0003
enum class ELQuartzSlotStatusType : uint8
{
	Empty                                    = 0,
	Installed                                = 1,
	ELQuartzSlotStatusType_MAX               = 2,
};

// Enum ProjectP.ELCoreLevelUpType
// NumValues: 0x0004
enum class ELCoreLevelUpType : uint8
{
	None                                     = 0,
	UseCoreItem                              = 1,
	GainSynergy                              = 2,
	ELCoreLevelUpType_MAX                    = 3,
};

// Enum ProjectP.ELSoundPlayWeatherCondition
// NumValues: 0x0004
enum class ELSoundPlayWeatherCondition : uint8
{
	None                                     = 0,
	Raining                                  = 1,
	Not_Raining                              = 2,
	ELSoundPlayWeatherCondition_MAX          = 3,
};

// Enum ProjectP.ELVolumeType
// NumValues: 0x0008
enum class ELVolumeType : uint8
{
	Master                                   = 0,
	BGM                                      = 1,
	Ambience                                 = 2,
	Character                                = 3,
	Cinematics                               = 4,
	System                                   = 5,
	Voice                                    = 6,
	Max                                      = 7,
};

// Enum ProjectP.ELSoundVolumeType
// NumValues: 0x0003
enum class ELSoundVolumeType : uint8
{
	None                                     = 0,
	BGM                                      = 1,
	ELSoundVolumeType_MAX                    = 2,
};

// Enum ProjectP.ELSpecialBuffSaveType
// NumValues: 0x0003
enum class ELSpecialBuffSaveType : uint8
{
	NeedToSave                               = 0,
	WillBeLoadedFromSavedParentContent       = 1,
	ELSpecialBuffSaveType_MAX                = 2,
};

// Enum ProjectP.ELPreloadSpotSetting
// NumValues: 0x0004
enum class ELPreloadSpotSetting : uint8
{
	UseGameSettings                          = 0,
	AlwaysOn                                 = 1,
	AlwaysOff                                = 2,
	ELPreloadSpotSetting_MAX                 = 3,
};

// Enum ProjectP.ELLoadingScreenUsage
// NumValues: 0x0004
enum class ELLoadingScreenUsage : uint8
{
	None                                     = 0,
	WorldLoadingWithProgress                 = 1,
	InGameLoading                            = 2,
	ELLoadingScreenUsage_MAX                 = 3,
};

// Enum ProjectP.ELLoadingScreenType
// NumValues: 0x0006
enum class ELLoadingScreenType : uint8
{
	None                                     = 0,
	WorldLoadingProgress                     = 1,
	WorldLoadingOnly                         = 2,
	InGameLoading                            = 3,
	InGameFlushLevelStreaming                = 4,
	ELLoadingScreenType_MAX                  = 5,
};

// Enum ProjectP.ELWidgetDepth
// NumValues: 0x0004
enum class ELWidgetDepth : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	ELWidgetDepth_MAX                        = 3,
};

// Enum ProjectP.ELWidgetLoading
// NumValues: 0x0003
enum class ELWidgetLoading : uint8
{
	PreLoading                               = 0,
	PostLoading                              = 1,
	ELWidgetLoading_MAX                      = 2,
};

// Enum ProjectP.ETweenEasingType
// NumValues: 0x000F
enum class ETweenEasingType : uint8
{
	Linear                                   = 0,
	Step                                     = 1,
	SinusoidalIn                             = 2,
	SinusoidalOut                            = 3,
	SinusoidalInOut                          = 4,
	EaseIn                                   = 5,
	EaseOut                                  = 6,
	EaseInOut                                = 7,
	ExpoIn                                   = 8,
	ExpoOut                                  = 9,
	ExpoInOut                                = 10,
	CircularIn                               = 11,
	CircularOut                              = 12,
	CircularInOut                            = 13,
	ETweenEasingType_MAX                     = 14,
};

// Enum ProjectP.ELWorldMapType
// NumValues: 0x0007
enum class ELWorldMapType : uint8
{
	Init                                     = 0,
	Lobby                                    = 1,
	PlayStart                                = 2,
	NewGamePlus                              = 3,
	Gallery                                  = 4,
	Max                                      = 5,
	None                                     = 6,
};

// ScriptStruct ProjectP.LHitMeshParts
// 0x0070 (0x0070 - 0x0000)
struct FLHitMeshParts final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InitRelativeTransform;                             // 0x0010(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillCodeNameOnDestory;                            // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLastEnable : 1;                                   // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPrevChangedEnable : 1;                            // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableWhenSpawn : 1;                              // 0x0050(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PartsHP;                                           // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0058(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x14];                                      // 0x005C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLHitMeshParts) == 0x000010, "Wrong alignment on FLHitMeshParts");
static_assert(sizeof(FLHitMeshParts) == 0x000070, "Wrong size on FLHitMeshParts");
static_assert(offsetof(FLHitMeshParts, PrimitiveComponent) == 0x000000, "Member 'FLHitMeshParts::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(FLHitMeshParts, InitRelativeTransform) == 0x000010, "Member 'FLHitMeshParts::InitRelativeTransform' has a wrong offset!");
static_assert(offsetof(FLHitMeshParts, AttachSocketName) == 0x000040, "Member 'FLHitMeshParts::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FLHitMeshParts, SkillCodeNameOnDestory) == 0x000048, "Member 'FLHitMeshParts::SkillCodeNameOnDestory' has a wrong offset!");
static_assert(offsetof(FLHitMeshParts, PartsHP) == 0x000054, "Member 'FLHitMeshParts::PartsHP' has a wrong offset!");
static_assert(offsetof(FLHitMeshParts, MaxHP) == 0x000058, "Member 'FLHitMeshParts::MaxHP' has a wrong offset!");

// ScriptStruct ProjectP.LCapturer_Tick
// 0x000C (0x000C - 0x0000)
struct FLCapturer_Tick final
{
public:
	int32                                         TotalTick;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextTick;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x4];                                        // 0x0008(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCapturer_Tick) == 0x000004, "Wrong alignment on FLCapturer_Tick");
static_assert(sizeof(FLCapturer_Tick) == 0x00000C, "Wrong size on FLCapturer_Tick");
static_assert(offsetof(FLCapturer_Tick, TotalTick) == 0x000000, "Member 'FLCapturer_Tick::TotalTick' has a wrong offset!");
static_assert(offsetof(FLCapturer_Tick, NextTick) == 0x000004, "Member 'FLCapturer_Tick::NextTick' has a wrong offset!");

// ScriptStruct ProjectP.LGrabResultInfo
// 0x0038 (0x0038 - 0x0000)
struct FLGrabResultInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Cached_Grab_Victim;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Cached_Grab_Attacker;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Cached_IsBackHit : 1;                              // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Cached_AttackerSocketName;                         // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cached_TargetSocketName;                           // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cached_AttachTargetSocketName;                     // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Cached_AttachedSocketName;                         // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Cached_NeedMeshTransformSync : 1;                  // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGrabResultInfo) == 0x000004, "Wrong alignment on FLGrabResultInfo");
static_assert(sizeof(FLGrabResultInfo) == 0x000038, "Wrong size on FLGrabResultInfo");
static_assert(offsetof(FLGrabResultInfo, Cached_Grab_Victim) == 0x000000, "Member 'FLGrabResultInfo::Cached_Grab_Victim' has a wrong offset!");
static_assert(offsetof(FLGrabResultInfo, Cached_Grab_Attacker) == 0x000008, "Member 'FLGrabResultInfo::Cached_Grab_Attacker' has a wrong offset!");
static_assert(offsetof(FLGrabResultInfo, Cached_AttackerSocketName) == 0x000014, "Member 'FLGrabResultInfo::Cached_AttackerSocketName' has a wrong offset!");
static_assert(offsetof(FLGrabResultInfo, Cached_TargetSocketName) == 0x00001C, "Member 'FLGrabResultInfo::Cached_TargetSocketName' has a wrong offset!");
static_assert(offsetof(FLGrabResultInfo, Cached_AttachTargetSocketName) == 0x000024, "Member 'FLGrabResultInfo::Cached_AttachTargetSocketName' has a wrong offset!");
static_assert(offsetof(FLGrabResultInfo, Cached_AttachedSocketName) == 0x00002C, "Member 'FLGrabResultInfo::Cached_AttachedSocketName' has a wrong offset!");

// ScriptStruct ProjectP.LHitIndexInfo
// 0x0014 (0x0014 - 0x0000)
struct FLHitIndexInfo final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitIndex;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickInterval_MaxCount;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLHitIndexInfo) == 0x000004, "Wrong alignment on FLHitIndexInfo");
static_assert(sizeof(FLHitIndexInfo) == 0x000014, "Wrong size on FLHitIndexInfo");
static_assert(offsetof(FLHitIndexInfo, SkillCodeName) == 0x000000, "Member 'FLHitIndexInfo::SkillCodeName' has a wrong offset!");
static_assert(offsetof(FLHitIndexInfo, HitIndex) == 0x000008, "Member 'FLHitIndexInfo::HitIndex' has a wrong offset!");
static_assert(offsetof(FLHitIndexInfo, TickInterval) == 0x00000C, "Member 'FLHitIndexInfo::TickInterval' has a wrong offset!");
static_assert(offsetof(FLHitIndexInfo, TickInterval_MaxCount) == 0x000010, "Member 'FLHitIndexInfo::TickInterval_MaxCount' has a wrong offset!");

// ScriptStruct ProjectP.LGameObjectHandle
// 0x0004 (0x0004 - 0x0000)
struct FLGameObjectHandle final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLGameObjectHandle) == 0x000004, "Wrong alignment on FLGameObjectHandle");
static_assert(sizeof(FLGameObjectHandle) == 0x000004, "Wrong size on FLGameObjectHandle");
static_assert(offsetof(FLGameObjectHandle, ID) == 0x000000, "Member 'FLGameObjectHandle::ID' has a wrong offset!");

// ScriptStruct ProjectP.LHitContext
// 0x0074 (0x0074 - 0x0000)
struct FLHitContext final
{
public:
	ELWeaponAttachPointType                       WeaponAttachPointType;                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPartsAttachPointType                        PartsAttachPointType;                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLGrabResultInfo                       GrabResultInfo;                                    // 0x0004(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLHitIndexInfo                         HitIndexInfo;                                      // 0x003C(0x0014)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         HitGroup;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEventTime;                                      // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContextStartTime;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContextEndTime;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 HitDescribeObject;                                 // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Handle;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Handle_OwnerAction;                                // 0x006C(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableSpark;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRepulse;                                    // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitFxLocationType                           HitFxLocationOverrideType;                         // 0x0072(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x1];                                       // 0x0073(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLHitContext) == 0x000004, "Wrong alignment on FLHitContext");
static_assert(sizeof(FLHitContext) == 0x000074, "Wrong size on FLHitContext");
static_assert(offsetof(FLHitContext, WeaponAttachPointType) == 0x000000, "Member 'FLHitContext::WeaponAttachPointType' has a wrong offset!");
static_assert(offsetof(FLHitContext, PartsAttachPointType) == 0x000001, "Member 'FLHitContext::PartsAttachPointType' has a wrong offset!");
static_assert(offsetof(FLHitContext, GrabResultInfo) == 0x000004, "Member 'FLHitContext::GrabResultInfo' has a wrong offset!");
static_assert(offsetof(FLHitContext, HitIndexInfo) == 0x00003C, "Member 'FLHitContext::HitIndexInfo' has a wrong offset!");
static_assert(offsetof(FLHitContext, HitGroup) == 0x000050, "Member 'FLHitContext::HitGroup' has a wrong offset!");
static_assert(offsetof(FLHitContext, HitEventTime) == 0x000054, "Member 'FLHitContext::HitEventTime' has a wrong offset!");
static_assert(offsetof(FLHitContext, ContextStartTime) == 0x000058, "Member 'FLHitContext::ContextStartTime' has a wrong offset!");
static_assert(offsetof(FLHitContext, ContextEndTime) == 0x00005C, "Member 'FLHitContext::ContextEndTime' has a wrong offset!");
static_assert(offsetof(FLHitContext, HitDescribeObject) == 0x000060, "Member 'FLHitContext::HitDescribeObject' has a wrong offset!");
static_assert(offsetof(FLHitContext, Handle) == 0x000068, "Member 'FLHitContext::Handle' has a wrong offset!");
static_assert(offsetof(FLHitContext, Handle_OwnerAction) == 0x00006C, "Member 'FLHitContext::Handle_OwnerAction' has a wrong offset!");
static_assert(offsetof(FLHitContext, bEnableSpark) == 0x000070, "Member 'FLHitContext::bEnableSpark' has a wrong offset!");
static_assert(offsetof(FLHitContext, bEnableRepulse) == 0x000071, "Member 'FLHitContext::bEnableRepulse' has a wrong offset!");
static_assert(offsetof(FLHitContext, HitFxLocationOverrideType) == 0x000072, "Member 'FLHitContext::HitFxLocationOverrideType' has a wrong offset!");

// ScriptStruct ProjectP.LGrabInfo
// 0x0068 (0x0068 - 0x0000)
struct FLGrabInfo final
{
public:
	bool                                          IsValidInfo;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachToAttacker;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttackerSocketName;                                // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSocketName;                                  // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELLinkedSkillUseType                          LinkedSkillUseType;                                // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LinkedSkillCodeName;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrabCancelSkillCodeName;                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowTargetDeath;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           TargetMontageFront;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TargetMontageBack;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AngleCheck : 1;                                    // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FrontAttackerSocket;                               // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FrontTargetSocket;                                 // 0x004C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackAttackerSocket;                                // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BackTargetSocket;                                  // 0x005C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGrabInfo) == 0x000008, "Wrong alignment on FLGrabInfo");
static_assert(sizeof(FLGrabInfo) == 0x000068, "Wrong size on FLGrabInfo");
static_assert(offsetof(FLGrabInfo, IsValidInfo) == 0x000000, "Member 'FLGrabInfo::IsValidInfo' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, AttachToAttacker) == 0x000001, "Member 'FLGrabInfo::AttachToAttacker' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, AttackerSocketName) == 0x000004, "Member 'FLGrabInfo::AttackerSocketName' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, TargetSocketName) == 0x00000C, "Member 'FLGrabInfo::TargetSocketName' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, LinkedSkillUseType) == 0x000014, "Member 'FLGrabInfo::LinkedSkillUseType' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, LinkedSkillCodeName) == 0x000018, "Member 'FLGrabInfo::LinkedSkillCodeName' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, GrabCancelSkillCodeName) == 0x000020, "Member 'FLGrabInfo::GrabCancelSkillCodeName' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, AllowTargetDeath) == 0x000028, "Member 'FLGrabInfo::AllowTargetDeath' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, TargetMontageFront) == 0x000030, "Member 'FLGrabInfo::TargetMontageFront' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, TargetMontageBack) == 0x000038, "Member 'FLGrabInfo::TargetMontageBack' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, FrontAttackerSocket) == 0x000044, "Member 'FLGrabInfo::FrontAttackerSocket' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, FrontTargetSocket) == 0x00004C, "Member 'FLGrabInfo::FrontTargetSocket' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, BackAttackerSocket) == 0x000054, "Member 'FLGrabInfo::BackAttackerSocket' has a wrong offset!");
static_assert(offsetof(FLGrabInfo, BackTargetSocket) == 0x00005C, "Member 'FLGrabInfo::BackTargetSocket' has a wrong offset!");

// ScriptStruct ProjectP.LHitInfo
// 0x0150 (0x0150 - 0x0000)
struct FLHitInfo final
{
public:
	struct FLHitContext                           HitContext;                                        // 0x0000(0x0074)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   SkillCodeName;                                     // 0x0074(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x007C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName_Origin;                           // 0x0084(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitGroup;                                          // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitIndex;                                          // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageCauserCodeName;                              // 0x0094(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Attacker;                                          // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    AttackerComponent;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGrabInfo                             GrabInfo;                                          // 0x00B0(0x0068)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HitTraceDirection;                                 // 0x0118(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0124(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGuarding;                                        // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGuarding_Perfect;                                // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsParalyzeTriggered;                               // 0x0132(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_133[0x1];                                      // 0x0133(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitAngle;                                          // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RepulseByGuardReflect : 1;                         // 0x0138(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IsFatalEndHit : 1;                                 // 0x0138(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          IsCritical;                                        // 0x0139(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Attack_PhysicalSurface;                            // 0x013A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Victim_PhysicalSurface;                            // 0x013B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALWeapon>                Weapon;                                            // 0x013C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULPartsComponent>        AttackerBodyWeaponComp;                            // 0x0144(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLHitInfo) == 0x000008, "Wrong alignment on FLHitInfo");
static_assert(sizeof(FLHitInfo) == 0x000150, "Wrong size on FLHitInfo");
static_assert(offsetof(FLHitInfo, HitContext) == 0x000000, "Member 'FLHitInfo::HitContext' has a wrong offset!");
static_assert(offsetof(FLHitInfo, SkillCodeName) == 0x000074, "Member 'FLHitInfo::SkillCodeName' has a wrong offset!");
static_assert(offsetof(FLHitInfo, SkillHitCodeName) == 0x00007C, "Member 'FLHitInfo::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(FLHitInfo, SkillHitCodeName_Origin) == 0x000084, "Member 'FLHitInfo::SkillHitCodeName_Origin' has a wrong offset!");
static_assert(offsetof(FLHitInfo, HitGroup) == 0x00008C, "Member 'FLHitInfo::HitGroup' has a wrong offset!");
static_assert(offsetof(FLHitInfo, HitIndex) == 0x000090, "Member 'FLHitInfo::HitIndex' has a wrong offset!");
static_assert(offsetof(FLHitInfo, DamageCauserCodeName) == 0x000094, "Member 'FLHitInfo::DamageCauserCodeName' has a wrong offset!");
static_assert(offsetof(FLHitInfo, Attacker) == 0x0000A0, "Member 'FLHitInfo::Attacker' has a wrong offset!");
static_assert(offsetof(FLHitInfo, AttackerComponent) == 0x0000A8, "Member 'FLHitInfo::AttackerComponent' has a wrong offset!");
static_assert(offsetof(FLHitInfo, GrabInfo) == 0x0000B0, "Member 'FLHitInfo::GrabInfo' has a wrong offset!");
static_assert(offsetof(FLHitInfo, HitTraceDirection) == 0x000118, "Member 'FLHitInfo::HitTraceDirection' has a wrong offset!");
static_assert(offsetof(FLHitInfo, HitLocation) == 0x000124, "Member 'FLHitInfo::HitLocation' has a wrong offset!");
static_assert(offsetof(FLHitInfo, IsGuarding) == 0x000130, "Member 'FLHitInfo::IsGuarding' has a wrong offset!");
static_assert(offsetof(FLHitInfo, IsGuarding_Perfect) == 0x000131, "Member 'FLHitInfo::IsGuarding_Perfect' has a wrong offset!");
static_assert(offsetof(FLHitInfo, IsParalyzeTriggered) == 0x000132, "Member 'FLHitInfo::IsParalyzeTriggered' has a wrong offset!");
static_assert(offsetof(FLHitInfo, HitAngle) == 0x000134, "Member 'FLHitInfo::HitAngle' has a wrong offset!");
static_assert(offsetof(FLHitInfo, IsCritical) == 0x000139, "Member 'FLHitInfo::IsCritical' has a wrong offset!");
static_assert(offsetof(FLHitInfo, Attack_PhysicalSurface) == 0x00013A, "Member 'FLHitInfo::Attack_PhysicalSurface' has a wrong offset!");
static_assert(offsetof(FLHitInfo, Victim_PhysicalSurface) == 0x00013B, "Member 'FLHitInfo::Victim_PhysicalSurface' has a wrong offset!");
static_assert(offsetof(FLHitInfo, Weapon) == 0x00013C, "Member 'FLHitInfo::Weapon' has a wrong offset!");
static_assert(offsetof(FLHitInfo, AttackerBodyWeaponComp) == 0x000144, "Member 'FLHitInfo::AttackerBodyWeaponComp' has a wrong offset!");

// ScriptStruct ProjectP.LSpotListManagement
// 0x0028 (0x0028 - 0x0000)
struct FLSpotListManagement final
{
public:
	TArray<TWeakObjectPtr<class ALSpot>>          OutboundSpotList;                                  // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ALSpot>>          InboundSpotList;                                   // 0x0010(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSpotListManagement) == 0x000008, "Wrong alignment on FLSpotListManagement");
static_assert(sizeof(FLSpotListManagement) == 0x000028, "Wrong size on FLSpotListManagement");
static_assert(offsetof(FLSpotListManagement, OutboundSpotList) == 0x000000, "Member 'FLSpotListManagement::OutboundSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotListManagement, InboundSpotList) == 0x000010, "Member 'FLSpotListManagement::InboundSpotList' has a wrong offset!");

// ScriptStruct ProjectP.LFxSocketTracerInfo
// 0x0108 (0x0108 - 0x0000)
struct alignas(0x08) FLFxSocketTracerInfo final
{
public:
	TWeakObjectPtr<class UObject>                 Instigator;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         TraceComponent;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         PivotComponent;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UShapeComponent>         FilterCollisionComponent;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseChannelTrace;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CollisionChannelForTest;                           // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileForTest;                           // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceSocketName;                                   // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PivotSocketName;                                   // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FxHitTableCodeName;                                // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceSphereRadius;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTestPivotToTrace;                               // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoRemoveWhenInstigatorDestroyed;                 // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeSpan;                                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawHitPoint;                                      // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugLine;                                     // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNotAdvancedSparkTest;                           // 0x005E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Override_SocketTracerPhysicalSurface;              // 0x005F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLGameObjectHandle                     Handle;                                            // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PrevLocation;                                      // 0x0064(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x98];                                      // 0x0070(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLFxSocketTracerInfo) == 0x000008, "Wrong alignment on FLFxSocketTracerInfo");
static_assert(sizeof(FLFxSocketTracerInfo) == 0x000108, "Wrong size on FLFxSocketTracerInfo");
static_assert(offsetof(FLFxSocketTracerInfo, Instigator) == 0x000000, "Member 'FLFxSocketTracerInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, TraceComponent) == 0x000008, "Member 'FLFxSocketTracerInfo::TraceComponent' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, PivotComponent) == 0x000010, "Member 'FLFxSocketTracerInfo::PivotComponent' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, FilterCollisionComponent) == 0x000018, "Member 'FLFxSocketTracerInfo::FilterCollisionComponent' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, UseChannelTrace) == 0x000020, "Member 'FLFxSocketTracerInfo::UseChannelTrace' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, CollisionChannelForTest) == 0x000021, "Member 'FLFxSocketTracerInfo::CollisionChannelForTest' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, CollisionProfileForTest) == 0x000024, "Member 'FLFxSocketTracerInfo::CollisionProfileForTest' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, TraceSocketName) == 0x00002C, "Member 'FLFxSocketTracerInfo::TraceSocketName' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, PivotSocketName) == 0x000034, "Member 'FLFxSocketTracerInfo::PivotSocketName' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, FxHitTableCodeName) == 0x00003C, "Member 'FLFxSocketTracerInfo::FxHitTableCodeName' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, TraceSphereRadius) == 0x000044, "Member 'FLFxSocketTracerInfo::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, UseTestPivotToTrace) == 0x000048, "Member 'FLFxSocketTracerInfo::UseTestPivotToTrace' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, AutoRemoveWhenInstigatorDestroyed) == 0x000049, "Member 'FLFxSocketTracerInfo::AutoRemoveWhenInstigatorDestroyed' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, LifeSpan) == 0x00004C, "Member 'FLFxSocketTracerInfo::LifeSpan' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, ElapsedTime) == 0x000050, "Member 'FLFxSocketTracerInfo::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, SkillHitCodeName) == 0x000054, "Member 'FLFxSocketTracerInfo::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, DrawHitPoint) == 0x00005C, "Member 'FLFxSocketTracerInfo::DrawHitPoint' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, DrawDebugLine) == 0x00005D, "Member 'FLFxSocketTracerInfo::DrawDebugLine' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, UseNotAdvancedSparkTest) == 0x00005E, "Member 'FLFxSocketTracerInfo::UseNotAdvancedSparkTest' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, Override_SocketTracerPhysicalSurface) == 0x00005F, "Member 'FLFxSocketTracerInfo::Override_SocketTracerPhysicalSurface' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, Handle) == 0x000060, "Member 'FLFxSocketTracerInfo::Handle' has a wrong offset!");
static_assert(offsetof(FLFxSocketTracerInfo, PrevLocation) == 0x000064, "Member 'FLFxSocketTracerInfo::PrevLocation' has a wrong offset!");

// ScriptStruct ProjectP.LSwingSFXTableRowType
// 0x0118 (0x0120 - 0x0008)
struct FLSwingSFXTableRowType final : public FTableRowBase
{
public:
	class FName                                   CodeName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSkillMotionType                             MotionType;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              SFX_VeryLight;                                     // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_Light;                                         // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_Medium;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_Heavy;                                         // 0x0090(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_VeryHeavy;                                     // 0x00B8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fire_Enchant_CodeName;                             // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Electric_Enchant_CodeName;                         // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Acid_Enchant_CodeName;                             // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Guard_Enchant_CodeName;                            // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Destruction_Enchant_CodeName;                      // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Critical_Enchant_CodeName;                         // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Frenzy_Enchant_CodeName;                           // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tough_Enchant_CodeName;                            // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSwingSFXTableRowType) == 0x000008, "Wrong alignment on FLSwingSFXTableRowType");
static_assert(sizeof(FLSwingSFXTableRowType) == 0x000120, "Wrong size on FLSwingSFXTableRowType");
static_assert(offsetof(FLSwingSFXTableRowType, CodeName) == 0x000008, "Member 'FLSwingSFXTableRowType::CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, MotionType) == 0x000010, "Member 'FLSwingSFXTableRowType::MotionType' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, SFX_VeryLight) == 0x000018, "Member 'FLSwingSFXTableRowType::SFX_VeryLight' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, SFX_Light) == 0x000040, "Member 'FLSwingSFXTableRowType::SFX_Light' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, SFX_Medium) == 0x000068, "Member 'FLSwingSFXTableRowType::SFX_Medium' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, SFX_Heavy) == 0x000090, "Member 'FLSwingSFXTableRowType::SFX_Heavy' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, SFX_VeryHeavy) == 0x0000B8, "Member 'FLSwingSFXTableRowType::SFX_VeryHeavy' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Fire_Enchant_CodeName) == 0x0000E0, "Member 'FLSwingSFXTableRowType::Fire_Enchant_CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Electric_Enchant_CodeName) == 0x0000E8, "Member 'FLSwingSFXTableRowType::Electric_Enchant_CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Acid_Enchant_CodeName) == 0x0000F0, "Member 'FLSwingSFXTableRowType::Acid_Enchant_CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Guard_Enchant_CodeName) == 0x0000F8, "Member 'FLSwingSFXTableRowType::Guard_Enchant_CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Destruction_Enchant_CodeName) == 0x000100, "Member 'FLSwingSFXTableRowType::Destruction_Enchant_CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Critical_Enchant_CodeName) == 0x000108, "Member 'FLSwingSFXTableRowType::Critical_Enchant_CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Frenzy_Enchant_CodeName) == 0x000110, "Member 'FLSwingSFXTableRowType::Frenzy_Enchant_CodeName' has a wrong offset!");
static_assert(offsetof(FLSwingSFXTableRowType, Tough_Enchant_CodeName) == 0x000118, "Member 'FLSwingSFXTableRowType::Tough_Enchant_CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LAchievementStatusInfo
// 0x0020 (0x0020 - 0x0000)
struct FLAchievementStatusInfo final
{
public:
	class FName                                   AchievementCodeName;                               // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllComplete;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  StatusList;                                        // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAchievementStatusInfo) == 0x000008, "Wrong alignment on FLAchievementStatusInfo");
static_assert(sizeof(FLAchievementStatusInfo) == 0x000020, "Wrong size on FLAchievementStatusInfo");
static_assert(offsetof(FLAchievementStatusInfo, AchievementCodeName) == 0x000000, "Member 'FLAchievementStatusInfo::AchievementCodeName' has a wrong offset!");
static_assert(offsetof(FLAchievementStatusInfo, AllComplete) == 0x000008, "Member 'FLAchievementStatusInfo::AllComplete' has a wrong offset!");
static_assert(offsetof(FLAchievementStatusInfo, StatusList) == 0x000010, "Member 'FLAchievementStatusInfo::StatusList' has a wrong offset!");

// ScriptStruct ProjectP.LAchievementSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLAchievementSaveData final
{
public:
	TArray<struct FLAchievementStatusInfo>        StatusInfoList;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAchievementSaveData) == 0x000008, "Wrong alignment on FLAchievementSaveData");
static_assert(sizeof(FLAchievementSaveData) == 0x000010, "Wrong size on FLAchievementSaveData");
static_assert(offsetof(FLAchievementSaveData, StatusInfoList) == 0x000000, "Member 'FLAchievementSaveData::StatusInfoList' has a wrong offset!");

// ScriptStruct ProjectP.LAction_StartRotationInfo
// 0x0028 (0x0028 - 0x0000)
struct FLAction_StartRotationInfo final
{
public:
	struct FVector                                LeverOnStart;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForwardOnStart;                                    // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationTime;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAction_StartRotationInfo) == 0x000004, "Wrong alignment on FLAction_StartRotationInfo");
static_assert(sizeof(FLAction_StartRotationInfo) == 0x000028, "Wrong size on FLAction_StartRotationInfo");
static_assert(offsetof(FLAction_StartRotationInfo, LeverOnStart) == 0x000000, "Member 'FLAction_StartRotationInfo::LeverOnStart' has a wrong offset!");
static_assert(offsetof(FLAction_StartRotationInfo, ForwardOnStart) == 0x00000C, "Member 'FLAction_StartRotationInfo::ForwardOnStart' has a wrong offset!");
static_assert(offsetof(FLAction_StartRotationInfo, Rotation) == 0x000018, "Member 'FLAction_StartRotationInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FLAction_StartRotationInfo, RotationTime) == 0x000024, "Member 'FLAction_StartRotationInfo::RotationTime' has a wrong offset!");

// ScriptStruct ProjectP.LCallBackEventData
// 0x0030 (0x0030 - 0x0000)
struct FLCallBackEventData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELCallBackEventType                           EventType;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventParam1;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventParam2;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCallBackEventData) == 0x000008, "Wrong alignment on FLCallBackEventData");
static_assert(sizeof(FLCallBackEventData) == 0x000030, "Wrong size on FLCallBackEventData");
static_assert(offsetof(FLCallBackEventData, EventType) == 0x000008, "Member 'FLCallBackEventData::EventType' has a wrong offset!");
static_assert(offsetof(FLCallBackEventData, EventParam1) == 0x000010, "Member 'FLCallBackEventData::EventParam1' has a wrong offset!");
static_assert(offsetof(FLCallBackEventData, EventParam2) == 0x000020, "Member 'FLCallBackEventData::EventParam2' has a wrong offset!");

// ScriptStruct ProjectP.LQuestTaskInfo
// 0x0008 (0x0038 - 0x0030)
struct FLQuestTaskInfo final : public FLCallBackEventData
{
public:
	class FName                                   QuestCodeName;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLQuestTaskInfo) == 0x000008, "Wrong alignment on FLQuestTaskInfo");
static_assert(sizeof(FLQuestTaskInfo) == 0x000038, "Wrong size on FLQuestTaskInfo");
static_assert(offsetof(FLQuestTaskInfo, QuestCodeName) == 0x000030, "Member 'FLQuestTaskInfo::QuestCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LBuildupInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FLBuildupInfo final
{
public:
	uint8                                         Pad_0[0x11];                                       // 0x0000(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ReduceClearly;                                     // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxGauge;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentGauge;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Visible;                                           // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Overhit;                                           // 0x001D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLBuildupInfo) == 0x000008, "Wrong alignment on FLBuildupInfo");
static_assert(sizeof(FLBuildupInfo) == 0x000020, "Wrong size on FLBuildupInfo");
static_assert(offsetof(FLBuildupInfo, ReduceClearly) == 0x000011, "Member 'FLBuildupInfo::ReduceClearly' has a wrong offset!");
static_assert(offsetof(FLBuildupInfo, MaxGauge) == 0x000014, "Member 'FLBuildupInfo::MaxGauge' has a wrong offset!");
static_assert(offsetof(FLBuildupInfo, CurrentGauge) == 0x000018, "Member 'FLBuildupInfo::CurrentGauge' has a wrong offset!");
static_assert(offsetof(FLBuildupInfo, Visible) == 0x00001C, "Member 'FLBuildupInfo::Visible' has a wrong offset!");
static_assert(offsetof(FLBuildupInfo, Overhit) == 0x00001D, "Member 'FLBuildupInfo::Overhit' has a wrong offset!");

// ScriptStruct ProjectP.LAbnormalInstigatorInfo
// 0x0010 (0x0010 - 0x0000)
struct FLAbnormalInstigatorInfo final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BuildUpRecoverIncBase;                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AbnormalStatePenaltyBase;                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurabilityMultiplier;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAbnormalInstigatorInfo) == 0x000004, "Wrong alignment on FLAbnormalInstigatorInfo");
static_assert(sizeof(FLAbnormalInstigatorInfo) == 0x000010, "Wrong size on FLAbnormalInstigatorInfo");
static_assert(offsetof(FLAbnormalInstigatorInfo, Enabled) == 0x000000, "Member 'FLAbnormalInstigatorInfo::Enabled' has a wrong offset!");
static_assert(offsetof(FLAbnormalInstigatorInfo, BuildUpRecoverIncBase) == 0x000004, "Member 'FLAbnormalInstigatorInfo::BuildUpRecoverIncBase' has a wrong offset!");
static_assert(offsetof(FLAbnormalInstigatorInfo, AbnormalStatePenaltyBase) == 0x000008, "Member 'FLAbnormalInstigatorInfo::AbnormalStatePenaltyBase' has a wrong offset!");
static_assert(offsetof(FLAbnormalInstigatorInfo, DurabilityMultiplier) == 0x00000C, "Member 'FLAbnormalInstigatorInfo::DurabilityMultiplier' has a wrong offset!");

// ScriptStruct ProjectP.LSimpleAbnormal
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FLSimpleAbnormal
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbnormalName;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Running;                                           // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0xB];                                       // 0x0019(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAbnormalInstigatorInfo               Instigator_Info;                                   // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSimpleAbnormal) == 0x000008, "Wrong alignment on FLSimpleAbnormal");
static_assert(sizeof(FLSimpleAbnormal) == 0x000040, "Wrong size on FLSimpleAbnormal");
static_assert(offsetof(FLSimpleAbnormal, AbnormalName) == 0x000010, "Member 'FLSimpleAbnormal::AbnormalName' has a wrong offset!");
static_assert(offsetof(FLSimpleAbnormal, Running) == 0x000018, "Member 'FLSimpleAbnormal::Running' has a wrong offset!");
static_assert(offsetof(FLSimpleAbnormal, Instigator_Info) == 0x000024, "Member 'FLSimpleAbnormal::Instigator_Info' has a wrong offset!");

// ScriptStruct ProjectP.LDurableAbnormal
// 0x0270 (0x02B0 - 0x0040)
struct FLDurableAbnormal final : public FLSimpleAbnormal
{
public:
	class FName                                   Alter_AbnormalName;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ULAbnormalComponent>     Owner;                                             // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ALWeapon>>        MaterialAppliedWeapons;                            // 0x0058(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALWeapon>                ElementAppliedWeapon;                              // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ControlStatusValue;                                // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrevRunning;                                       // 0x0071(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RemainDuration;                                    // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxDuration;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Forever;                                           // 0x007C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         UniqueId;                                          // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MarkedTakeOff;                                     // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0xAF];                                      // 0x0089(0x00AF)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         EnchantedWeaponId;                                 // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0xF0];                                     // 0x0148(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Capturing;                                         // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLBuildupInfo                          ActiveBuildup;                                     // 0x0240(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsElementalBuildup;                                // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLBuildupInfo                          ActiveGauge;                                       // 0x0268(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_288[0x28];                                     // 0x0288(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDurableAbnormal) == 0x000008, "Wrong alignment on FLDurableAbnormal");
static_assert(sizeof(FLDurableAbnormal) == 0x0002B0, "Wrong size on FLDurableAbnormal");
static_assert(offsetof(FLDurableAbnormal, Alter_AbnormalName) == 0x000040, "Member 'FLDurableAbnormal::Alter_AbnormalName' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, Owner) == 0x000048, "Member 'FLDurableAbnormal::Owner' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, MaterialAppliedWeapons) == 0x000058, "Member 'FLDurableAbnormal::MaterialAppliedWeapons' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, ElementAppliedWeapon) == 0x000068, "Member 'FLDurableAbnormal::ElementAppliedWeapon' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, ControlStatusValue) == 0x000070, "Member 'FLDurableAbnormal::ControlStatusValue' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, PrevRunning) == 0x000071, "Member 'FLDurableAbnormal::PrevRunning' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, RemainDuration) == 0x000074, "Member 'FLDurableAbnormal::RemainDuration' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, MaxDuration) == 0x000078, "Member 'FLDurableAbnormal::MaxDuration' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, Forever) == 0x00007C, "Member 'FLDurableAbnormal::Forever' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, UniqueId) == 0x000080, "Member 'FLDurableAbnormal::UniqueId' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, MarkedTakeOff) == 0x000088, "Member 'FLDurableAbnormal::MarkedTakeOff' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, EnchantedWeaponId) == 0x000138, "Member 'FLDurableAbnormal::EnchantedWeaponId' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, Reason) == 0x000140, "Member 'FLDurableAbnormal::Reason' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, Capturing) == 0x000238, "Member 'FLDurableAbnormal::Capturing' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, ActiveBuildup) == 0x000240, "Member 'FLDurableAbnormal::ActiveBuildup' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, IsElementalBuildup) == 0x000260, "Member 'FLDurableAbnormal::IsElementalBuildup' has a wrong offset!");
static_assert(offsetof(FLDurableAbnormal, ActiveGauge) == 0x000268, "Member 'FLDurableAbnormal::ActiveGauge' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialParamBase
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FLMaterialParamBase
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MaterialSlotName;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationTime;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMaterialParamBase) == 0x000008, "Wrong alignment on FLMaterialParamBase");
static_assert(sizeof(FLMaterialParamBase) == 0x000020, "Wrong size on FLMaterialParamBase");
static_assert(offsetof(FLMaterialParamBase, MaterialSlotName) == 0x000008, "Member 'FLMaterialParamBase::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(FLMaterialParamBase, ParameterName) == 0x000010, "Member 'FLMaterialParamBase::ParameterName' has a wrong offset!");
static_assert(offsetof(FLMaterialParamBase, DurationTime) == 0x000018, "Member 'FLMaterialParamBase::DurationTime' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialParamScalar
// 0x0008 (0x0028 - 0x0020)
struct FLMaterialParamScalar final : public FLMaterialParamBase
{
public:
	float                                         StartValue;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMaterialParamScalar) == 0x000008, "Wrong alignment on FLMaterialParamScalar");
static_assert(sizeof(FLMaterialParamScalar) == 0x000028, "Wrong size on FLMaterialParamScalar");
static_assert(offsetof(FLMaterialParamScalar, StartValue) == 0x000020, "Member 'FLMaterialParamScalar::StartValue' has a wrong offset!");
static_assert(offsetof(FLMaterialParamScalar, EndValue) == 0x000024, "Member 'FLMaterialParamScalar::EndValue' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialParamVector
// 0x0020 (0x0040 - 0x0020)
struct FLMaterialParamVector final : public FLMaterialParamBase
{
public:
	struct FLinearColor                           StartValue;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EndValue;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMaterialParamVector) == 0x000008, "Wrong alignment on FLMaterialParamVector");
static_assert(sizeof(FLMaterialParamVector) == 0x000040, "Wrong size on FLMaterialParamVector");
static_assert(offsetof(FLMaterialParamVector, StartValue) == 0x000020, "Member 'FLMaterialParamVector::StartValue' has a wrong offset!");
static_assert(offsetof(FLMaterialParamVector, EndValue) == 0x000030, "Member 'FLMaterialParamVector::EndValue' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialParamContainer
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLMaterialParamContainer final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMaterialParamContainer) == 0x000008, "Wrong alignment on FLMaterialParamContainer");
static_assert(sizeof(FLMaterialParamContainer) == 0x000050, "Wrong size on FLMaterialParamContainer");

// ScriptStruct ProjectP.LMaterialParamPlayEntity
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLMaterialParamPlayEntity final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EvaluateAlpha;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMaterialParamPlayEntity) == 0x000008, "Wrong alignment on FLMaterialParamPlayEntity");
static_assert(sizeof(FLMaterialParamPlayEntity) == 0x000010, "Wrong size on FLMaterialParamPlayEntity");
static_assert(offsetof(FLMaterialParamPlayEntity, EvaluateAlpha) == 0x000008, "Member 'FLMaterialParamPlayEntity::EvaluateAlpha' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialParamPlayer
// 0x0088 (0x0088 - 0x0000)
struct FLMaterialParamPlayer
{
public:
	TArray<struct FLMaterialParamScalar>          ScalarParams;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLMaterialParamVector>          VectorParams;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPlaying;                                          // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElapsedTime;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLMaterialParamContainer               MaterialContainer;                                 // 0x0028(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLMaterialParamPlayEntity>      PlayEntities;                                      // 0x0078(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLMaterialParamPlayer) == 0x000008, "Wrong alignment on FLMaterialParamPlayer");
static_assert(sizeof(FLMaterialParamPlayer) == 0x000088, "Wrong size on FLMaterialParamPlayer");
static_assert(offsetof(FLMaterialParamPlayer, ScalarParams) == 0x000000, "Member 'FLMaterialParamPlayer::ScalarParams' has a wrong offset!");
static_assert(offsetof(FLMaterialParamPlayer, VectorParams) == 0x000010, "Member 'FLMaterialParamPlayer::VectorParams' has a wrong offset!");
static_assert(offsetof(FLMaterialParamPlayer, bPlaying) == 0x000020, "Member 'FLMaterialParamPlayer::bPlaying' has a wrong offset!");
static_assert(offsetof(FLMaterialParamPlayer, ElapsedTime) == 0x000024, "Member 'FLMaterialParamPlayer::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FLMaterialParamPlayer, MaterialContainer) == 0x000028, "Member 'FLMaterialParamPlayer::MaterialContainer' has a wrong offset!");
static_assert(offsetof(FLMaterialParamPlayer, PlayEntities) == 0x000078, "Member 'FLMaterialParamPlayer::PlayEntities' has a wrong offset!");

// ScriptStruct ProjectP.LLogicCondition
// 0x0050 (0x0050 - 0x0000)
struct FLLogicCondition final
{
public:
	TSet<ELLogicalCondition>                      Conditions;                                        // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLLogicCondition) == 0x000008, "Wrong alignment on FLLogicCondition");
static_assert(sizeof(FLLogicCondition) == 0x000050, "Wrong size on FLLogicCondition");
static_assert(offsetof(FLLogicCondition, Conditions) == 0x000000, "Member 'FLLogicCondition::Conditions' has a wrong offset!");

// ScriptStruct ProjectP.LSlaveArmBuildData
// 0x0010 (0x0010 - 0x0000)
struct FLSlaveArmBuildData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULSlaveArmInfo*                         SlaveArmInfo;                                      // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSlaveArmBuildData) == 0x000008, "Wrong alignment on FLSlaveArmBuildData");
static_assert(sizeof(FLSlaveArmBuildData) == 0x000010, "Wrong size on FLSlaveArmBuildData");
static_assert(offsetof(FLSlaveArmBuildData, SlaveArmInfo) == 0x000008, "Member 'FLSlaveArmBuildData::SlaveArmInfo' has a wrong offset!");

// ScriptStruct ProjectP.LActionGroupTable
// 0x0008 (0x0008 - 0x0000)
struct FLActionGroupTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLActionGroupTable) == 0x000008, "Wrong alignment on FLActionGroupTable");
static_assert(sizeof(FLActionGroupTable) == 0x000008, "Wrong size on FLActionGroupTable");
static_assert(offsetof(FLActionGroupTable, Table) == 0x000000, "Member 'FLActionGroupTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LEquipItemSlot
// 0x0018 (0x0018 - 0x0000)
struct FLEquipItemSlot final
{
public:
	ELEquipSlotType                               SlotType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULItem*                                 Item;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLEquipItemSlot) == 0x000008, "Wrong alignment on FLEquipItemSlot");
static_assert(sizeof(FLEquipItemSlot) == 0x000018, "Wrong size on FLEquipItemSlot");
static_assert(offsetof(FLEquipItemSlot, SlotType) == 0x000000, "Member 'FLEquipItemSlot::SlotType' has a wrong offset!");
static_assert(offsetof(FLEquipItemSlot, Item) == 0x000008, "Member 'FLEquipItemSlot::Item' has a wrong offset!");
static_assert(offsetof(FLEquipItemSlot, bUnlock) == 0x000010, "Member 'FLEquipItemSlot::bUnlock' has a wrong offset!");

// ScriptStruct ProjectP.LCustomInputMapping
// 0x0058 (0x0058 - 0x0000)
struct FLCustomInputMapping final
{
public:
	class FName                                   InputActionName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputAxisKeyMapping                   AxisMapping;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FInputActionKeyMapping                 ActionMapping;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCustomInputMapping) == 0x000008, "Wrong alignment on FLCustomInputMapping");
static_assert(sizeof(FLCustomInputMapping) == 0x000058, "Wrong size on FLCustomInputMapping");
static_assert(offsetof(FLCustomInputMapping, InputActionName) == 0x000000, "Member 'FLCustomInputMapping::InputActionName' has a wrong offset!");
static_assert(offsetof(FLCustomInputMapping, AxisMapping) == 0x000008, "Member 'FLCustomInputMapping::AxisMapping' has a wrong offset!");
static_assert(offsetof(FLCustomInputMapping, ActionMapping) == 0x000030, "Member 'FLCustomInputMapping::ActionMapping' has a wrong offset!");

// ScriptStruct ProjectP.LCustomInputMappingPreset
// 0x0018 (0x0020 - 0x0008)
struct FLCustomInputMappingPreset final : public FTableRowBase
{
public:
	TArray<struct FLCustomInputMapping>           Preset;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsGamePadPreset;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCustomInputMappingPreset) == 0x000008, "Wrong alignment on FLCustomInputMappingPreset");
static_assert(sizeof(FLCustomInputMappingPreset) == 0x000020, "Wrong size on FLCustomInputMappingPreset");
static_assert(offsetof(FLCustomInputMappingPreset, Preset) == 0x000008, "Member 'FLCustomInputMappingPreset::Preset' has a wrong offset!");
static_assert(offsetof(FLCustomInputMappingPreset, IsGamePadPreset) == 0x000018, "Member 'FLCustomInputMappingPreset::IsGamePadPreset' has a wrong offset!");

// ScriptStruct ProjectP.LQuartzEffectSaveData
// 0x0014 (0x0014 - 0x0000)
struct FLQuartzEffectSaveData final
{
public:
	class FName                                   QuartzPocketCodeName;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuartzEffectCodeName;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLQuartzEffectSaveData) == 0x000004, "Wrong alignment on FLQuartzEffectSaveData");
static_assert(sizeof(FLQuartzEffectSaveData) == 0x000014, "Wrong size on FLQuartzEffectSaveData");
static_assert(offsetof(FLQuartzEffectSaveData, QuartzPocketCodeName) == 0x000000, "Member 'FLQuartzEffectSaveData::QuartzPocketCodeName' has a wrong offset!");
static_assert(offsetof(FLQuartzEffectSaveData, QuartzEffectCodeName) == 0x000008, "Member 'FLQuartzEffectSaveData::QuartzEffectCodeName' has a wrong offset!");
static_assert(offsetof(FLQuartzEffectSaveData, SlotIndex) == 0x000010, "Member 'FLQuartzEffectSaveData::SlotIndex' has a wrong offset!");

// ScriptStruct ProjectP.LUseItemSlot
// 0x0014 (0x0014 - 0x0000)
struct FLUseItemSlot final
{
public:
	bool                                          IsSlotFirstLine;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemCodeName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLUseItemSlot) == 0x000004, "Wrong alignment on FLUseItemSlot");
static_assert(sizeof(FLUseItemSlot) == 0x000014, "Wrong size on FLUseItemSlot");
static_assert(offsetof(FLUseItemSlot, IsSlotFirstLine) == 0x000000, "Member 'FLUseItemSlot::IsSlotFirstLine' has a wrong offset!");
static_assert(offsetof(FLUseItemSlot, SlotIndex) == 0x000004, "Member 'FLUseItemSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(FLUseItemSlot, ItemCodeName) == 0x000008, "Member 'FLUseItemSlot::ItemCodeName' has a wrong offset!");
static_assert(offsetof(FLUseItemSlot, bUnlock) == 0x000010, "Member 'FLUseItemSlot::bUnlock' has a wrong offset!");

// ScriptStruct ProjectP.LFloatInterval
// 0x0008 (0x0008 - 0x0000)
struct FLFloatInterval final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFloatInterval) == 0x000004, "Wrong alignment on FLFloatInterval");
static_assert(sizeof(FLFloatInterval) == 0x000008, "Wrong size on FLFloatInterval");
static_assert(offsetof(FLFloatInterval, Min) == 0x000000, "Member 'FLFloatInterval::Min' has a wrong offset!");
static_assert(offsetof(FLFloatInterval, Max) == 0x000004, "Member 'FLFloatInterval::Max' has a wrong offset!");

// ScriptStruct ProjectP.LMoveBasedRootMotionSpeed
// 0x0018 (0x0018 - 0x0000)
struct FLMoveBasedRootMotionSpeed final
{
public:
	float                                         WalkMontageSpeed;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunMontageSpeed;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFloatInterval                        LimitSpeedRateWalk;                                // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FLFloatInterval                        LimitSpeedRateRun;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMoveBasedRootMotionSpeed) == 0x000004, "Wrong alignment on FLMoveBasedRootMotionSpeed");
static_assert(sizeof(FLMoveBasedRootMotionSpeed) == 0x000018, "Wrong size on FLMoveBasedRootMotionSpeed");
static_assert(offsetof(FLMoveBasedRootMotionSpeed, WalkMontageSpeed) == 0x000000, "Member 'FLMoveBasedRootMotionSpeed::WalkMontageSpeed' has a wrong offset!");
static_assert(offsetof(FLMoveBasedRootMotionSpeed, RunMontageSpeed) == 0x000004, "Member 'FLMoveBasedRootMotionSpeed::RunMontageSpeed' has a wrong offset!");
static_assert(offsetof(FLMoveBasedRootMotionSpeed, LimitSpeedRateWalk) == 0x000008, "Member 'FLMoveBasedRootMotionSpeed::LimitSpeedRateWalk' has a wrong offset!");
static_assert(offsetof(FLMoveBasedRootMotionSpeed, LimitSpeedRateRun) == 0x000010, "Member 'FLMoveBasedRootMotionSpeed::LimitSpeedRateRun' has a wrong offset!");

// ScriptStruct ProjectP.LMoveBasedRootMotion
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLMoveBasedRootMotion final
{
public:
	bool                                          bUseRootMotion;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMoveBasedRootMotionSpeed             Speed;                                             // 0x0004(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0xC];                                       // 0x001C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMoveBasedRootMotion) == 0x000008, "Wrong alignment on FLMoveBasedRootMotion");
static_assert(sizeof(FLMoveBasedRootMotion) == 0x000028, "Wrong size on FLMoveBasedRootMotion");
static_assert(offsetof(FLMoveBasedRootMotion, bUseRootMotion) == 0x000000, "Member 'FLMoveBasedRootMotion::bUseRootMotion' has a wrong offset!");
static_assert(offsetof(FLMoveBasedRootMotion, Speed) == 0x000004, "Member 'FLMoveBasedRootMotion::Speed' has a wrong offset!");

// ScriptStruct ProjectP.LMonsterLockOnCameraModifier
// 0x0018 (0x0018 - 0x0000)
struct FLMonsterLockOnCameraModifier final
{
public:
	struct FLFloatInterval                        CheckDistance;                                     // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bModifyLagSpeed;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LagSpeed;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bModifyRotationLagSpeed;                           // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationLagSpeed;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMonsterLockOnCameraModifier) == 0x000004, "Wrong alignment on FLMonsterLockOnCameraModifier");
static_assert(sizeof(FLMonsterLockOnCameraModifier) == 0x000018, "Wrong size on FLMonsterLockOnCameraModifier");
static_assert(offsetof(FLMonsterLockOnCameraModifier, CheckDistance) == 0x000000, "Member 'FLMonsterLockOnCameraModifier::CheckDistance' has a wrong offset!");
static_assert(offsetof(FLMonsterLockOnCameraModifier, bModifyLagSpeed) == 0x000008, "Member 'FLMonsterLockOnCameraModifier::bModifyLagSpeed' has a wrong offset!");
static_assert(offsetof(FLMonsterLockOnCameraModifier, LagSpeed) == 0x00000C, "Member 'FLMonsterLockOnCameraModifier::LagSpeed' has a wrong offset!");
static_assert(offsetof(FLMonsterLockOnCameraModifier, bModifyRotationLagSpeed) == 0x000010, "Member 'FLMonsterLockOnCameraModifier::bModifyRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(FLMonsterLockOnCameraModifier, RotationLagSpeed) == 0x000014, "Member 'FLMonsterLockOnCameraModifier::RotationLagSpeed' has a wrong offset!");

// ScriptStruct ProjectP.LMonsterLockOnCameraModifiers
// 0x0010 (0x0010 - 0x0000)
struct FLMonsterLockOnCameraModifiers final
{
public:
	TArray<struct FLMonsterLockOnCameraModifier>  Modifiers;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMonsterLockOnCameraModifiers) == 0x000008, "Wrong alignment on FLMonsterLockOnCameraModifiers");
static_assert(sizeof(FLMonsterLockOnCameraModifiers) == 0x000010, "Wrong size on FLMonsterLockOnCameraModifiers");
static_assert(offsetof(FLMonsterLockOnCameraModifiers, Modifiers) == 0x000000, "Member 'FLMonsterLockOnCameraModifiers::Modifiers' has a wrong offset!");

// ScriptStruct ProjectP.MomentConditionCaptureInfo
// 0x0028 (0x0028 - 0x0000)
struct FMomentConditionCaptureInfo final
{
public:
	ELConditionState                              State;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMomentType                                  MomentType;                                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBack;                                            // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGroggyEnable;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitGroggy;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGroggy;                                          // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSubSwing;                                        // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSubThrust;                                       // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALCharacter>             Opponent;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitName;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseSkillName;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALWeapon>                AttakerWeapon;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMomentConditionCaptureInfo) == 0x000004, "Wrong alignment on FMomentConditionCaptureInfo");
static_assert(sizeof(FMomentConditionCaptureInfo) == 0x000028, "Wrong size on FMomentConditionCaptureInfo");
static_assert(offsetof(FMomentConditionCaptureInfo, State) == 0x000000, "Member 'FMomentConditionCaptureInfo::State' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, MomentType) == 0x000001, "Member 'FMomentConditionCaptureInfo::MomentType' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, IsBack) == 0x000002, "Member 'FMomentConditionCaptureInfo::IsBack' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, IsGroggyEnable) == 0x000003, "Member 'FMomentConditionCaptureInfo::IsGroggyEnable' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, IsHitGroggy) == 0x000004, "Member 'FMomentConditionCaptureInfo::IsHitGroggy' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, IsGroggy) == 0x000005, "Member 'FMomentConditionCaptureInfo::IsGroggy' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, IsSubSwing) == 0x000006, "Member 'FMomentConditionCaptureInfo::IsSubSwing' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, IsSubThrust) == 0x000007, "Member 'FMomentConditionCaptureInfo::IsSubThrust' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, Opponent) == 0x000008, "Member 'FMomentConditionCaptureInfo::Opponent' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, SkillHitName) == 0x000010, "Member 'FMomentConditionCaptureInfo::SkillHitName' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, UseSkillName) == 0x000018, "Member 'FMomentConditionCaptureInfo::UseSkillName' has a wrong offset!");
static_assert(offsetof(FMomentConditionCaptureInfo, AttakerWeapon) == 0x000020, "Member 'FMomentConditionCaptureInfo::AttakerWeapon' has a wrong offset!");

// ScriptStruct ProjectP.LAICheckOwner
// 0x000C (0x000C - 0x0000)
struct FLAICheckOwner final
{
public:
	uint8                                         bDebug : 1;                                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ACharacter>              Character;                                         // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLAICheckOwner) == 0x000004, "Wrong alignment on FLAICheckOwner");
static_assert(sizeof(FLAICheckOwner) == 0x00000C, "Wrong size on FLAICheckOwner");
static_assert(offsetof(FLAICheckOwner, Character) == 0x000004, "Member 'FLAICheckOwner::Character' has a wrong offset!");

// ScriptStruct ProjectP.LCameraWorkViewInfo
// 0x001C (0x001C - 0x0000)
struct FLCameraWorkViewInfo final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCameraWorkViewInfo) == 0x000004, "Wrong alignment on FLCameraWorkViewInfo");
static_assert(sizeof(FLCameraWorkViewInfo) == 0x00001C, "Wrong size on FLCameraWorkViewInfo");
static_assert(offsetof(FLCameraWorkViewInfo, Location) == 0x000000, "Member 'FLCameraWorkViewInfo::Location' has a wrong offset!");
static_assert(offsetof(FLCameraWorkViewInfo, Rotation) == 0x00000C, "Member 'FLCameraWorkViewInfo::Rotation' has a wrong offset!");
static_assert(offsetof(FLCameraWorkViewInfo, FOV) == 0x000018, "Member 'FLCameraWorkViewInfo::FOV' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialVaryingPlayer
// 0x0028 (0x0028 - 0x0000)
struct FLMaterialVaryingPlayer final
{
public:
	class ULMaterialVarying*                      MaterialVarying;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           PlayNames;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMaterialVaryingPlayer) == 0x000008, "Wrong alignment on FLMaterialVaryingPlayer");
static_assert(sizeof(FLMaterialVaryingPlayer) == 0x000028, "Wrong size on FLMaterialVaryingPlayer");
static_assert(offsetof(FLMaterialVaryingPlayer, MaterialVarying) == 0x000000, "Member 'FLMaterialVaryingPlayer::MaterialVarying' has a wrong offset!");
static_assert(offsetof(FLMaterialVaryingPlayer, PlayNames) == 0x000008, "Member 'FLMaterialVaryingPlayer::PlayNames' has a wrong offset!");

// ScriptStruct ProjectP.LAbsoluteRootMotionContext
// 0x0060 (0x0060 - 0x0000)
struct FLAbsoluteRootMotionContext final
{
public:
	ELAbsoluteRootMotionModeType                  ModeType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAnimMontage>            Montage;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualFinishTime;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopRemainTimeCompensateMargin;                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location_Start;                                    // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation_Start;                                    // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Rotation_Start_BlendTime;                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location_End;                                      // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation_End;                                      // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Rotation_End_BlendTime;                            // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation_ToTarget;                                 // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale_Horizontal;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale_Vertical;                                    // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAbsoluteRootMotionContext) == 0x000004, "Wrong alignment on FLAbsoluteRootMotionContext");
static_assert(sizeof(FLAbsoluteRootMotionContext) == 0x000060, "Wrong size on FLAbsoluteRootMotionContext");
static_assert(offsetof(FLAbsoluteRootMotionContext, ModeType) == 0x000000, "Member 'FLAbsoluteRootMotionContext::ModeType' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Montage) == 0x000004, "Member 'FLAbsoluteRootMotionContext::Montage' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, ManualFinishTime) == 0x00000C, "Member 'FLAbsoluteRootMotionContext::ManualFinishTime' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, StopRemainTimeCompensateMargin) == 0x000010, "Member 'FLAbsoluteRootMotionContext::StopRemainTimeCompensateMargin' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Location_Start) == 0x000014, "Member 'FLAbsoluteRootMotionContext::Location_Start' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Rotation_Start) == 0x000020, "Member 'FLAbsoluteRootMotionContext::Rotation_Start' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Rotation_Start_BlendTime) == 0x00002C, "Member 'FLAbsoluteRootMotionContext::Rotation_Start_BlendTime' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Location_End) == 0x000030, "Member 'FLAbsoluteRootMotionContext::Location_End' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Rotation_End) == 0x00003C, "Member 'FLAbsoluteRootMotionContext::Rotation_End' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Rotation_End_BlendTime) == 0x000048, "Member 'FLAbsoluteRootMotionContext::Rotation_End_BlendTime' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Rotation_ToTarget) == 0x00004C, "Member 'FLAbsoluteRootMotionContext::Rotation_ToTarget' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Scale_Horizontal) == 0x000058, "Member 'FLAbsoluteRootMotionContext::Scale_Horizontal' has a wrong offset!");
static_assert(offsetof(FLAbsoluteRootMotionContext, Scale_Vertical) == 0x00005C, "Member 'FLAbsoluteRootMotionContext::Scale_Vertical' has a wrong offset!");

// ScriptStruct ProjectP.LItemSaveData
// 0x0060 (0x0060 - 0x0000)
struct FLItemSaveData final
{
public:
	int64                                         UniqueId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         UniqueId_ComplexUnit;                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstCodeName;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondCodeName;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeapon;                                         // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELEquipSlotType                               EquipItemSlotType;                                 // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UseItemSlotIndexFirst;                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseItemSlotIndexSecond;                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentInfoNoticeCount;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SharpnessPoint;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReinforceLevel;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondReinforceLevel;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRechargedPulse;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PulseRechargedCount;                               // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAssistUseItemSlotType                       AssistUseItemSlotType;                             // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HandleCorrectionLevel_Motivity;                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandleCorrectionLevel_Technique;                   // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HandleCorrectionLevel_Advance;                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ammo_Current;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELShotGunAmmoType                             ShotGunAmmoType;                                   // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAcidSpreadingModeType                       AcidSpreadingMode;                                 // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLItemSaveData) == 0x000008, "Wrong alignment on FLItemSaveData");
static_assert(sizeof(FLItemSaveData) == 0x000060, "Wrong size on FLItemSaveData");
static_assert(offsetof(FLItemSaveData, UniqueId) == 0x000000, "Member 'FLItemSaveData::UniqueId' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, UniqueId_ComplexUnit) == 0x000008, "Member 'FLItemSaveData::UniqueId_ComplexUnit' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, FirstCodeName) == 0x000010, "Member 'FLItemSaveData::FirstCodeName' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, SecondCodeName) == 0x000018, "Member 'FLItemSaveData::SecondCodeName' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, bIsWeapon) == 0x000020, "Member 'FLItemSaveData::bIsWeapon' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, EquipItemSlotType) == 0x000021, "Member 'FLItemSaveData::EquipItemSlotType' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, UseItemSlotIndexFirst) == 0x000024, "Member 'FLItemSaveData::UseItemSlotIndexFirst' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, UseItemSlotIndexSecond) == 0x000028, "Member 'FLItemSaveData::UseItemSlotIndexSecond' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, Count) == 0x00002C, "Member 'FLItemSaveData::Count' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, CurrentInfoNoticeCount) == 0x000030, "Member 'FLItemSaveData::CurrentInfoNoticeCount' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, SharpnessPoint) == 0x000034, "Member 'FLItemSaveData::SharpnessPoint' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, ReinforceLevel) == 0x000038, "Member 'FLItemSaveData::ReinforceLevel' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, SecondReinforceLevel) == 0x00003C, "Member 'FLItemSaveData::SecondReinforceLevel' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, bRechargedPulse) == 0x000040, "Member 'FLItemSaveData::bRechargedPulse' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, PulseRechargedCount) == 0x000044, "Member 'FLItemSaveData::PulseRechargedCount' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, AssistUseItemSlotType) == 0x000048, "Member 'FLItemSaveData::AssistUseItemSlotType' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, HandleCorrectionLevel_Motivity) == 0x00004C, "Member 'FLItemSaveData::HandleCorrectionLevel_Motivity' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, HandleCorrectionLevel_Technique) == 0x000050, "Member 'FLItemSaveData::HandleCorrectionLevel_Technique' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, HandleCorrectionLevel_Advance) == 0x000054, "Member 'FLItemSaveData::HandleCorrectionLevel_Advance' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, Ammo_Current) == 0x000058, "Member 'FLItemSaveData::Ammo_Current' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, ShotGunAmmoType) == 0x00005C, "Member 'FLItemSaveData::ShotGunAmmoType' has a wrong offset!");
static_assert(offsetof(FLItemSaveData, AcidSpreadingMode) == 0x00005D, "Member 'FLItemSaveData::AcidSpreadingMode' has a wrong offset!");

// ScriptStruct ProjectP.LProductShopItemData
// 0x000C (0x000C - 0x0000)
struct FLProductShopItemData final
{
public:
	class FName                                   ProductCodeName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StockLimit;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProductShopItemData) == 0x000004, "Wrong alignment on FLProductShopItemData");
static_assert(sizeof(FLProductShopItemData) == 0x00000C, "Wrong size on FLProductShopItemData");
static_assert(offsetof(FLProductShopItemData, ProductCodeName) == 0x000000, "Member 'FLProductShopItemData::ProductCodeName' has a wrong offset!");
static_assert(offsetof(FLProductShopItemData, StockLimit) == 0x000008, "Member 'FLProductShopItemData::StockLimit' has a wrong offset!");

// ScriptStruct ProjectP.LProductShopData
// 0x0018 (0x0018 - 0x0000)
struct FLProductShopData final
{
public:
	class FName                                   ShopCodeName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLProductShopItemData>          DealedProductDatas;                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProductShopData) == 0x000008, "Wrong alignment on FLProductShopData");
static_assert(sizeof(FLProductShopData) == 0x000018, "Wrong size on FLProductShopData");
static_assert(offsetof(FLProductShopData, ShopCodeName) == 0x000000, "Member 'FLProductShopData::ShopCodeName' has a wrong offset!");
static_assert(offsetof(FLProductShopData, DealedProductDatas) == 0x000008, "Member 'FLProductShopData::DealedProductDatas' has a wrong offset!");

// ScriptStruct ProjectP.LEquipSlotSaveData
// 0x0002 (0x0002 - 0x0000)
struct FLEquipSlotSaveData final
{
public:
	ELEquipSlotType                               EquipSlotType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLEquipSlotSaveData) == 0x000001, "Wrong alignment on FLEquipSlotSaveData");
static_assert(sizeof(FLEquipSlotSaveData) == 0x000002, "Wrong size on FLEquipSlotSaveData");
static_assert(offsetof(FLEquipSlotSaveData, EquipSlotType) == 0x000000, "Member 'FLEquipSlotSaveData::EquipSlotType' has a wrong offset!");
static_assert(offsetof(FLEquipSlotSaveData, bUnlock) == 0x000001, "Member 'FLEquipSlotSaveData::bUnlock' has a wrong offset!");

// ScriptStruct ProjectP.LEquipUseSlotSaveData
// 0x0008 (0x0008 - 0x0000)
struct FLEquipUseSlotSaveData final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLEquipUseSlotSaveData) == 0x000004, "Wrong alignment on FLEquipUseSlotSaveData");
static_assert(sizeof(FLEquipUseSlotSaveData) == 0x000008, "Wrong size on FLEquipUseSlotSaveData");
static_assert(offsetof(FLEquipUseSlotSaveData, SlotIndex) == 0x000000, "Member 'FLEquipUseSlotSaveData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FLEquipUseSlotSaveData, bUnlock) == 0x000004, "Member 'FLEquipUseSlotSaveData::bUnlock' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterItemSaveData
// 0x00C0 (0x00C0 - 0x0000)
struct FLCharacterItemSaveData final
{
public:
	TMap<class FName, int32>                      ItemInfoNoticeCountMap;                            // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FLItemSaveData>                 PlayerItems;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLItemSaveData>                 LockerItems;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ELEquipSlotType                               ChosenWeaponSlotType;                              // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELEquipSlotType                               ChosenSlaveArmSlotType;                            // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChosenUseItemFirstLine;                         // 0x0072(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x1];                                       // 0x0073(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChosenUseItemSlotIndex;                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLProductShopData>              DealedShopData;                                    // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           CheckedLettersPage;                                // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          bEnablePulseGaugeRechargeSystem;                   // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLEquipSlotSaveData>            EquipSlotSaveDatas;                                // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLEquipUseSlotSaveData>         EquipUseSlotSaveDatas;                             // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterItemSaveData) == 0x000008, "Wrong alignment on FLCharacterItemSaveData");
static_assert(sizeof(FLCharacterItemSaveData) == 0x0000C0, "Wrong size on FLCharacterItemSaveData");
static_assert(offsetof(FLCharacterItemSaveData, ItemInfoNoticeCountMap) == 0x000000, "Member 'FLCharacterItemSaveData::ItemInfoNoticeCountMap' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, PlayerItems) == 0x000050, "Member 'FLCharacterItemSaveData::PlayerItems' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, LockerItems) == 0x000060, "Member 'FLCharacterItemSaveData::LockerItems' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, ChosenWeaponSlotType) == 0x000070, "Member 'FLCharacterItemSaveData::ChosenWeaponSlotType' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, ChosenSlaveArmSlotType) == 0x000071, "Member 'FLCharacterItemSaveData::ChosenSlaveArmSlotType' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, bIsChosenUseItemFirstLine) == 0x000072, "Member 'FLCharacterItemSaveData::bIsChosenUseItemFirstLine' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, ChosenUseItemSlotIndex) == 0x000074, "Member 'FLCharacterItemSaveData::ChosenUseItemSlotIndex' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, DealedShopData) == 0x000078, "Member 'FLCharacterItemSaveData::DealedShopData' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, CheckedLettersPage) == 0x000088, "Member 'FLCharacterItemSaveData::CheckedLettersPage' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, bEnablePulseGaugeRechargeSystem) == 0x000098, "Member 'FLCharacterItemSaveData::bEnablePulseGaugeRechargeSystem' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, EquipSlotSaveDatas) == 0x0000A0, "Member 'FLCharacterItemSaveData::EquipSlotSaveDatas' has a wrong offset!");
static_assert(offsetof(FLCharacterItemSaveData, EquipUseSlotSaveDatas) == 0x0000B0, "Member 'FLCharacterItemSaveData::EquipUseSlotSaveDatas' has a wrong offset!");

// ScriptStruct ProjectP.LTalkerData
// 0x000C (0x000C - 0x0000)
struct FLTalkerData final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Hited;                                             // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLTalkerData) == 0x000004, "Wrong alignment on FLTalkerData");
static_assert(sizeof(FLTalkerData) == 0x00000C, "Wrong size on FLTalkerData");
static_assert(offsetof(FLTalkerData, CodeName) == 0x000000, "Member 'FLTalkerData::CodeName' has a wrong offset!");
static_assert(offsetof(FLTalkerData, Hited) == 0x000008, "Member 'FLTalkerData::Hited' has a wrong offset!");

// ScriptStruct ProjectP.LPlayerCameraData
// 0x003C (0x003C - 0x0000)
struct FLPlayerCameraData final
{
public:
	float                                         FOV;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMin;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmLength;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset;                                      // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableCameraLag : 1;                              // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableCameraRotationLag : 1;                      // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLagSpeed;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxDistance;                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DialogCamZoom;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPlayerCameraData) == 0x000004, "Wrong alignment on FLPlayerCameraData");
static_assert(sizeof(FLPlayerCameraData) == 0x00003C, "Wrong size on FLPlayerCameraData");
static_assert(offsetof(FLPlayerCameraData, FOV) == 0x000000, "Member 'FLPlayerCameraData::FOV' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, PitchMin) == 0x000004, "Member 'FLPlayerCameraData::PitchMin' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, PitchMax) == 0x000008, "Member 'FLPlayerCameraData::PitchMax' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, TargetArmLength) == 0x00000C, "Member 'FLPlayerCameraData::TargetArmLength' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, SocketOffset) == 0x000010, "Member 'FLPlayerCameraData::SocketOffset' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, TargetOffset) == 0x00001C, "Member 'FLPlayerCameraData::TargetOffset' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, CameraLagSpeed) == 0x00002C, "Member 'FLPlayerCameraData::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, CameraRotationLagSpeed) == 0x000030, "Member 'FLPlayerCameraData::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, CameraLagMaxDistance) == 0x000034, "Member 'FLPlayerCameraData::CameraLagMaxDistance' has a wrong offset!");
static_assert(offsetof(FLPlayerCameraData, DialogCamZoom) == 0x000038, "Member 'FLPlayerCameraData::DialogCamZoom' has a wrong offset!");

// ScriptStruct ProjectP.LViewTargetTransitionParams
// 0x000C (0x000C - 0x0000)
struct FLViewTargetTransitionParams final
{
public:
	float                                         BlendTime;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunction;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLViewTargetTransitionParams) == 0x000004, "Wrong alignment on FLViewTargetTransitionParams");
static_assert(sizeof(FLViewTargetTransitionParams) == 0x00000C, "Wrong size on FLViewTargetTransitionParams");
static_assert(offsetof(FLViewTargetTransitionParams, BlendTime) == 0x000000, "Member 'FLViewTargetTransitionParams::BlendTime' has a wrong offset!");
static_assert(offsetof(FLViewTargetTransitionParams, BlendFunction) == 0x000004, "Member 'FLViewTargetTransitionParams::BlendFunction' has a wrong offset!");
static_assert(offsetof(FLViewTargetTransitionParams, BlendExp) == 0x000008, "Member 'FLViewTargetTransitionParams::BlendExp' has a wrong offset!");

// ScriptStruct ProjectP.LBuildupPayload
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FLBuildupPayload final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLBuildupPayload) == 0x000004, "Wrong alignment on FLBuildupPayload");
static_assert(sizeof(FLBuildupPayload) == 0x00000C, "Wrong size on FLBuildupPayload");

// ScriptStruct ProjectP.LCloudSettings
// 0x008C (0x008C - 0x0000)
struct FLCloudSettings final
{
public:
	uint8                                         bOverride_Density : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Opacity : 1;                             // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShineIntensity : 1;                      // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WispyCloudAlpha : 1;                     // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Speed : 1;                               // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Height1 : 1;                             // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Height2 : 1;                             // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Tiling1 : 1;                             // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Tiling2 : 1;                             // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Soften1 : 1;                             // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Soften2 : 1;                             // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Sharpness : 1;                           // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AroundMoonDensityExponent : 1;           // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AroundMoonDensityMultiplier : 1;         // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HorizonDensityMultiplier : 1;            // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ZenithDensityMultiplier : 1;             // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LatitudeGradientPosition : 1;            // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LatitudeGradientWidth : 1;               // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SoftenHorizon : 1;                       // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShadingGradientWidth : 1;                // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShadingOffset : 1;                       // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OvercastSwirl : 1;                       // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CloudLightColor : 1;                     // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_CloudDarkColor : 1;                      // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WispyAmbientColor : 1;                   // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	float                                         Density;                                           // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShineIntensity;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WispyCloudAlpha;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height1;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height2;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tiling1;                                           // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tiling2;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Soften1;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Soften2;                                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sharpness;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundMoonDensityExponent;                         // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundMoonDensityMultiplier;                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizonDensityMultiplier;                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZenithDensityMultiplier;                           // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LatitudeGradientPosition;                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LatitudeGradientWidth;                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftenHorizon;                                     // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadingGradientWidth;                              // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadingOffset;                                     // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OvercastSwirl;                                     // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CloudLightColor;                                   // 0x005C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CloudDarkColor;                                    // 0x006C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WispyAmbientColor;                                 // 0x007C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCloudSettings) == 0x000004, "Wrong alignment on FLCloudSettings");
static_assert(sizeof(FLCloudSettings) == 0x00008C, "Wrong size on FLCloudSettings");
static_assert(offsetof(FLCloudSettings, Density) == 0x000004, "Member 'FLCloudSettings::Density' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Opacity) == 0x000008, "Member 'FLCloudSettings::Opacity' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, ShineIntensity) == 0x00000C, "Member 'FLCloudSettings::ShineIntensity' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, WispyCloudAlpha) == 0x000010, "Member 'FLCloudSettings::WispyCloudAlpha' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Speed) == 0x000014, "Member 'FLCloudSettings::Speed' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Height1) == 0x000018, "Member 'FLCloudSettings::Height1' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Height2) == 0x00001C, "Member 'FLCloudSettings::Height2' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Tiling1) == 0x000020, "Member 'FLCloudSettings::Tiling1' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Tiling2) == 0x000024, "Member 'FLCloudSettings::Tiling2' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Soften1) == 0x000028, "Member 'FLCloudSettings::Soften1' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Soften2) == 0x00002C, "Member 'FLCloudSettings::Soften2' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, Sharpness) == 0x000030, "Member 'FLCloudSettings::Sharpness' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, AroundMoonDensityExponent) == 0x000034, "Member 'FLCloudSettings::AroundMoonDensityExponent' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, AroundMoonDensityMultiplier) == 0x000038, "Member 'FLCloudSettings::AroundMoonDensityMultiplier' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, HorizonDensityMultiplier) == 0x00003C, "Member 'FLCloudSettings::HorizonDensityMultiplier' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, ZenithDensityMultiplier) == 0x000040, "Member 'FLCloudSettings::ZenithDensityMultiplier' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, LatitudeGradientPosition) == 0x000044, "Member 'FLCloudSettings::LatitudeGradientPosition' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, LatitudeGradientWidth) == 0x000048, "Member 'FLCloudSettings::LatitudeGradientWidth' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, SoftenHorizon) == 0x00004C, "Member 'FLCloudSettings::SoftenHorizon' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, ShadingGradientWidth) == 0x000050, "Member 'FLCloudSettings::ShadingGradientWidth' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, ShadingOffset) == 0x000054, "Member 'FLCloudSettings::ShadingOffset' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, OvercastSwirl) == 0x000058, "Member 'FLCloudSettings::OvercastSwirl' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, CloudLightColor) == 0x00005C, "Member 'FLCloudSettings::CloudLightColor' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, CloudDarkColor) == 0x00006C, "Member 'FLCloudSettings::CloudDarkColor' has a wrong offset!");
static_assert(offsetof(FLCloudSettings, WispyAmbientColor) == 0x00007C, "Member 'FLCloudSettings::WispyAmbientColor' has a wrong offset!");

// ScriptStruct ProjectP.LAbnormalPayload
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLAbnormalPayload final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAbnormalPayload) == 0x000008, "Wrong alignment on FLAbnormalPayload");
static_assert(sizeof(FLAbnormalPayload) == 0x000028, "Wrong size on FLAbnormalPayload");

// ScriptStruct ProjectP.LAbnormalCollector
// 0x0198 (0x0198 - 0x0000)
struct alignas(0x08) FLAbnormalCollector final
{
public:
	uint8                                         Pad_0[0x198];                                      // 0x0000(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAbnormalCollector) == 0x000008, "Wrong alignment on FLAbnormalCollector");
static_assert(sizeof(FLAbnormalCollector) == 0x000198, "Wrong size on FLAbnormalCollector");

// ScriptStruct ProjectP.LDropPrimitiveItem
// 0x0050 (0x0050 - 0x0000)
struct FLDropPrimitiveItem final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfileName;                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachParent;                                      // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RelativeTransform;                                 // 0x0020(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDropPrimitiveItem) == 0x000010, "Wrong alignment on FLDropPrimitiveItem");
static_assert(sizeof(FLDropPrimitiveItem) == 0x000050, "Wrong size on FLDropPrimitiveItem");
static_assert(offsetof(FLDropPrimitiveItem, Component) == 0x000000, "Member 'FLDropPrimitiveItem::Component' has a wrong offset!");
static_assert(offsetof(FLDropPrimitiveItem, CollisionProfileName) == 0x000008, "Member 'FLDropPrimitiveItem::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(FLDropPrimitiveItem, AttachParent) == 0x000010, "Member 'FLDropPrimitiveItem::AttachParent' has a wrong offset!");
static_assert(offsetof(FLDropPrimitiveItem, AttachSocketName) == 0x000018, "Member 'FLDropPrimitiveItem::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FLDropPrimitiveItem, RelativeTransform) == 0x000020, "Member 'FLDropPrimitiveItem::RelativeTransform' has a wrong offset!");

// ScriptStruct ProjectP.LDropPrimitive
// 0x0080 (0x0080 - 0x0000)
struct FLDropPrimitive final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLDropPrimitiveItem                    DropedComponent;                                   // 0x0010(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLDropPrimitiveItem>            WeldChildComponents;                               // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         DurationTime;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDropPrimitive) == 0x000010, "Wrong alignment on FLDropPrimitive");
static_assert(sizeof(FLDropPrimitive) == 0x000080, "Wrong size on FLDropPrimitive");
static_assert(offsetof(FLDropPrimitive, DropedComponent) == 0x000010, "Member 'FLDropPrimitive::DropedComponent' has a wrong offset!");
static_assert(offsetof(FLDropPrimitive, WeldChildComponents) == 0x000060, "Member 'FLDropPrimitive::WeldChildComponents' has a wrong offset!");
static_assert(offsetof(FLDropPrimitive, DurationTime) == 0x000070, "Member 'FLDropPrimitive::DurationTime' has a wrong offset!");

// ScriptStruct ProjectP.LDurableAbnormalBPPtr
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FLDurableAbnormalBPPtr final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDurableAbnormalBPPtr) == 0x000008, "Wrong alignment on FLDurableAbnormalBPPtr");
static_assert(sizeof(FLDurableAbnormalBPPtr) == 0x000008, "Wrong size on FLDurableAbnormalBPPtr");

// ScriptStruct ProjectP.LReservedHitContext
// 0x01E8 (0x01E8 - 0x0000)
struct FLReservedHitContext final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0010(0x0088)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLHitInfo                              HitInfo;                                           // 0x0098(0x0150)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLReservedHitContext) == 0x000008, "Wrong alignment on FLReservedHitContext");
static_assert(sizeof(FLReservedHitContext) == 0x0001E8, "Wrong size on FLReservedHitContext");
static_assert(offsetof(FLReservedHitContext, Attacker) == 0x000000, "Member 'FLReservedHitContext::Attacker' has a wrong offset!");
static_assert(offsetof(FLReservedHitContext, Victim) == 0x000008, "Member 'FLReservedHitContext::Victim' has a wrong offset!");
static_assert(offsetof(FLReservedHitContext, HitResult) == 0x000010, "Member 'FLReservedHitContext::HitResult' has a wrong offset!");
static_assert(offsetof(FLReservedHitContext, HitInfo) == 0x000098, "Member 'FLReservedHitContext::HitInfo' has a wrong offset!");

// ScriptStruct ProjectP.LLightningSettings
// 0x0074 (0x0074 - 0x0000)
struct FLLightningSettings final
{
public:
	uint8                                         bOverride_Lightning : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Direction : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionRange : 1;                      // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DistanceMin : 1;                         // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DistanceMax : 1;                         // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HeightMin : 1;                           // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HeightMax : 1;                           // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Interval : 1;                            // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShaftIntensity : 1;                      // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LightColor : 1;                          // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkyShineColor : 1;                       // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LightningColorBright : 1;                // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LightningColorMid : 1;                   // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LightningColorDim : 1;                   // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          Lightning;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Direction;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionRange;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceMin;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceMax;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMin;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightMax;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShaftIntensity;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkyShineColor;                                     // 0x0034(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColorBright;                              // 0x0044(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColorMid;                                 // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightningColorDim;                                 // 0x0064(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLightningSettings) == 0x000004, "Wrong alignment on FLLightningSettings");
static_assert(sizeof(FLLightningSettings) == 0x000074, "Wrong size on FLLightningSettings");
static_assert(offsetof(FLLightningSettings, Lightning) == 0x000002, "Member 'FLLightningSettings::Lightning' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, Direction) == 0x000004, "Member 'FLLightningSettings::Direction' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, DirectionRange) == 0x000008, "Member 'FLLightningSettings::DirectionRange' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, DistanceMin) == 0x00000C, "Member 'FLLightningSettings::DistanceMin' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, DistanceMax) == 0x000010, "Member 'FLLightningSettings::DistanceMax' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, HeightMin) == 0x000014, "Member 'FLLightningSettings::HeightMin' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, HeightMax) == 0x000018, "Member 'FLLightningSettings::HeightMax' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, Interval) == 0x00001C, "Member 'FLLightningSettings::Interval' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, ShaftIntensity) == 0x000020, "Member 'FLLightningSettings::ShaftIntensity' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, LightColor) == 0x000024, "Member 'FLLightningSettings::LightColor' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, SkyShineColor) == 0x000034, "Member 'FLLightningSettings::SkyShineColor' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, LightningColorBright) == 0x000044, "Member 'FLLightningSettings::LightningColorBright' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, LightningColorMid) == 0x000054, "Member 'FLLightningSettings::LightningColorMid' has a wrong offset!");
static_assert(offsetof(FLLightningSettings, LightningColorDim) == 0x000064, "Member 'FLLightningSettings::LightningColorDim' has a wrong offset!");

// ScriptStruct ProjectP.LAbnormalFromOther
// 0x0010 (0x0050 - 0x0040)
struct FLAbnormalFromOther final : public FLSimpleAbnormal
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAbnormalFromOther) == 0x000008, "Wrong alignment on FLAbnormalFromOther");
static_assert(sizeof(FLAbnormalFromOther) == 0x000050, "Wrong size on FLAbnormalFromOther");

// ScriptStruct ProjectP.LCapturer_Aura
// 0x0078 (0x0078 - 0x0000)
struct FLCapturer_Aura final
{
public:
	TArray<TWeakObjectPtr<class AActor>>          OverlappingActors;                                 // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x68];                                      // 0x0010(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCapturer_Aura) == 0x000008, "Wrong alignment on FLCapturer_Aura");
static_assert(sizeof(FLCapturer_Aura) == 0x000078, "Wrong size on FLCapturer_Aura");
static_assert(offsetof(FLCapturer_Aura, OverlappingActors) == 0x000000, "Member 'FLCapturer_Aura::OverlappingActors' has a wrong offset!");

// ScriptStruct ProjectP.LCapturer_Moment
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FLCapturer_Moment final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CaptureMomentCount;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CaptureMomentCount_Max;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCapturer_Moment) == 0x000008, "Wrong alignment on FLCapturer_Moment");
static_assert(sizeof(FLCapturer_Moment) == 0x000048, "Wrong size on FLCapturer_Moment");
static_assert(offsetof(FLCapturer_Moment, CaptureMomentCount) == 0x00003C, "Member 'FLCapturer_Moment::CaptureMomentCount' has a wrong offset!");
static_assert(offsetof(FLCapturer_Moment, CaptureMomentCount_Max) == 0x000040, "Member 'FLCapturer_Moment::CaptureMomentCount_Max' has a wrong offset!");

// ScriptStruct ProjectP.LSkyAtmosphereSettings
// 0x00D0 (0x00D0 - 0x0000)
struct FLSkyAtmosphereSettings final
{
public:
	uint8                                         bOverride_SunDiskColor : 1;                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonDiskColor : 1;                       // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SecondaryMoonRotation : 1;               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonDiskIntensity : 1;                   // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonGlowIntensity : 1;                   // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonPhase : 1;                           // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonScale : 1;                           // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_StarsIntensity : 1;                      // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_StarsTiling : 1;                         // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayleighScatteringScale : 1;             // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayleighScattering : 1;                  // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RayleighExponentialDistribution : 1;     // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MieScatteringScale : 1;                  // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MieScattering : 1;                       // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MieAbsorptionScale : 1;                  // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MieAbsorption : 1;                       // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MieAnisotropy : 1;                       // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MieExponentialDistribution : 1;          // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OtherAbsorptionScale : 1;                // 0x0002(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OtherAbsorption : 1;                     // 0x0002(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TipAltitude : 1;                         // 0x0002(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TipValue : 1;                            // 0x0002(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TentWidth : 1;                           // 0x0002(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SkyLuminanceFactor : 1;                  // 0x0002(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AerialPespectiveViewDistanceScale : 1;   // 0x0003(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HeightFogContribution : 1;               // 0x0003(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_TransmittanceMinLightElevationAngle : 1; // 0x0003(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_AerialPerspectiveStartDepth : 1;         // 0x0003(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	struct FLinearColor                           SunDiskColor;                                      // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MoonDiskColor;                                     // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SecondaryMoonRotation;                             // 0x0024(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MoonDiskIntensity;                                 // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonGlowIntensity;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonPhase;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonScale;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsIntensity;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsTiling;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayleighScatteringScale;                           // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RayleighScattering;                                // 0x004C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RayleighExponentialDistribution;                   // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MieScatteringScale;                                // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MieScattering;                                     // 0x0064(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MieAbsorptionScale;                                // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MieAbsorption;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MieAnisotropy;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MieExponentialDistribution;                        // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OtherAbsorptionScale;                              // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OtherAbsorption;                                   // 0x0094(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipAltitude;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TipValue;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TentWidth;                                         // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SkyLuminanceFactor;                                // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialPespectiveViewDistanceScale;                 // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightFogContribution;                             // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransmittanceMinLightElevationAngle;               // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AerialPerspectiveStartDepth;                       // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSkyAtmosphereSettings) == 0x000004, "Wrong alignment on FLSkyAtmosphereSettings");
static_assert(sizeof(FLSkyAtmosphereSettings) == 0x0000D0, "Wrong size on FLSkyAtmosphereSettings");
static_assert(offsetof(FLSkyAtmosphereSettings, SunDiskColor) == 0x000004, "Member 'FLSkyAtmosphereSettings::SunDiskColor' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MoonDiskColor) == 0x000014, "Member 'FLSkyAtmosphereSettings::MoonDiskColor' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, SecondaryMoonRotation) == 0x000024, "Member 'FLSkyAtmosphereSettings::SecondaryMoonRotation' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MoonDiskIntensity) == 0x000030, "Member 'FLSkyAtmosphereSettings::MoonDiskIntensity' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MoonGlowIntensity) == 0x000034, "Member 'FLSkyAtmosphereSettings::MoonGlowIntensity' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MoonPhase) == 0x000038, "Member 'FLSkyAtmosphereSettings::MoonPhase' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MoonScale) == 0x00003C, "Member 'FLSkyAtmosphereSettings::MoonScale' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, StarsIntensity) == 0x000040, "Member 'FLSkyAtmosphereSettings::StarsIntensity' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, StarsTiling) == 0x000044, "Member 'FLSkyAtmosphereSettings::StarsTiling' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, RayleighScatteringScale) == 0x000048, "Member 'FLSkyAtmosphereSettings::RayleighScatteringScale' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, RayleighScattering) == 0x00004C, "Member 'FLSkyAtmosphereSettings::RayleighScattering' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, RayleighExponentialDistribution) == 0x00005C, "Member 'FLSkyAtmosphereSettings::RayleighExponentialDistribution' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MieScatteringScale) == 0x000060, "Member 'FLSkyAtmosphereSettings::MieScatteringScale' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MieScattering) == 0x000064, "Member 'FLSkyAtmosphereSettings::MieScattering' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MieAbsorptionScale) == 0x000074, "Member 'FLSkyAtmosphereSettings::MieAbsorptionScale' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MieAbsorption) == 0x000078, "Member 'FLSkyAtmosphereSettings::MieAbsorption' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MieAnisotropy) == 0x000088, "Member 'FLSkyAtmosphereSettings::MieAnisotropy' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, MieExponentialDistribution) == 0x00008C, "Member 'FLSkyAtmosphereSettings::MieExponentialDistribution' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, OtherAbsorptionScale) == 0x000090, "Member 'FLSkyAtmosphereSettings::OtherAbsorptionScale' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, OtherAbsorption) == 0x000094, "Member 'FLSkyAtmosphereSettings::OtherAbsorption' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, TipAltitude) == 0x0000A4, "Member 'FLSkyAtmosphereSettings::TipAltitude' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, TipValue) == 0x0000A8, "Member 'FLSkyAtmosphereSettings::TipValue' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, TentWidth) == 0x0000AC, "Member 'FLSkyAtmosphereSettings::TentWidth' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, SkyLuminanceFactor) == 0x0000B0, "Member 'FLSkyAtmosphereSettings::SkyLuminanceFactor' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, AerialPespectiveViewDistanceScale) == 0x0000C0, "Member 'FLSkyAtmosphereSettings::AerialPespectiveViewDistanceScale' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, HeightFogContribution) == 0x0000C4, "Member 'FLSkyAtmosphereSettings::HeightFogContribution' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, TransmittanceMinLightElevationAngle) == 0x0000C8, "Member 'FLSkyAtmosphereSettings::TransmittanceMinLightElevationAngle' has a wrong offset!");
static_assert(offsetof(FLSkyAtmosphereSettings, AerialPerspectiveStartDepth) == 0x0000CC, "Member 'FLSkyAtmosphereSettings::AerialPerspectiveStartDepth' has a wrong offset!");

// ScriptStruct ProjectP.LElement_Attack
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FLElement_Attack final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLElement_Attack) == 0x000004, "Wrong alignment on FLElement_Attack");
static_assert(sizeof(FLElement_Attack) == 0x000010, "Wrong size on FLElement_Attack");

// ScriptStruct ProjectP.LElement_DamageHeal
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FLElement_DamageHeal final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLElement_DamageHeal) == 0x000004, "Wrong alignment on FLElement_DamageHeal");
static_assert(sizeof(FLElement_DamageHeal) == 0x000028, "Wrong size on FLElement_DamageHeal");

// ScriptStruct ProjectP.LDLCItemInOrder
// 0x0010 (0x0010 - 0x0000)
struct FLDLCItemInOrder final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDLCItemInOrder) == 0x000008, "Wrong alignment on FLDLCItemInOrder");
static_assert(sizeof(FLDLCItemInOrder) == 0x000010, "Wrong size on FLDLCItemInOrder");
static_assert(offsetof(FLDLCItemInOrder, Item) == 0x000000, "Member 'FLDLCItemInOrder::Item' has a wrong offset!");

// ScriptStruct ProjectP.LElement_ChangeStatus
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FLElement_ChangeStatus final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLElement_ChangeStatus) == 0x000004, "Wrong alignment on FLElement_ChangeStatus");
static_assert(sizeof(FLElement_ChangeStatus) == 0x00000C, "Wrong size on FLElement_ChangeStatus");

// ScriptStruct ProjectP.LValueModifier
// 0x0030 (0x0030 - 0x0000)
struct FLValueModifier final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELSecondStat                                  Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStatusValue;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BuildupAbnormalName;                               // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuildupDamage;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RegainValue;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SharpnessValue;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DurabilityValue;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErgoValue;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLValueModifier) == 0x000004, "Wrong alignment on FLValueModifier");
static_assert(sizeof(FLValueModifier) == 0x000030, "Wrong size on FLValueModifier");
static_assert(offsetof(FLValueModifier, Type) == 0x000008, "Member 'FLValueModifier::Type' has a wrong offset!");
static_assert(offsetof(FLValueModifier, Value) == 0x00000C, "Member 'FLValueModifier::Value' has a wrong offset!");
static_assert(offsetof(FLValueModifier, IsStatusValue) == 0x000010, "Member 'FLValueModifier::IsStatusValue' has a wrong offset!");
static_assert(offsetof(FLValueModifier, BuildupAbnormalName) == 0x000014, "Member 'FLValueModifier::BuildupAbnormalName' has a wrong offset!");
static_assert(offsetof(FLValueModifier, BuildupDamage) == 0x00001C, "Member 'FLValueModifier::BuildupDamage' has a wrong offset!");
static_assert(offsetof(FLValueModifier, RegainValue) == 0x000020, "Member 'FLValueModifier::RegainValue' has a wrong offset!");
static_assert(offsetof(FLValueModifier, SharpnessValue) == 0x000024, "Member 'FLValueModifier::SharpnessValue' has a wrong offset!");
static_assert(offsetof(FLValueModifier, DurabilityValue) == 0x000028, "Member 'FLValueModifier::DurabilityValue' has a wrong offset!");
static_assert(offsetof(FLValueModifier, ErgoValue) == 0x00002C, "Member 'FLValueModifier::ErgoValue' has a wrong offset!");

// ScriptStruct ProjectP.LDirectionalLightSettings
// 0x005C (0x005C - 0x0000)
struct FLDirectionalLightSettings final
{
public:
	uint8                                         bOverride_Rotation : 1;                            // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Intensity : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LightColor : 1;                          // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Temperature : 1;                         // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_IndirectLightingIntensity : 1;           // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VolumetricScatteringIntensity : 1;       // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ShadowAmount : 1;                        // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SpecularScale : 1;                       // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OcclusionMaskDarkness : 1;               // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OcclusionDepthRange : 1;                 // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomScale : 1;                          // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomThreshold : 1;                      // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomMaxBrightness : 1;                  // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_BloomTint : 1;                           // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotation;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Temperature;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndirectLightingIntensity;                         // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricScatteringIntensity;                     // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowAmount;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecularScale;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionMaskDarkness;                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionDepthRange;                               // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomScale;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomThreshold;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloomMaxBrightness;                                // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BloomTint;                                         // 0x004C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDirectionalLightSettings) == 0x000004, "Wrong alignment on FLDirectionalLightSettings");
static_assert(sizeof(FLDirectionalLightSettings) == 0x00005C, "Wrong size on FLDirectionalLightSettings");
static_assert(offsetof(FLDirectionalLightSettings, Rotation) == 0x000004, "Member 'FLDirectionalLightSettings::Rotation' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, Intensity) == 0x000010, "Member 'FLDirectionalLightSettings::Intensity' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, LightColor) == 0x000014, "Member 'FLDirectionalLightSettings::LightColor' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, Temperature) == 0x000024, "Member 'FLDirectionalLightSettings::Temperature' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, IndirectLightingIntensity) == 0x000028, "Member 'FLDirectionalLightSettings::IndirectLightingIntensity' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, VolumetricScatteringIntensity) == 0x00002C, "Member 'FLDirectionalLightSettings::VolumetricScatteringIntensity' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, ShadowAmount) == 0x000030, "Member 'FLDirectionalLightSettings::ShadowAmount' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, SpecularScale) == 0x000034, "Member 'FLDirectionalLightSettings::SpecularScale' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, OcclusionMaskDarkness) == 0x000038, "Member 'FLDirectionalLightSettings::OcclusionMaskDarkness' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, OcclusionDepthRange) == 0x00003C, "Member 'FLDirectionalLightSettings::OcclusionDepthRange' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, BloomScale) == 0x000040, "Member 'FLDirectionalLightSettings::BloomScale' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, BloomThreshold) == 0x000044, "Member 'FLDirectionalLightSettings::BloomThreshold' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, BloomMaxBrightness) == 0x000048, "Member 'FLDirectionalLightSettings::BloomMaxBrightness' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightSettings, BloomTint) == 0x00004C, "Member 'FLDirectionalLightSettings::BloomTint' has a wrong offset!");

// ScriptStruct ProjectP.LAchievementDetailInfoList
// 0x0010 (0x0010 - 0x0000)
struct FLAchievementDetailInfoList final
{
public:
	TArray<struct FAchievementDetailInfoPtr>      DetailInfoList;                                    // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAchievementDetailInfoList) == 0x000008, "Wrong alignment on FLAchievementDetailInfoList");
static_assert(sizeof(FLAchievementDetailInfoList) == 0x000010, "Wrong size on FLAchievementDetailInfoList");
static_assert(offsetof(FLAchievementDetailInfoList, DetailInfoList) == 0x000000, "Member 'FLAchievementDetailInfoList::DetailInfoList' has a wrong offset!");

// ScriptStruct ProjectP.LAchievementHierarchyInfo
// 0x0078 (0x0078 - 0x0000)
struct FLAchievementHierarchyInfo final
{
public:
	class FName                                   AchievementCodeName;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllComplete;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  StatusList;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FAchievementListInfoPtr                InfoPtr;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FLAchievementDetailInfoList> DetailInfoMap;                                     // 0x0028(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAchievementHierarchyInfo) == 0x000008, "Wrong alignment on FLAchievementHierarchyInfo");
static_assert(sizeof(FLAchievementHierarchyInfo) == 0x000078, "Wrong size on FLAchievementHierarchyInfo");
static_assert(offsetof(FLAchievementHierarchyInfo, AchievementCodeName) == 0x000000, "Member 'FLAchievementHierarchyInfo::AchievementCodeName' has a wrong offset!");
static_assert(offsetof(FLAchievementHierarchyInfo, AllComplete) == 0x000008, "Member 'FLAchievementHierarchyInfo::AllComplete' has a wrong offset!");
static_assert(offsetof(FLAchievementHierarchyInfo, StatusList) == 0x000010, "Member 'FLAchievementHierarchyInfo::StatusList' has a wrong offset!");
static_assert(offsetof(FLAchievementHierarchyInfo, InfoPtr) == 0x000020, "Member 'FLAchievementHierarchyInfo::InfoPtr' has a wrong offset!");
static_assert(offsetof(FLAchievementHierarchyInfo, DetailInfoMap) == 0x000028, "Member 'FLAchievementHierarchyInfo::DetailInfoMap' has a wrong offset!");

// ScriptStruct ProjectP.LLocomotionStateMachineChangeAnimation
// 0x0038 (0x0038 - 0x0000)
struct FLLocomotionStateMachineChangeAnimation final
{
public:
	class FName                                   StateMachineName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateNodeName;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         AnimationAsset;                                    // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLocomotionStateMachineChangeAnimation) == 0x000008, "Wrong alignment on FLLocomotionStateMachineChangeAnimation");
static_assert(sizeof(FLLocomotionStateMachineChangeAnimation) == 0x000038, "Wrong size on FLLocomotionStateMachineChangeAnimation");
static_assert(offsetof(FLLocomotionStateMachineChangeAnimation, StateMachineName) == 0x000000, "Member 'FLLocomotionStateMachineChangeAnimation::StateMachineName' has a wrong offset!");
static_assert(offsetof(FLLocomotionStateMachineChangeAnimation, StateNodeName) == 0x000008, "Member 'FLLocomotionStateMachineChangeAnimation::StateNodeName' has a wrong offset!");
static_assert(offsetof(FLLocomotionStateMachineChangeAnimation, AnimationAsset) == 0x000010, "Member 'FLLocomotionStateMachineChangeAnimation::AnimationAsset' has a wrong offset!");

// ScriptStruct ProjectP.LActionGroupTableRowType
// 0x0210 (0x0218 - 0x0008)
struct FLActionGroupTableRowType final : public FTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimBlueprint;                                     // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitMotion_ReplaceGroup_CodeName;                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         BaseAssetRef_CommonActionPath;                     // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         BaseAssetRef_LocomotionActionPath;                 // 0x0070(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         BaseAssetRef_SkillActionPath;                      // 0x0098(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLLocomotionStateMachineChangeAnimation> LocomotionArray;                                   // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bOverrideMoveBasedRootMotionSpeed;                 // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLMoveBasedRootMotionSpeed             MoveBasedRootMotionSpeed;                          // 0x00D4(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PeaceIdle_StateMachineName;                        // 0x00EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PeaceIdle_StateNodeName;                           // 0x00F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimationAsset>         PeaceIdle_AnimationAsset;                          // 0x0100(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PeaceMove_StateMachineName;                        // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PeaceMove_StateNodeName;                           // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         PeaceMove_AnimationAsset;                          // 0x0138(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatIdle_StateMachineName;                       // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatIdle_StateNodeName;                          // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         CombatIdle_AnimationAsset;                         // 0x0170(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatMove_StateMachineName;                       // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CombatMove_StateNodeName;                          // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         CombatMove_AnimationAsset;                         // 0x01A8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Additive_StateMachineName;                         // 0x01D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Additive_StateNodeName;                            // 0x01D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         Additive_AnimationAsset;                           // 0x01E0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           DeadMontageListForWeaponHold;                      // 0x0208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLActionGroupTableRowType) == 0x000008, "Wrong alignment on FLActionGroupTableRowType");
static_assert(sizeof(FLActionGroupTableRowType) == 0x000218, "Wrong size on FLActionGroupTableRowType");
static_assert(offsetof(FLActionGroupTableRowType, Description) == 0x000008, "Member 'FLActionGroupTableRowType::Description' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, AnimBlueprint) == 0x000018, "Member 'FLActionGroupTableRowType::AnimBlueprint' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, HitMotion_ReplaceGroup_CodeName) == 0x000040, "Member 'FLActionGroupTableRowType::HitMotion_ReplaceGroup_CodeName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, BaseAssetRef_CommonActionPath) == 0x000048, "Member 'FLActionGroupTableRowType::BaseAssetRef_CommonActionPath' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, BaseAssetRef_LocomotionActionPath) == 0x000070, "Member 'FLActionGroupTableRowType::BaseAssetRef_LocomotionActionPath' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, BaseAssetRef_SkillActionPath) == 0x000098, "Member 'FLActionGroupTableRowType::BaseAssetRef_SkillActionPath' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, LocomotionArray) == 0x0000C0, "Member 'FLActionGroupTableRowType::LocomotionArray' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, bOverrideMoveBasedRootMotionSpeed) == 0x0000D0, "Member 'FLActionGroupTableRowType::bOverrideMoveBasedRootMotionSpeed' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, MoveBasedRootMotionSpeed) == 0x0000D4, "Member 'FLActionGroupTableRowType::MoveBasedRootMotionSpeed' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, PeaceIdle_StateMachineName) == 0x0000EC, "Member 'FLActionGroupTableRowType::PeaceIdle_StateMachineName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, PeaceIdle_StateNodeName) == 0x0000F4, "Member 'FLActionGroupTableRowType::PeaceIdle_StateNodeName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, PeaceIdle_AnimationAsset) == 0x000100, "Member 'FLActionGroupTableRowType::PeaceIdle_AnimationAsset' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, PeaceMove_StateMachineName) == 0x000128, "Member 'FLActionGroupTableRowType::PeaceMove_StateMachineName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, PeaceMove_StateNodeName) == 0x000130, "Member 'FLActionGroupTableRowType::PeaceMove_StateNodeName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, PeaceMove_AnimationAsset) == 0x000138, "Member 'FLActionGroupTableRowType::PeaceMove_AnimationAsset' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, CombatIdle_StateMachineName) == 0x000160, "Member 'FLActionGroupTableRowType::CombatIdle_StateMachineName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, CombatIdle_StateNodeName) == 0x000168, "Member 'FLActionGroupTableRowType::CombatIdle_StateNodeName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, CombatIdle_AnimationAsset) == 0x000170, "Member 'FLActionGroupTableRowType::CombatIdle_AnimationAsset' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, CombatMove_StateMachineName) == 0x000198, "Member 'FLActionGroupTableRowType::CombatMove_StateMachineName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, CombatMove_StateNodeName) == 0x0001A0, "Member 'FLActionGroupTableRowType::CombatMove_StateNodeName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, CombatMove_AnimationAsset) == 0x0001A8, "Member 'FLActionGroupTableRowType::CombatMove_AnimationAsset' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, Additive_StateMachineName) == 0x0001D0, "Member 'FLActionGroupTableRowType::Additive_StateMachineName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, Additive_StateNodeName) == 0x0001D8, "Member 'FLActionGroupTableRowType::Additive_StateNodeName' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, Additive_AnimationAsset) == 0x0001E0, "Member 'FLActionGroupTableRowType::Additive_AnimationAsset' has a wrong offset!");
static_assert(offsetof(FLActionGroupTableRowType, DeadMontageListForWeaponHold) == 0x000208, "Member 'FLActionGroupTableRowType::DeadMontageListForWeaponHold' has a wrong offset!");

// ScriptStruct ProjectP.LSkyLightSettings
// 0x001C (0x001C - 0x0000)
struct FLSkyLightSettings final
{
public:
	uint8                                         bOverride_Intensity : 1;                           // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LightColor : 1;                          // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VolumetricScatteringIntensity : 1;       // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Intensity;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricScatteringIntensity;                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSkyLightSettings) == 0x000004, "Wrong alignment on FLSkyLightSettings");
static_assert(sizeof(FLSkyLightSettings) == 0x00001C, "Wrong size on FLSkyLightSettings");
static_assert(offsetof(FLSkyLightSettings, Intensity) == 0x000004, "Member 'FLSkyLightSettings::Intensity' has a wrong offset!");
static_assert(offsetof(FLSkyLightSettings, LightColor) == 0x000008, "Member 'FLSkyLightSettings::LightColor' has a wrong offset!");
static_assert(offsetof(FLSkyLightSettings, VolumetricScatteringIntensity) == 0x000018, "Member 'FLSkyLightSettings::VolumetricScatteringIntensity' has a wrong offset!");

// ScriptStruct ProjectP.ExiledNpcContext
// 0x0018 (0x0018 - 0x0000)
struct FExiledNpcContext final
{
public:
	class FName                                   NPCCodeName;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpotCodeName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengeCount;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsFelled : 1;                                      // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExiledNpcContext) == 0x000004, "Wrong alignment on FExiledNpcContext");
static_assert(sizeof(FExiledNpcContext) == 0x000018, "Wrong size on FExiledNpcContext");
static_assert(offsetof(FExiledNpcContext, NPCCodeName) == 0x000000, "Member 'FExiledNpcContext::NPCCodeName' has a wrong offset!");
static_assert(offsetof(FExiledNpcContext, SpotCodeName) == 0x000008, "Member 'FExiledNpcContext::SpotCodeName' has a wrong offset!");
static_assert(offsetof(FExiledNpcContext, ChallengeCount) == 0x000010, "Member 'FExiledNpcContext::ChallengeCount' has a wrong offset!");

// ScriptStruct ProjectP.ExiledNpcContextInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FExiledNpcContextInfo final
{
public:
	TArray<class FName>                           ExiledNpcCodeNameArray;                            // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExiledNpcSpotCodeNameArray;                        // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, TWeakObjectPtr<class ALExiledNpcArea>> ExiledNpcAreaMap;                                  // 0x0020(0x0050)(Edit, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, struct FExiledNpcContext>   ExiledNpcContextMap;                               // 0x0070(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ALExiledNpcArea>> ExiledNpcAreaArray_DeferredMsg_Inner;              // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class ALExiledNpcArea>> ExiledNpcAreaArray_DeferredMsg_Outer;              // 0x00D0(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExiledNpcContextInfo) == 0x000008, "Wrong alignment on FExiledNpcContextInfo");
static_assert(sizeof(FExiledNpcContextInfo) == 0x0000E0, "Wrong size on FExiledNpcContextInfo");
static_assert(offsetof(FExiledNpcContextInfo, ExiledNpcCodeNameArray) == 0x000000, "Member 'FExiledNpcContextInfo::ExiledNpcCodeNameArray' has a wrong offset!");
static_assert(offsetof(FExiledNpcContextInfo, ExiledNpcSpotCodeNameArray) == 0x000010, "Member 'FExiledNpcContextInfo::ExiledNpcSpotCodeNameArray' has a wrong offset!");
static_assert(offsetof(FExiledNpcContextInfo, ExiledNpcAreaMap) == 0x000020, "Member 'FExiledNpcContextInfo::ExiledNpcAreaMap' has a wrong offset!");
static_assert(offsetof(FExiledNpcContextInfo, ExiledNpcContextMap) == 0x000070, "Member 'FExiledNpcContextInfo::ExiledNpcContextMap' has a wrong offset!");
static_assert(offsetof(FExiledNpcContextInfo, ExiledNpcAreaArray_DeferredMsg_Inner) == 0x0000C0, "Member 'FExiledNpcContextInfo::ExiledNpcAreaArray_DeferredMsg_Inner' has a wrong offset!");
static_assert(offsetof(FExiledNpcContextInfo, ExiledNpcAreaArray_DeferredMsg_Outer) == 0x0000D0, "Member 'FExiledNpcContextInfo::ExiledNpcAreaArray_DeferredMsg_Outer' has a wrong offset!");

// ScriptStruct ProjectP.LActionGroupMontageValidMap
// 0x0001 (0x0001 - 0x0000)
struct FLActionGroupMontageValidMap final
{
public:
	uint8                                         bValidMontageBase : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bValidMontageReplace : 1;                          // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FLActionGroupMontageValidMap) == 0x000001, "Wrong alignment on FLActionGroupMontageValidMap");
static_assert(sizeof(FLActionGroupMontageValidMap) == 0x000001, "Wrong size on FLActionGroupMontageValidMap");

// ScriptStruct ProjectP.LConditionalAnimBranchContext
// 0x000C (0x000C - 0x0000)
struct FLConditionalAnimBranchContext final
{
public:
	ELConditionalAnimBranch                       Condition;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 Instigator;                                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLConditionalAnimBranchContext) == 0x000004, "Wrong alignment on FLConditionalAnimBranchContext");
static_assert(sizeof(FLConditionalAnimBranchContext) == 0x00000C, "Wrong size on FLConditionalAnimBranchContext");
static_assert(offsetof(FLConditionalAnimBranchContext, Condition) == 0x000000, "Member 'FLConditionalAnimBranchContext::Condition' has a wrong offset!");
static_assert(offsetof(FLConditionalAnimBranchContext, Instigator) == 0x000004, "Member 'FLConditionalAnimBranchContext::Instigator' has a wrong offset!");

// ScriptStruct ProjectP.LFootStepFxData
// 0x0078 (0x0078 - 0x0000)
struct FLFootStepFxData final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SoundCue1;                                         // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SoundCue2;                                         // 0x0050(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFootStepFxData) == 0x000008, "Wrong alignment on FLFootStepFxData");
static_assert(sizeof(FLFootStepFxData) == 0x000078, "Wrong size on FLFootStepFxData");
static_assert(offsetof(FLFootStepFxData, Niagara) == 0x000000, "Member 'FLFootStepFxData::Niagara' has a wrong offset!");
static_assert(offsetof(FLFootStepFxData, SoundCue1) == 0x000028, "Member 'FLFootStepFxData::SoundCue1' has a wrong offset!");
static_assert(offsetof(FLFootStepFxData, SoundCue2) == 0x000050, "Member 'FLFootStepFxData::SoundCue2' has a wrong offset!");

// ScriptStruct ProjectP.LActionInfo
// 0x0060 (0x0060 - 0x0000)
struct FLActionInfo final
{
public:
	struct FLGameObjectHandle                     HandleForActionStart;                              // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   InstigateCommand;                                  // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InstigateCommandEventTime;                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionClassCodeName;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillCodeName;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELActionCategory                              ActionCategory;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLAction_StartRotationInfo             StartRotationInfo;                                 // 0x0024(0x0028)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	ELStartRotationType                           ActionRotationType;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AutoGuideTarget;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingLoopElapsedTime;                            // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLActionInfo) == 0x000008, "Wrong alignment on FLActionInfo");
static_assert(sizeof(FLActionInfo) == 0x000060, "Wrong size on FLActionInfo");
static_assert(offsetof(FLActionInfo, HandleForActionStart) == 0x000000, "Member 'FLActionInfo::HandleForActionStart' has a wrong offset!");
static_assert(offsetof(FLActionInfo, InstigateCommand) == 0x000004, "Member 'FLActionInfo::InstigateCommand' has a wrong offset!");
static_assert(offsetof(FLActionInfo, InstigateCommandEventTime) == 0x00000C, "Member 'FLActionInfo::InstigateCommandEventTime' has a wrong offset!");
static_assert(offsetof(FLActionInfo, ActionClassCodeName) == 0x000010, "Member 'FLActionInfo::ActionClassCodeName' has a wrong offset!");
static_assert(offsetof(FLActionInfo, SkillCodeName) == 0x000018, "Member 'FLActionInfo::SkillCodeName' has a wrong offset!");
static_assert(offsetof(FLActionInfo, ActionCategory) == 0x000020, "Member 'FLActionInfo::ActionCategory' has a wrong offset!");
static_assert(offsetof(FLActionInfo, StartRotationInfo) == 0x000024, "Member 'FLActionInfo::StartRotationInfo' has a wrong offset!");
static_assert(offsetof(FLActionInfo, ActionRotationType) == 0x00004C, "Member 'FLActionInfo::ActionRotationType' has a wrong offset!");
static_assert(offsetof(FLActionInfo, AutoGuideTarget) == 0x000050, "Member 'FLActionInfo::AutoGuideTarget' has a wrong offset!");
static_assert(offsetof(FLActionInfo, WalkingLoopElapsedTime) == 0x000058, "Member 'FLActionInfo::WalkingLoopElapsedTime' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponBuildData
// 0x0030 (0x0030 - 0x0000)
struct FLWeaponBuildData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ALWeapon*                               WeaponActor;                                       // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWeaponBuildData) == 0x000008, "Wrong alignment on FLWeaponBuildData");
static_assert(sizeof(FLWeaponBuildData) == 0x000030, "Wrong size on FLWeaponBuildData");
static_assert(offsetof(FLWeaponBuildData, WeaponActor) == 0x000028, "Member 'FLWeaponBuildData::WeaponActor' has a wrong offset!");

// ScriptStruct ProjectP.LFallingHeightOverrideInfo
// 0x0008 (0x0008 - 0x0000)
struct FLFallingHeightOverrideInfo final
{
public:
	ELActionCategory                              ActionCategory;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingHeight;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFallingHeightOverrideInfo) == 0x000004, "Wrong alignment on FLFallingHeightOverrideInfo");
static_assert(sizeof(FLFallingHeightOverrideInfo) == 0x000008, "Wrong size on FLFallingHeightOverrideInfo");
static_assert(offsetof(FLFallingHeightOverrideInfo, ActionCategory) == 0x000000, "Member 'FLFallingHeightOverrideInfo::ActionCategory' has a wrong offset!");
static_assert(offsetof(FLFallingHeightOverrideInfo, FallingHeight) == 0x000004, "Member 'FLFallingHeightOverrideInfo::FallingHeight' has a wrong offset!");

// ScriptStruct ProjectP.HitCollisionDynamicArray
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FHitCollisionDynamicArray final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitCollisionDynamicArray) == 0x000008, "Wrong alignment on FHitCollisionDynamicArray");
static_assert(sizeof(FHitCollisionDynamicArray) == 0x000010, "Wrong size on FHitCollisionDynamicArray");

// ScriptStruct ProjectP.LTransformModifierInfo_MoveActor_Walking_Tracking
// 0x0058 (0x0058 - 0x0000)
struct FLTransformModifierInfo_MoveActor_Walking_Tracking final
{
public:
	TWeakObjectPtr<class AActor>                  TrackingTargetActor;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Movement;                                          // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IgnoreRotateUse : 1;                               // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           MoveCurve;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MoveDirection;                                     // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         CheckNavPath : 1;                                  // 0x0034(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         CheckFloor : 1;                                    // 0x0034(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MoveToTargetUse : 1;                               // 0x0034(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveToTargetSpeed;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToTargetSpeedMin;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToTargetSpeedMax;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToTargetOffsetDistance;                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PursuitToTargetScalingSpeedUse : 1;                // 0x0048(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PursuitToTargetScalingSpeedMin;                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PursuitToTargetScalingSpeedMax;                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PursuitToTargetScalingOffsetDistance;              // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTransformModifierInfo_MoveActor_Walking_Tracking) == 0x000008, "Wrong alignment on FLTransformModifierInfo_MoveActor_Walking_Tracking");
static_assert(sizeof(FLTransformModifierInfo_MoveActor_Walking_Tracking) == 0x000058, "Wrong size on FLTransformModifierInfo_MoveActor_Walking_Tracking");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, TrackingTargetActor) == 0x000000, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::TrackingTargetActor' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, Movement) == 0x000008, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::Movement' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, Speed) == 0x000014, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::Speed' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, Duration) == 0x000018, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::Duration' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, MoveCurve) == 0x000020, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::MoveCurve' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, MoveDirection) == 0x000028, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::MoveDirection' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, MoveToTargetSpeed) == 0x000038, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::MoveToTargetSpeed' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, MoveToTargetSpeedMin) == 0x00003C, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::MoveToTargetSpeedMin' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, MoveToTargetSpeedMax) == 0x000040, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::MoveToTargetSpeedMax' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, MoveToTargetOffsetDistance) == 0x000044, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::MoveToTargetOffsetDistance' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, PursuitToTargetScalingSpeedMin) == 0x00004C, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::PursuitToTargetScalingSpeedMin' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, PursuitToTargetScalingSpeedMax) == 0x000050, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::PursuitToTargetScalingSpeedMax' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_MoveActor_Walking_Tracking, PursuitToTargetScalingOffsetDistance) == 0x000054, "Member 'FLTransformModifierInfo_MoveActor_Walking_Tracking::PursuitToTargetScalingOffsetDistance' has a wrong offset!");

// ScriptStruct ProjectP.LTransformModifierInfo_RotateActor_Tracking
// 0x0034 (0x0034 - 0x0000)
struct FLTransformModifierInfo_RotateActor_Tracking final
{
public:
	TWeakObjectPtr<class AActor>                  TrackingTargetActor;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotateTrackingFullHomingUse : 1;                   // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedDegree;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompletionDegree_Left;                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompletionDegree_Right;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GiveUpDegree;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCaptureLocation;                                // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELTrackingDirectionType                       TrackingDirectionType;                             // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustYaw;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AdjustYaw_EarlyFinish : 1;                         // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SetDirectionOnStart : 1;                           // 0x0028(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SetDirectionOnStartLeft;                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetDirectionOnStartRight;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTransformModifierInfo_RotateActor_Tracking) == 0x000004, "Wrong alignment on FLTransformModifierInfo_RotateActor_Tracking");
static_assert(sizeof(FLTransformModifierInfo_RotateActor_Tracking) == 0x000034, "Wrong size on FLTransformModifierInfo_RotateActor_Tracking");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, TrackingTargetActor) == 0x000000, "Member 'FLTransformModifierInfo_RotateActor_Tracking::TrackingTargetActor' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, SpeedDegree) == 0x00000C, "Member 'FLTransformModifierInfo_RotateActor_Tracking::SpeedDegree' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, CompletionDegree_Left) == 0x000010, "Member 'FLTransformModifierInfo_RotateActor_Tracking::CompletionDegree_Left' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, CompletionDegree_Right) == 0x000014, "Member 'FLTransformModifierInfo_RotateActor_Tracking::CompletionDegree_Right' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, GiveUpDegree) == 0x000018, "Member 'FLTransformModifierInfo_RotateActor_Tracking::GiveUpDegree' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, Duration) == 0x00001C, "Member 'FLTransformModifierInfo_RotateActor_Tracking::Duration' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, UseCaptureLocation) == 0x000020, "Member 'FLTransformModifierInfo_RotateActor_Tracking::UseCaptureLocation' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, TrackingDirectionType) == 0x000021, "Member 'FLTransformModifierInfo_RotateActor_Tracking::TrackingDirectionType' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, AdjustYaw) == 0x000024, "Member 'FLTransformModifierInfo_RotateActor_Tracking::AdjustYaw' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, SetDirectionOnStartLeft) == 0x00002C, "Member 'FLTransformModifierInfo_RotateActor_Tracking::SetDirectionOnStartLeft' has a wrong offset!");
static_assert(offsetof(FLTransformModifierInfo_RotateActor_Tracking, SetDirectionOnStartRight) == 0x000030, "Member 'FLTransformModifierInfo_RotateActor_Tracking::SetDirectionOnStartRight' has a wrong offset!");

// ScriptStruct ProjectP.LSyncTransformToTargetInfo
// 0x0040 (0x0040 - 0x0000)
struct FLSyncTransformToTargetInfo final
{
public:
	TWeakObjectPtr<class AActor>                  SyncTargetActor;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocation;                                    // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OffsetRotation;                                    // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         OffsetRotationFromSyncTargetForward : 1;           // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UMeshComponent>          SyncMeshComponent;                                 // 0x0024(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SyncSocketName;                                    // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncDuration;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActiveDuration;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeElapsed;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSyncTransformToTargetInfo) == 0x000004, "Wrong alignment on FLSyncTransformToTargetInfo");
static_assert(sizeof(FLSyncTransformToTargetInfo) == 0x000040, "Wrong size on FLSyncTransformToTargetInfo");
static_assert(offsetof(FLSyncTransformToTargetInfo, SyncTargetActor) == 0x000000, "Member 'FLSyncTransformToTargetInfo::SyncTargetActor' has a wrong offset!");
static_assert(offsetof(FLSyncTransformToTargetInfo, OffsetLocation) == 0x000008, "Member 'FLSyncTransformToTargetInfo::OffsetLocation' has a wrong offset!");
static_assert(offsetof(FLSyncTransformToTargetInfo, OffsetRotation) == 0x000014, "Member 'FLSyncTransformToTargetInfo::OffsetRotation' has a wrong offset!");
static_assert(offsetof(FLSyncTransformToTargetInfo, SyncMeshComponent) == 0x000024, "Member 'FLSyncTransformToTargetInfo::SyncMeshComponent' has a wrong offset!");
static_assert(offsetof(FLSyncTransformToTargetInfo, SyncSocketName) == 0x00002C, "Member 'FLSyncTransformToTargetInfo::SyncSocketName' has a wrong offset!");
static_assert(offsetof(FLSyncTransformToTargetInfo, SyncDuration) == 0x000034, "Member 'FLSyncTransformToTargetInfo::SyncDuration' has a wrong offset!");
static_assert(offsetof(FLSyncTransformToTargetInfo, ActiveDuration) == 0x000038, "Member 'FLSyncTransformToTargetInfo::ActiveDuration' has a wrong offset!");
static_assert(offsetof(FLSyncTransformToTargetInfo, TimeElapsed) == 0x00003C, "Member 'FLSyncTransformToTargetInfo::TimeElapsed' has a wrong offset!");

// ScriptStruct ProjectP.LAITimer
// 0x0010 (0x0010 - 0x0000)
struct FLAITimer final
{
public:
	uint8                                         bTimeTicking : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPauseTime : 1;                                    // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CodeName;                                          // 0x0004(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLAITimer) == 0x000004, "Wrong alignment on FLAITimer");
static_assert(sizeof(FLAITimer) == 0x000010, "Wrong size on FLAITimer");
static_assert(offsetof(FLAITimer, CodeName) == 0x000004, "Member 'FLAITimer::CodeName' has a wrong offset!");
static_assert(offsetof(FLAITimer, ElapsedTime) == 0x00000C, "Member 'FLAITimer::ElapsedTime' has a wrong offset!");

// ScriptStruct ProjectP.LAILocationSampler
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FLAILocationSampler final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAILocationSampler) == 0x000008, "Wrong alignment on FLAILocationSampler");
static_assert(sizeof(FLAILocationSampler) == 0x000030, "Wrong size on FLAILocationSampler");

// ScriptStruct ProjectP.LAttachedEffectSet
// 0x001C (0x001C - 0x0000)
struct FLAttachedEffectSet final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFXSystemComponent>      VFX;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         SFX;                                               // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x4];                                       // 0x0018(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAttachedEffectSet) == 0x000004, "Wrong alignment on FLAttachedEffectSet");
static_assert(sizeof(FLAttachedEffectSet) == 0x00001C, "Wrong size on FLAttachedEffectSet");
static_assert(offsetof(FLAttachedEffectSet, VFX) == 0x000008, "Member 'FLAttachedEffectSet::VFX' has a wrong offset!");
static_assert(offsetof(FLAttachedEffectSet, SFX) == 0x000010, "Member 'FLAttachedEffectSet::SFX' has a wrong offset!");

// ScriptStruct ProjectP.LAILocationSampleItem
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FLAILocationSampleItem final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAILocationSampleItem) == 0x000004, "Wrong alignment on FLAILocationSampleItem");
static_assert(sizeof(FLAILocationSampleItem) == 0x000010, "Wrong size on FLAILocationSampleItem");

// ScriptStruct ProjectP.LFootIKContext
// 0x0074 (0x0074 - 0x0000)
struct FLFootIKContext final
{
public:
	class FName                                   FootBoneName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceTryStepForPelvisMove;                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootHeight;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFootRotation;                               // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ImpactPointOnTryStep;                              // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuccessTryStepForPelvisMove;                      // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TraceFootRootLocation;                             // 0x0024(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FootLocation;                                      // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasImpact;                                        // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ImpactPoint;                                       // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x004C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0058(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationOffsetInverseZ;                            // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0068(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFootIKContext) == 0x000004, "Wrong alignment on FLFootIKContext");
static_assert(sizeof(FLFootIKContext) == 0x000074, "Wrong size on FLFootIKContext");
static_assert(offsetof(FLFootIKContext, FootBoneName) == 0x000000, "Member 'FLFootIKContext::FootBoneName' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, DistanceTryStepForPelvisMove) == 0x000008, "Member 'FLFootIKContext::DistanceTryStepForPelvisMove' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, FootHeight) == 0x00000C, "Member 'FLFootIKContext::FootHeight' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, bEnableFootRotation) == 0x000010, "Member 'FLFootIKContext::bEnableFootRotation' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, ImpactPointOnTryStep) == 0x000014, "Member 'FLFootIKContext::ImpactPointOnTryStep' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, bSuccessTryStepForPelvisMove) == 0x000020, "Member 'FLFootIKContext::bSuccessTryStepForPelvisMove' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, TraceFootRootLocation) == 0x000024, "Member 'FLFootIKContext::TraceFootRootLocation' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, FootLocation) == 0x000030, "Member 'FLFootIKContext::FootLocation' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, bHasImpact) == 0x00003C, "Member 'FLFootIKContext::bHasImpact' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, ImpactPoint) == 0x000040, "Member 'FLFootIKContext::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, ImpactNormal) == 0x00004C, "Member 'FLFootIKContext::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, LocationOffset) == 0x000058, "Member 'FLFootIKContext::LocationOffset' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, LocationOffsetInverseZ) == 0x000064, "Member 'FLFootIKContext::LocationOffsetInverseZ' has a wrong offset!");
static_assert(offsetof(FLFootIKContext, RotationOffset) == 0x000068, "Member 'FLFootIKContext::RotationOffset' has a wrong offset!");

// ScriptStruct ProjectP.LInverseKinemetic
// 0x0040 (0x0040 - 0x0000)
struct FLInverseKinemetic final
{
public:
	class FName                                   PelvisBoneName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bDebugDraw : 1;                                    // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsMovingOnGround : 1;                             // 0x0008(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceStartPositionPelvisToFoot;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingVelocity;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableFootIK;                                      // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisOffset;                                      // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLFootIKContext>                Foots;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLInverseKinemetic) == 0x000008, "Wrong alignment on FLInverseKinemetic");
static_assert(sizeof(FLInverseKinemetic) == 0x000040, "Wrong size on FLInverseKinemetic");
static_assert(offsetof(FLInverseKinemetic, PelvisBoneName) == 0x000000, "Member 'FLInverseKinemetic::PelvisBoneName' has a wrong offset!");
static_assert(offsetof(FLInverseKinemetic, TraceStartPositionPelvisToFoot) == 0x00000C, "Member 'FLInverseKinemetic::TraceStartPositionPelvisToFoot' has a wrong offset!");
static_assert(offsetof(FLInverseKinemetic, MovingVelocity) == 0x000010, "Member 'FLInverseKinemetic::MovingVelocity' has a wrong offset!");
static_assert(offsetof(FLInverseKinemetic, EnableFootIK) == 0x000014, "Member 'FLInverseKinemetic::EnableFootIK' has a wrong offset!");
static_assert(offsetof(FLInverseKinemetic, PelvisOffset) == 0x000018, "Member 'FLInverseKinemetic::PelvisOffset' has a wrong offset!");
static_assert(offsetof(FLInverseKinemetic, Foots) == 0x000020, "Member 'FLInverseKinemetic::Foots' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialVaryingValue
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FLMaterialVaryingValue
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMaterialVaryingValue) == 0x000008, "Wrong alignment on FLMaterialVaryingValue");
static_assert(sizeof(FLMaterialVaryingValue) == 0x000008, "Wrong size on FLMaterialVaryingValue");

// ScriptStruct ProjectP.LMaterialVaryingScalar
// 0x0098 (0x00A0 - 0x0008)
struct FLMaterialVaryingScalar final : public FLMaterialVaryingValue
{
public:
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     CurveValue;                                        // 0x0018(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMaterialVaryingScalar) == 0x000008, "Wrong alignment on FLMaterialVaryingScalar");
static_assert(sizeof(FLMaterialVaryingScalar) == 0x0000A0, "Wrong size on FLMaterialVaryingScalar");
static_assert(offsetof(FLMaterialVaryingScalar, ParameterName) == 0x000008, "Member 'FLMaterialVaryingScalar::ParameterName' has a wrong offset!");
static_assert(offsetof(FLMaterialVaryingScalar, Value) == 0x000010, "Member 'FLMaterialVaryingScalar::Value' has a wrong offset!");
static_assert(offsetof(FLMaterialVaryingScalar, CurveValue) == 0x000018, "Member 'FLMaterialVaryingScalar::CurveValue' has a wrong offset!");

// ScriptStruct ProjectP.LPhysicsAssetForRigidBodyNode
// 0x0018 (0x0018 - 0x0000)
struct FLPhysicsAssetForRigidBodyNode final
{
public:
	class USkeletalMesh*                          MatchKey_SkelMesh;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MatchKey_Tag;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          OverridePhysicsAsset;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPhysicsAssetForRigidBodyNode) == 0x000008, "Wrong alignment on FLPhysicsAssetForRigidBodyNode");
static_assert(sizeof(FLPhysicsAssetForRigidBodyNode) == 0x000018, "Wrong size on FLPhysicsAssetForRigidBodyNode");
static_assert(offsetof(FLPhysicsAssetForRigidBodyNode, MatchKey_SkelMesh) == 0x000000, "Member 'FLPhysicsAssetForRigidBodyNode::MatchKey_SkelMesh' has a wrong offset!");
static_assert(offsetof(FLPhysicsAssetForRigidBodyNode, MatchKey_Tag) == 0x000008, "Member 'FLPhysicsAssetForRigidBodyNode::MatchKey_Tag' has a wrong offset!");
static_assert(offsetof(FLPhysicsAssetForRigidBodyNode, OverridePhysicsAsset) == 0x000010, "Member 'FLPhysicsAssetForRigidBodyNode::OverridePhysicsAsset' has a wrong offset!");

// ScriptStruct ProjectP.LPlaySoundNotify_TimeRecord
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FLPlaySoundNotify_TimeRecord final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPlaySoundNotify_TimeRecord) == 0x000004, "Wrong alignment on FLPlaySoundNotify_TimeRecord");
static_assert(sizeof(FLPlaySoundNotify_TimeRecord) == 0x000008, "Wrong size on FLPlaySoundNotify_TimeRecord");

// ScriptStruct ProjectP.LPlaySoundNotify_TimeChecker
// 0x0058 (0x0058 - 0x0000)
struct FLPlaySoundNotify_TimeChecker final
{
public:
	TMap<class FString, struct FLPlaySoundNotify_TimeRecord> TimeCheckerMap;                                    // 0x0000(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPlaySoundNotify_TimeChecker) == 0x000008, "Wrong alignment on FLPlaySoundNotify_TimeChecker");
static_assert(sizeof(FLPlaySoundNotify_TimeChecker) == 0x000058, "Wrong size on FLPlaySoundNotify_TimeChecker");
static_assert(offsetof(FLPlaySoundNotify_TimeChecker, TimeCheckerMap) == 0x000000, "Member 'FLPlaySoundNotify_TimeChecker::TimeCheckerMap' has a wrong offset!");

// ScriptStruct ProjectP.LDebugOption_Movement
// 0x0048 (0x0048 - 0x0000)
struct FLDebugOption_Movement final
{
public:
	uint8                                         Active_Move4Way_RootMotion : 1;                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Move4Way_RootMotion_PlayRateLimit_Low;             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_RootMotion_PlayRateLimit_High;            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_RootMotion_MoveAnimBaseSpeed_Run_C_F_Trans; // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_RootMotion_MoveAnimBaseSpeed_Run_C_F;     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_F;    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_B;    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_L;    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_R;    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Active_Move4Way : 1;                               // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Move4Way_ShowLog : 1;                              // 0x0024(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Move4Way_FrontAngleRange;                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_BackAngleRange;                           // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_MotionBlendDuration;                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_PelvisTwistSpeed;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_PelvisTwistDuration;                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_PelvisTwistLimit;                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_SpineTwistSpeed;                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Move4Way_SpineTwistDuration;                       // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDebugOption_Movement) == 0x000004, "Wrong alignment on FLDebugOption_Movement");
static_assert(sizeof(FLDebugOption_Movement) == 0x000048, "Wrong size on FLDebugOption_Movement");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_PlayRateLimit_Low) == 0x000004, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_PlayRateLimit_Low' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_PlayRateLimit_High) == 0x000008, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_PlayRateLimit_High' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_MoveAnimBaseSpeed_Run_C_F_Trans) == 0x00000C, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_MoveAnimBaseSpeed_Run_C_F_Trans' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_MoveAnimBaseSpeed_Run_C_F) == 0x000010, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_MoveAnimBaseSpeed_Run_C_F' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_F) == 0x000014, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_F' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_B) == 0x000018, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_B' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_L) == 0x00001C, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_L' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_R) == 0x000020, "Member 'FLDebugOption_Movement::Move4Way_RootMotion_MoveAnimBaseSpeed_Walk_C_R' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_FrontAngleRange) == 0x000028, "Member 'FLDebugOption_Movement::Move4Way_FrontAngleRange' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_BackAngleRange) == 0x00002C, "Member 'FLDebugOption_Movement::Move4Way_BackAngleRange' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_MotionBlendDuration) == 0x000030, "Member 'FLDebugOption_Movement::Move4Way_MotionBlendDuration' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_PelvisTwistSpeed) == 0x000034, "Member 'FLDebugOption_Movement::Move4Way_PelvisTwistSpeed' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_PelvisTwistDuration) == 0x000038, "Member 'FLDebugOption_Movement::Move4Way_PelvisTwistDuration' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_PelvisTwistLimit) == 0x00003C, "Member 'FLDebugOption_Movement::Move4Way_PelvisTwistLimit' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_SpineTwistSpeed) == 0x000040, "Member 'FLDebugOption_Movement::Move4Way_SpineTwistSpeed' has a wrong offset!");
static_assert(offsetof(FLDebugOption_Movement, Move4Way_SpineTwistDuration) == 0x000044, "Member 'FLDebugOption_Movement::Move4Way_SpineTwistDuration' has a wrong offset!");

// ScriptStruct ProjectP.LStretchBoneName
// 0x003C (0x003C - 0x0000)
struct alignas(0x04) FLStretchBoneName final
{
public:
	uint8                                         Pad_0[0x3C];                                       // 0x0000(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLStretchBoneName) == 0x000004, "Wrong alignment on FLStretchBoneName");
static_assert(sizeof(FLStretchBoneName) == 0x00003C, "Wrong size on FLStretchBoneName");

// ScriptStruct ProjectP.LStretchBoneList
// 0x0050 (0x0050 - 0x0000)
struct FLStretchBoneList final
{
public:
	TMap<class FName, struct FLStretchBoneName>   StretchBones;                                      // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLStretchBoneList) == 0x000008, "Wrong alignment on FLStretchBoneList");
static_assert(sizeof(FLStretchBoneList) == 0x000050, "Wrong size on FLStretchBoneList");
static_assert(offsetof(FLStretchBoneList, StretchBones) == 0x000000, "Member 'FLStretchBoneList::StretchBones' has a wrong offset!");

// ScriptStruct ProjectP.LBuffIconData
// 0x000C (0x000C - 0x0000)
struct FLBuffIconData final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromAbnormal;                                     // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSpecialBuff;                                  // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLBuffIconData) == 0x000004, "Wrong alignment on FLBuffIconData");
static_assert(sizeof(FLBuffIconData) == 0x00000C, "Wrong size on FLBuffIconData");
static_assert(offsetof(FLBuffIconData, CodeName) == 0x000000, "Member 'FLBuffIconData::CodeName' has a wrong offset!");
static_assert(offsetof(FLBuffIconData, bFromAbnormal) == 0x000008, "Member 'FLBuffIconData::bFromAbnormal' has a wrong offset!");
static_assert(offsetof(FLBuffIconData, bFromSpecialBuff) == 0x000009, "Member 'FLBuffIconData::bFromSpecialBuff' has a wrong offset!");

// ScriptStruct ProjectP.LRigStretchBone
// 0x000C (0x000C - 0x0000)
struct FLRigStretchBone final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StretchDistance;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLRigStretchBone) == 0x000004, "Wrong alignment on FLRigStretchBone");
static_assert(sizeof(FLRigStretchBone) == 0x00000C, "Wrong size on FLRigStretchBone");
static_assert(offsetof(FLRigStretchBone, BoneName) == 0x000000, "Member 'FLRigStretchBone::BoneName' has a wrong offset!");
static_assert(offsetof(FLRigStretchBone, StretchDistance) == 0x000008, "Member 'FLRigStretchBone::StretchDistance' has a wrong offset!");

// ScriptStruct ProjectP.LGalleryAssetTable
// 0x0008 (0x0008 - 0x0000)
struct FLGalleryAssetTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLGalleryAssetTable) == 0x000008, "Wrong alignment on FLGalleryAssetTable");
static_assert(sizeof(FLGalleryAssetTable) == 0x000008, "Wrong size on FLGalleryAssetTable");
static_assert(offsetof(FLGalleryAssetTable, Table) == 0x000000, "Member 'FLGalleryAssetTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LLockOnBoneName
// 0x0018 (0x0018 - 0x0000)
struct FLLockOnBoneName final
{
public:
	class FName                                   LockOn;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UpperLookAt;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFloatInterval                        PossibleAngle;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLockOnBoneName) == 0x000004, "Wrong alignment on FLLockOnBoneName");
static_assert(sizeof(FLLockOnBoneName) == 0x000018, "Wrong size on FLLockOnBoneName");
static_assert(offsetof(FLLockOnBoneName, LockOn) == 0x000000, "Member 'FLLockOnBoneName::LockOn' has a wrong offset!");
static_assert(offsetof(FLLockOnBoneName, UpperLookAt) == 0x000008, "Member 'FLLockOnBoneName::UpperLookAt' has a wrong offset!");
static_assert(offsetof(FLLockOnBoneName, PossibleAngle) == 0x000010, "Member 'FLLockOnBoneName::PossibleAngle' has a wrong offset!");

// ScriptStruct ProjectP.LDefinedBoneNames
// 0x0050 (0x0050 - 0x0000)
struct FLDefinedBoneNames final
{
public:
	class FName                                   Head;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponR;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponL;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponEx1;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponEx2;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponEx3;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponAttachPoint;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AimToTargetFire;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLLockOnBoneName>               LockOn;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDefinedBoneNames) == 0x000008, "Wrong alignment on FLDefinedBoneNames");
static_assert(sizeof(FLDefinedBoneNames) == 0x000050, "Wrong size on FLDefinedBoneNames");
static_assert(offsetof(FLDefinedBoneNames, Head) == 0x000000, "Member 'FLDefinedBoneNames::Head' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, WeaponR) == 0x000008, "Member 'FLDefinedBoneNames::WeaponR' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, WeaponL) == 0x000010, "Member 'FLDefinedBoneNames::WeaponL' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, WeaponEx1) == 0x000018, "Member 'FLDefinedBoneNames::WeaponEx1' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, WeaponEx2) == 0x000020, "Member 'FLDefinedBoneNames::WeaponEx2' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, WeaponEx3) == 0x000028, "Member 'FLDefinedBoneNames::WeaponEx3' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, WeaponAttachPoint) == 0x000030, "Member 'FLDefinedBoneNames::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, AimToTargetFire) == 0x000038, "Member 'FLDefinedBoneNames::AimToTargetFire' has a wrong offset!");
static_assert(offsetof(FLDefinedBoneNames, LockOn) == 0x000040, "Member 'FLDefinedBoneNames::LockOn' has a wrong offset!");

// ScriptStruct ProjectP.LNamedMaterialParamPlayer
// 0x0008 (0x0090 - 0x0088)
struct FLNamedMaterialParamPlayer final : public FLMaterialParamPlayer
{
public:
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNamedMaterialParamPlayer) == 0x000008, "Wrong alignment on FLNamedMaterialParamPlayer");
static_assert(sizeof(FLNamedMaterialParamPlayer) == 0x000090, "Wrong size on FLNamedMaterialParamPlayer");

// ScriptStruct ProjectP.LMontageSlotBlend
// 0x001C (0x001C - 0x0000)
struct FLMontageSlotBlend final
{
public:
	float                                         BlendSpeed;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BlendTargetSlotName;                               // 0x0004(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlotPlayRate;                                      // 0x000C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightSlotBlendWeight;                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeavySlotBlendWeight;                              // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasLightSlot;                                     // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasHeavySlot;                                     // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMontageSlotBlend) == 0x000004, "Wrong alignment on FLMontageSlotBlend");
static_assert(sizeof(FLMontageSlotBlend) == 0x00001C, "Wrong size on FLMontageSlotBlend");
static_assert(offsetof(FLMontageSlotBlend, BlendSpeed) == 0x000000, "Member 'FLMontageSlotBlend::BlendSpeed' has a wrong offset!");
static_assert(offsetof(FLMontageSlotBlend, BlendTargetSlotName) == 0x000004, "Member 'FLMontageSlotBlend::BlendTargetSlotName' has a wrong offset!");
static_assert(offsetof(FLMontageSlotBlend, SlotPlayRate) == 0x00000C, "Member 'FLMontageSlotBlend::SlotPlayRate' has a wrong offset!");
static_assert(offsetof(FLMontageSlotBlend, LightSlotBlendWeight) == 0x000010, "Member 'FLMontageSlotBlend::LightSlotBlendWeight' has a wrong offset!");
static_assert(offsetof(FLMontageSlotBlend, HeavySlotBlendWeight) == 0x000014, "Member 'FLMontageSlotBlend::HeavySlotBlendWeight' has a wrong offset!");
static_assert(offsetof(FLMontageSlotBlend, bHasLightSlot) == 0x000018, "Member 'FLMontageSlotBlend::bHasLightSlot' has a wrong offset!");
static_assert(offsetof(FLMontageSlotBlend, bHasHeavySlot) == 0x000019, "Member 'FLMontageSlotBlend::bHasHeavySlot' has a wrong offset!");

// ScriptStruct ProjectP.LMoveMotionBlend
// 0x0030 (0x0030 - 0x0000)
struct FLMoveMotionBlend final
{
public:
	int32                                         CurrMoveAnimInstacneID;                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveAnimBaseSpeed;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cached_PreventTime_ForMotionChange;                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELMoveMotionBlendDirection                    BlendTo_Direction;                                 // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendFrom_RightSpeed;                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendFrom_ForwardSpeed;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Previous_RightSpeed;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Previous_ForwardSpeed;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Previous_Speed;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cached_RemainTime_MoveMotionBlend;                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTo_PelvisAdditionalYaw;                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTo_SpineAdditionalYaw;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMoveMotionBlend) == 0x000004, "Wrong alignment on FLMoveMotionBlend");
static_assert(sizeof(FLMoveMotionBlend) == 0x000030, "Wrong size on FLMoveMotionBlend");
static_assert(offsetof(FLMoveMotionBlend, CurrMoveAnimInstacneID) == 0x000000, "Member 'FLMoveMotionBlend::CurrMoveAnimInstacneID' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, MoveAnimBaseSpeed) == 0x000004, "Member 'FLMoveMotionBlend::MoveAnimBaseSpeed' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, Cached_PreventTime_ForMotionChange) == 0x000008, "Member 'FLMoveMotionBlend::Cached_PreventTime_ForMotionChange' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, BlendTo_Direction) == 0x00000C, "Member 'FLMoveMotionBlend::BlendTo_Direction' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, BlendFrom_RightSpeed) == 0x000010, "Member 'FLMoveMotionBlend::BlendFrom_RightSpeed' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, BlendFrom_ForwardSpeed) == 0x000014, "Member 'FLMoveMotionBlend::BlendFrom_ForwardSpeed' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, Previous_RightSpeed) == 0x000018, "Member 'FLMoveMotionBlend::Previous_RightSpeed' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, Previous_ForwardSpeed) == 0x00001C, "Member 'FLMoveMotionBlend::Previous_ForwardSpeed' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, Previous_Speed) == 0x000020, "Member 'FLMoveMotionBlend::Previous_Speed' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, Cached_RemainTime_MoveMotionBlend) == 0x000024, "Member 'FLMoveMotionBlend::Cached_RemainTime_MoveMotionBlend' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, BlendTo_PelvisAdditionalYaw) == 0x000028, "Member 'FLMoveMotionBlend::BlendTo_PelvisAdditionalYaw' has a wrong offset!");
static_assert(offsetof(FLMoveMotionBlend, BlendTo_SpineAdditionalYaw) == 0x00002C, "Member 'FLMoveMotionBlend::BlendTo_SpineAdditionalYaw' has a wrong offset!");

// ScriptStruct ProjectP.MainAnimFSMData
// 0x0088 (0x0088 - 0x0000)
struct FMainAnimFSMData final
{
public:
	struct FLMoveMotionBlend                      MoveMotionBlend;                                   // 0x0000(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ELAnimFSMState                                MainAnimFSMState;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightSpeed;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardSpeed;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisAdditionalYaw;                               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpineAdditionalYaw;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveVelocity;                                      // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction_LockOn;                                  // 0x0054(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction_Move;                                    // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoveStopped;                                      // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFullBodyWhenMoveStopped;                          // 0x006D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAdditiveHitType                             AdditiveHitType;                                   // 0x006E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdditiveHitFlipFlop;                              // 0x006F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveAlpha;                                     // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandInteger;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasWeapon;                                        // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseDirection;                                 // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopMainStateByMontagePlaying;                    // 0x007A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequenceBindingPlaying;                           // 0x007B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  RagdollFreeze_SourceSkeletalMeshComponent;         // 0x007C(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RagdollFreeze_Enable : 1;                          // 0x0084(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMainAnimFSMData) == 0x000004, "Wrong alignment on FMainAnimFSMData");
static_assert(sizeof(FMainAnimFSMData) == 0x000088, "Wrong size on FMainAnimFSMData");
static_assert(offsetof(FMainAnimFSMData, MoveMotionBlend) == 0x000000, "Member 'FMainAnimFSMData::MoveMotionBlend' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, MainAnimFSMState) == 0x000030, "Member 'FMainAnimFSMData::MainAnimFSMState' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, Speed) == 0x000034, "Member 'FMainAnimFSMData::Speed' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, RightSpeed) == 0x000038, "Member 'FMainAnimFSMData::RightSpeed' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, ForwardSpeed) == 0x00003C, "Member 'FMainAnimFSMData::ForwardSpeed' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, PelvisAdditionalYaw) == 0x000040, "Member 'FMainAnimFSMData::PelvisAdditionalYaw' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, SpineAdditionalYaw) == 0x000044, "Member 'FMainAnimFSMData::SpineAdditionalYaw' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, MoveVelocity) == 0x000048, "Member 'FMainAnimFSMData::MoveVelocity' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, Direction_LockOn) == 0x000054, "Member 'FMainAnimFSMData::Direction_LockOn' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, Direction_Move) == 0x000060, "Member 'FMainAnimFSMData::Direction_Move' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, bMoveStopped) == 0x00006C, "Member 'FMainAnimFSMData::bMoveStopped' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, bFullBodyWhenMoveStopped) == 0x00006D, "Member 'FMainAnimFSMData::bFullBodyWhenMoveStopped' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, AdditiveHitType) == 0x00006E, "Member 'FMainAnimFSMData::AdditiveHitType' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, bAdditiveHitFlipFlop) == 0x00006F, "Member 'FMainAnimFSMData::bAdditiveHitFlipFlop' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, AdditiveAlpha) == 0x000070, "Member 'FMainAnimFSMData::AdditiveAlpha' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, RandInteger) == 0x000074, "Member 'FMainAnimFSMData::RandInteger' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, bHasWeapon) == 0x000078, "Member 'FMainAnimFSMData::bHasWeapon' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, bReverseDirection) == 0x000079, "Member 'FMainAnimFSMData::bReverseDirection' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, bStopMainStateByMontagePlaying) == 0x00007A, "Member 'FMainAnimFSMData::bStopMainStateByMontagePlaying' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, bSequenceBindingPlaying) == 0x00007B, "Member 'FMainAnimFSMData::bSequenceBindingPlaying' has a wrong offset!");
static_assert(offsetof(FMainAnimFSMData, RagdollFreeze_SourceSkeletalMeshComponent) == 0x00007C, "Member 'FMainAnimFSMData::RagdollFreeze_SourceSkeletalMeshComponent' has a wrong offset!");

// ScriptStruct ProjectP.LRootMotionJumpContext
// 0x0060 (0x0060 - 0x0000)
struct FLRootMotionJumpContext final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TargetingPC;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetTrasnform;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocation;                                    // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WireRewindDelay;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualFinishTime;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLRootMotionJumpContext) == 0x000010, "Wrong alignment on FLRootMotionJumpContext");
static_assert(sizeof(FLRootMotionJumpContext) == 0x000060, "Wrong size on FLRootMotionJumpContext");
static_assert(offsetof(FLRootMotionJumpContext, SkillCodeName) == 0x000000, "Member 'FLRootMotionJumpContext::SkillCodeName' has a wrong offset!");
static_assert(offsetof(FLRootMotionJumpContext, TargetingPC) == 0x000008, "Member 'FLRootMotionJumpContext::TargetingPC' has a wrong offset!");
static_assert(offsetof(FLRootMotionJumpContext, TargetTrasnform) == 0x000010, "Member 'FLRootMotionJumpContext::TargetTrasnform' has a wrong offset!");
static_assert(offsetof(FLRootMotionJumpContext, OffsetLocation) == 0x000040, "Member 'FLRootMotionJumpContext::OffsetLocation' has a wrong offset!");
static_assert(offsetof(FLRootMotionJumpContext, WireRewindDelay) == 0x00004C, "Member 'FLRootMotionJumpContext::WireRewindDelay' has a wrong offset!");
static_assert(offsetof(FLRootMotionJumpContext, ManualFinishTime) == 0x000050, "Member 'FLRootMotionJumpContext::ManualFinishTime' has a wrong offset!");

// ScriptStruct ProjectP.LAnimLookAtLimit
// 0x0010 (0x0010 - 0x0000)
struct FLAnimLookAtLimit final
{
public:
	float                                         Yaw_Min_Degree;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw_Max_Degree;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch_Min_Degree;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch_Max_Degree;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAnimLookAtLimit) == 0x000004, "Wrong alignment on FLAnimLookAtLimit");
static_assert(sizeof(FLAnimLookAtLimit) == 0x000010, "Wrong size on FLAnimLookAtLimit");
static_assert(offsetof(FLAnimLookAtLimit, Yaw_Min_Degree) == 0x000000, "Member 'FLAnimLookAtLimit::Yaw_Min_Degree' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtLimit, Yaw_Max_Degree) == 0x000004, "Member 'FLAnimLookAtLimit::Yaw_Max_Degree' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtLimit, Pitch_Min_Degree) == 0x000008, "Member 'FLAnimLookAtLimit::Pitch_Min_Degree' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtLimit, Pitch_Max_Degree) == 0x00000C, "Member 'FLAnimLookAtLimit::Pitch_Max_Degree' has a wrong offset!");

// ScriptStruct ProjectP.LAnimLookAtUpperBody
// 0x0040 (0x0040 - 0x0000)
struct FLAnimLookAtUpperBody final
{
public:
	uint8                                         bDebug : 1;                                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnable : 1;                                       // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSetLookAt : 1;                                    // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableYaw : 1;                                   // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProcessOutOfEffective : 1;                        // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtInterpSpeed;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLAnimLookAtLimit                      LimitAngle;                                        // 0x0008(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   YawBasisBoneName;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PitchBasisBoneName;                                // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LookAtRotation;                                    // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAnimLookAtUpperBody) == 0x000004, "Wrong alignment on FLAnimLookAtUpperBody");
static_assert(sizeof(FLAnimLookAtUpperBody) == 0x000040, "Wrong size on FLAnimLookAtUpperBody");
static_assert(offsetof(FLAnimLookAtUpperBody, LookAtInterpSpeed) == 0x000004, "Member 'FLAnimLookAtUpperBody::LookAtInterpSpeed' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtUpperBody, LimitAngle) == 0x000008, "Member 'FLAnimLookAtUpperBody::LimitAngle' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtUpperBody, YawBasisBoneName) == 0x000018, "Member 'FLAnimLookAtUpperBody::YawBasisBoneName' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtUpperBody, PitchBasisBoneName) == 0x000020, "Member 'FLAnimLookAtUpperBody::PitchBasisBoneName' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtUpperBody, LookAtRotation) == 0x000028, "Member 'FLAnimLookAtUpperBody::LookAtRotation' has a wrong offset!");

// ScriptStruct ProjectP.LGroggyPointAdjustRatio
// 0x0008 (0x0008 - 0x0000)
struct FLGroggyPointAdjustRatio final
{
public:
	int32                                         GroggyPoint;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GroggyPointRestoreBase;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGroggyPointAdjustRatio) == 0x000004, "Wrong alignment on FLGroggyPointAdjustRatio");
static_assert(sizeof(FLGroggyPointAdjustRatio) == 0x000008, "Wrong size on FLGroggyPointAdjustRatio");
static_assert(offsetof(FLGroggyPointAdjustRatio, GroggyPoint) == 0x000000, "Member 'FLGroggyPointAdjustRatio::GroggyPoint' has a wrong offset!");
static_assert(offsetof(FLGroggyPointAdjustRatio, GroggyPointRestoreBase) == 0x000004, "Member 'FLGroggyPointAdjustRatio::GroggyPointRestoreBase' has a wrong offset!");

// ScriptStruct ProjectP.LAnimLookAtHead
// 0x007C (0x007C - 0x0000)
struct FLAnimLookAtHead final
{
public:
	class FName                                   HeadBoneName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BasisBoneName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebug : 1;                                        // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnable : 1;                                       // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAutoSystemUpdate : 1;                             // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRotationPitch : 1;                                // 0x0010(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseComponentBaseBoneRotation : 1;                 // 0x0010(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEmptyRotationWhenClearLookAt : 1;                 // 0x0010(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bAddHeadBoneLocalTransform : 1;                    // 0x0010(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSetLookAt : 1;                                    // 0x0010(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bProcessOutOfEffective : 1;                        // 0x0011(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BasisBoneRotationAdditive;                         // 0x0014(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LookAtInterpSpeed;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HeadAxis;                                          // 0x0024(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLAnimLookAtLimit                      LimitAngle;                                        // 0x0030(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LookAtLocation;                                    // 0x0040(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LookAtRotation;                                    // 0x004C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0xC];                                       // 0x0058(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DesiredLookAtFrom;                                 // 0x0064(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0xC];                                       // 0x0070(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAnimLookAtHead) == 0x000004, "Wrong alignment on FLAnimLookAtHead");
static_assert(sizeof(FLAnimLookAtHead) == 0x00007C, "Wrong size on FLAnimLookAtHead");
static_assert(offsetof(FLAnimLookAtHead, HeadBoneName) == 0x000000, "Member 'FLAnimLookAtHead::HeadBoneName' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, BasisBoneName) == 0x000008, "Member 'FLAnimLookAtHead::BasisBoneName' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, BasisBoneRotationAdditive) == 0x000014, "Member 'FLAnimLookAtHead::BasisBoneRotationAdditive' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, LookAtInterpSpeed) == 0x000020, "Member 'FLAnimLookAtHead::LookAtInterpSpeed' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, HeadAxis) == 0x000024, "Member 'FLAnimLookAtHead::HeadAxis' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, LimitAngle) == 0x000030, "Member 'FLAnimLookAtHead::LimitAngle' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, LookAtLocation) == 0x000040, "Member 'FLAnimLookAtHead::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, LookAtRotation) == 0x00004C, "Member 'FLAnimLookAtHead::LookAtRotation' has a wrong offset!");
static_assert(offsetof(FLAnimLookAtHead, DesiredLookAtFrom) == 0x000064, "Member 'FLAnimLookAtHead::DesiredLookAtFrom' has a wrong offset!");

// ScriptStruct ProjectP.LHiddenComplex
// 0x0050 (0x0050 - 0x0000)
struct FLHiddenComplex final
{
public:
	TSet<class FName>                             HiddenNames;                                       // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLHiddenComplex) == 0x000008, "Wrong alignment on FLHiddenComplex");
static_assert(sizeof(FLHiddenComplex) == 0x000050, "Wrong size on FLHiddenComplex");
static_assert(offsetof(FLHiddenComplex, HiddenNames) == 0x000000, "Member 'FLHiddenComplex::HiddenNames' has a wrong offset!");

// ScriptStruct ProjectP.LAnimStateMachineInfo
// 0x0010 (0x0010 - 0x0000)
struct FLAnimStateMachineInfo final
{
public:
	TArray<class FName>                           StateArray;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAnimStateMachineInfo) == 0x000008, "Wrong alignment on FLAnimStateMachineInfo");
static_assert(sizeof(FLAnimStateMachineInfo) == 0x000010, "Wrong size on FLAnimStateMachineInfo");
static_assert(offsetof(FLAnimStateMachineInfo, StateArray) == 0x000000, "Member 'FLAnimStateMachineInfo::StateArray' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyBase
// 0x0008 (0x0008 - 0x0000)
struct FLBBoardKeyBase
{
public:
	class FName                                   KeyName;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLBBoardKeyBase) == 0x000004, "Wrong alignment on FLBBoardKeyBase");
static_assert(sizeof(FLBBoardKeyBase) == 0x000008, "Wrong size on FLBBoardKeyBase");
static_assert(offsetof(FLBBoardKeyBase, KeyName) == 0x000000, "Member 'FLBBoardKeyBase::KeyName' has a wrong offset!");

// ScriptStruct ProjectP.LDiplayableGallery
// 0x0010 (0x0010 - 0x0000)
struct FLDiplayableGallery final
{
public:
	struct FRecollectionInfoPtr                   Info;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Unlock;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDiplayableGallery) == 0x000008, "Wrong alignment on FLDiplayableGallery");
static_assert(sizeof(FLDiplayableGallery) == 0x000010, "Wrong size on FLDiplayableGallery");
static_assert(offsetof(FLDiplayableGallery, Info) == 0x000000, "Member 'FLDiplayableGallery::Info' has a wrong offset!");
static_assert(offsetof(FLDiplayableGallery, Unlock) == 0x000008, "Member 'FLDiplayableGallery::Unlock' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyNPC
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyNPC final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyNPC) == 0x000004, "Wrong alignment on FLBBoardKeyNPC");
static_assert(sizeof(FLBBoardKeyNPC) == 0x000008, "Wrong size on FLBBoardKeyNPC");

// ScriptStruct ProjectP.LBBoardKeyPC
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyPC final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyPC) == 0x000004, "Wrong alignment on FLBBoardKeyPC");
static_assert(sizeof(FLBBoardKeyPC) == 0x000008, "Wrong size on FLBBoardKeyPC");

// ScriptStruct ProjectP.LSpotData
// 0x0030 (0x0030 - 0x0000)
struct FLSpotData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELSpotType                                    SpotType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpotUniqueID;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActorSpawnable;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTouchedTalker;                                    // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TalkerCodeName;                                    // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReserveActorSpawn;                                 // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReserveActorDespawn;                               // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSpotData) == 0x000008, "Wrong alignment on FLSpotData");
static_assert(sizeof(FLSpotData) == 0x000030, "Wrong size on FLSpotData");
static_assert(offsetof(FLSpotData, SpotType) == 0x000008, "Member 'FLSpotData::SpotType' has a wrong offset!");
static_assert(offsetof(FLSpotData, SpotUniqueID) == 0x000010, "Member 'FLSpotData::SpotUniqueID' has a wrong offset!");
static_assert(offsetof(FLSpotData, ActorSpawnable) == 0x000020, "Member 'FLSpotData::ActorSpawnable' has a wrong offset!");
static_assert(offsetof(FLSpotData, bTouchedTalker) == 0x000021, "Member 'FLSpotData::bTouchedTalker' has a wrong offset!");
static_assert(offsetof(FLSpotData, TalkerCodeName) == 0x000024, "Member 'FLSpotData::TalkerCodeName' has a wrong offset!");
static_assert(offsetof(FLSpotData, ReserveActorSpawn) == 0x00002C, "Member 'FLSpotData::ReserveActorSpawn' has a wrong offset!");
static_assert(offsetof(FLSpotData, ReserveActorDespawn) == 0x00002D, "Member 'FLSpotData::ReserveActorDespawn' has a wrong offset!");

// ScriptStruct ProjectP.LPropSpotData
// 0x0008 (0x0038 - 0x0030)
struct FLPropSpotData : public FLSpotData
{
public:
	int32                                         PropData;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPropSpotData) == 0x000008, "Wrong alignment on FLPropSpotData");
static_assert(sizeof(FLPropSpotData) == 0x000038, "Wrong size on FLPropSpotData");
static_assert(offsetof(FLPropSpotData, PropData) == 0x000030, "Member 'FLPropSpotData::PropData' has a wrong offset!");

// ScriptStruct ProjectP.LLiftSpotData
// 0x0010 (0x0048 - 0x0038)
struct FLLiftSpotData final : public FLPropSpotData
{
public:
	class FName                                   LiftCodeName;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForceDefaultState;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLiftSpotData) == 0x000008, "Wrong alignment on FLLiftSpotData");
static_assert(sizeof(FLLiftSpotData) == 0x000048, "Wrong size on FLLiftSpotData");
static_assert(offsetof(FLLiftSpotData, LiftCodeName) == 0x000038, "Member 'FLLiftSpotData::LiftCodeName' has a wrong offset!");
static_assert(offsetof(FLLiftSpotData, ForceDefaultState) == 0x000040, "Member 'FLLiftSpotData::ForceDefaultState' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyCharacter
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyCharacter final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyCharacter) == 0x000004, "Wrong alignment on FLBBoardKeyCharacter");
static_assert(sizeof(FLBBoardKeyCharacter) == 0x000008, "Wrong size on FLBBoardKeyCharacter");

// ScriptStruct ProjectP.LBBoardKeyActor
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyActor final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyActor) == 0x000004, "Wrong alignment on FLBBoardKeyActor");
static_assert(sizeof(FLBBoardKeyActor) == 0x000008, "Wrong size on FLBBoardKeyActor");

// ScriptStruct ProjectP.LFirstStatData
// 0x0018 (0x0018 - 0x0000)
struct FLFirstStatData final
{
public:
	ELFirstStat                                   StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultStat;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterStat;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipStat;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuffStat;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalStat;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFirstStatData) == 0x000004, "Wrong alignment on FLFirstStatData");
static_assert(sizeof(FLFirstStatData) == 0x000018, "Wrong size on FLFirstStatData");
static_assert(offsetof(FLFirstStatData, StatType) == 0x000000, "Member 'FLFirstStatData::StatType' has a wrong offset!");
static_assert(offsetof(FLFirstStatData, DefaultStat) == 0x000004, "Member 'FLFirstStatData::DefaultStat' has a wrong offset!");
static_assert(offsetof(FLFirstStatData, CharacterStat) == 0x000008, "Member 'FLFirstStatData::CharacterStat' has a wrong offset!");
static_assert(offsetof(FLFirstStatData, EquipStat) == 0x00000C, "Member 'FLFirstStatData::EquipStat' has a wrong offset!");
static_assert(offsetof(FLFirstStatData, BuffStat) == 0x000010, "Member 'FLFirstStatData::BuffStat' has a wrong offset!");
static_assert(offsetof(FLFirstStatData, TotalStat) == 0x000014, "Member 'FLFirstStatData::TotalStat' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyRotator
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyRotator final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyRotator) == 0x000004, "Wrong alignment on FLBBoardKeyRotator");
static_assert(sizeof(FLBBoardKeyRotator) == 0x000008, "Wrong size on FLBBoardKeyRotator");

// ScriptStruct ProjectP.LBBoardKeyVector
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyVector final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyVector) == 0x000004, "Wrong alignment on FLBBoardKeyVector");
static_assert(sizeof(FLBBoardKeyVector) == 0x000008, "Wrong size on FLBBoardKeyVector");

// ScriptStruct ProjectP.LPropItemSpotData
// 0x0008 (0x0040 - 0x0038)
struct FLPropItemSpotData final : public FLPropSpotData
{
public:
	int32                                         PropItemData;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPropItemSpotData) == 0x000008, "Wrong alignment on FLPropItemSpotData");
static_assert(sizeof(FLPropItemSpotData) == 0x000040, "Wrong size on FLPropItemSpotData");
static_assert(offsetof(FLPropItemSpotData, PropItemData) == 0x000038, "Member 'FLPropItemSpotData::PropItemData' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyName
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyName final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyName) == 0x000004, "Wrong alignment on FLBBoardKeyName");
static_assert(sizeof(FLBBoardKeyName) == 0x000008, "Wrong size on FLBBoardKeyName");

// ScriptStruct ProjectP.LBBoardKeyString
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyString final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyString) == 0x000004, "Wrong alignment on FLBBoardKeyString");
static_assert(sizeof(FLBBoardKeyString) == 0x000008, "Wrong size on FLBBoardKeyString");

// ScriptStruct ProjectP.LVolumeSpotData
// 0x0010 (0x0048 - 0x0038)
struct FLVolumeSpotData final : public FLPropSpotData
{
public:
	class FName                                   VolumeCodeName;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLocationNameDisplay : 1;                          // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLVolumeSpotData) == 0x000008, "Wrong alignment on FLVolumeSpotData");
static_assert(sizeof(FLVolumeSpotData) == 0x000048, "Wrong size on FLVolumeSpotData");
static_assert(offsetof(FLVolumeSpotData, VolumeCodeName) == 0x000038, "Member 'FLVolumeSpotData::VolumeCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyBool
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyBool final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyBool) == 0x000004, "Wrong alignment on FLBBoardKeyBool");
static_assert(sizeof(FLBBoardKeyBool) == 0x000008, "Wrong size on FLBBoardKeyBool");

// ScriptStruct ProjectP.LBBoardKeyFloat
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyFloat final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyFloat) == 0x000004, "Wrong alignment on FLBBoardKeyFloat");
static_assert(sizeof(FLBBoardKeyFloat) == 0x000008, "Wrong size on FLBBoardKeyFloat");

// ScriptStruct ProjectP.LRecordCameraFrame
// 0x0018 (0x0018 - 0x0000)
struct FLRecordCameraFrame final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLRecordCameraFrame) == 0x000004, "Wrong alignment on FLRecordCameraFrame");
static_assert(sizeof(FLRecordCameraFrame) == 0x000018, "Wrong size on FLRecordCameraFrame");
static_assert(offsetof(FLRecordCameraFrame, Location) == 0x000000, "Member 'FLRecordCameraFrame::Location' has a wrong offset!");
static_assert(offsetof(FLRecordCameraFrame, Rotation) == 0x00000C, "Member 'FLRecordCameraFrame::Rotation' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyInt
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyInt final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyInt) == 0x000004, "Wrong alignment on FLBBoardKeyInt");
static_assert(sizeof(FLBBoardKeyInt) == 0x000008, "Wrong size on FLBBoardKeyInt");

// ScriptStruct ProjectP.LBBoardKeyEnum
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyEnum final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyEnum) == 0x000004, "Wrong alignment on FLBBoardKeyEnum");
static_assert(sizeof(FLBBoardKeyEnum) == 0x000008, "Wrong size on FLBBoardKeyEnum");

// ScriptStruct ProjectP.LSkillCodeNameType
// 0x0008 (0x0008 - 0x0000)
struct FLSkillCodeNameType final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSkillCodeNameType) == 0x000004, "Wrong alignment on FLSkillCodeNameType");
static_assert(sizeof(FLSkillCodeNameType) == 0x000008, "Wrong size on FLSkillCodeNameType");
static_assert(offsetof(FLSkillCodeNameType, CodeName) == 0x000000, "Member 'FLSkillCodeNameType::CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LFatalAttackCounterEnableInfo_ActionItem
// 0x0010 (0x0010 - 0x0000)
struct FLFatalAttackCounterEnableInfo_ActionItem final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLFatalAttackCounterEnableInfo_ActionItem) == 0x000008, "Wrong alignment on FLFatalAttackCounterEnableInfo_ActionItem");
static_assert(sizeof(FLFatalAttackCounterEnableInfo_ActionItem) == 0x000010, "Wrong size on FLFatalAttackCounterEnableInfo_ActionItem");
static_assert(offsetof(FLFatalAttackCounterEnableInfo_ActionItem, Montage) == 0x000000, "Member 'FLFatalAttackCounterEnableInfo_ActionItem::Montage' has a wrong offset!");
static_assert(offsetof(FLFatalAttackCounterEnableInfo_ActionItem, Probability) == 0x000008, "Member 'FLFatalAttackCounterEnableInfo_ActionItem::Probability' has a wrong offset!");

// ScriptStruct ProjectP.LFatalAttackCounterEnableInfo_Action
// 0x0018 (0x0018 - 0x0000)
struct FLFatalAttackCounterEnableInfo_Action final
{
public:
	struct FLSkillCodeNameType                    SkillCodeNameType;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLFatalAttackCounterEnableInfo_ActionItem> ActionArray;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFatalAttackCounterEnableInfo_Action) == 0x000008, "Wrong alignment on FLFatalAttackCounterEnableInfo_Action");
static_assert(sizeof(FLFatalAttackCounterEnableInfo_Action) == 0x000018, "Wrong size on FLFatalAttackCounterEnableInfo_Action");
static_assert(offsetof(FLFatalAttackCounterEnableInfo_Action, SkillCodeNameType) == 0x000000, "Member 'FLFatalAttackCounterEnableInfo_Action::SkillCodeNameType' has a wrong offset!");
static_assert(offsetof(FLFatalAttackCounterEnableInfo_Action, ActionArray) == 0x000008, "Member 'FLFatalAttackCounterEnableInfo_Action::ActionArray' has a wrong offset!");

// ScriptStruct ProjectP.LFatalAttackCounterEnableInfo
// 0x0018 (0x0018 - 0x0000)
struct FLFatalAttackCounterEnableInfo final
{
public:
	int32                                         Probability;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionHpRate;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLFatalAttackCounterEnableInfo_Action> SkillToActionArray;                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFatalAttackCounterEnableInfo) == 0x000008, "Wrong alignment on FLFatalAttackCounterEnableInfo");
static_assert(sizeof(FLFatalAttackCounterEnableInfo) == 0x000018, "Wrong size on FLFatalAttackCounterEnableInfo");
static_assert(offsetof(FLFatalAttackCounterEnableInfo, Probability) == 0x000000, "Member 'FLFatalAttackCounterEnableInfo::Probability' has a wrong offset!");
static_assert(offsetof(FLFatalAttackCounterEnableInfo, ConditionHpRate) == 0x000004, "Member 'FLFatalAttackCounterEnableInfo::ConditionHpRate' has a wrong offset!");
static_assert(offsetof(FLFatalAttackCounterEnableInfo, SkillToActionArray) == 0x000008, "Member 'FLFatalAttackCounterEnableInfo::SkillToActionArray' has a wrong offset!");

// ScriptStruct ProjectP.LBBoardKeyClass
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyClass final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyClass) == 0x000004, "Wrong alignment on FLBBoardKeyClass");
static_assert(sizeof(FLBBoardKeyClass) == 0x000008, "Wrong size on FLBBoardKeyClass");

// ScriptStruct ProjectP.LBBoardKeyObject
// 0x0000 (0x0008 - 0x0008)
struct FLBBoardKeyObject final : public FLBBoardKeyBase
{
};
static_assert(alignof(FLBBoardKeyObject) == 0x000004, "Wrong alignment on FLBBoardKeyObject");
static_assert(sizeof(FLBBoardKeyObject) == 0x000008, "Wrong size on FLBBoardKeyObject");

// ScriptStruct ProjectP.LSkillMoveInfoOverride
// 0x00A0 (0x00A0 - 0x0000)
struct FLSkillMoveInfoOverride final
{
public:
	uint8                                         IgnoreRootMotion_Rotation : 1;                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IgnoreRootMotion_Move : 1;                         // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         ApplyAnimScaling : 1;                              // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RotateEnable : 1;                                  // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateLimit;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotateAngleUse : 1;                                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateAngle;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotateUseCaptureLocation : 1;                      // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RotateTrackingUse : 1;                             // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         RotateTrackingFullHomingUse : 1;                   // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateTrackingSpeed;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateTrackingCompletionDegree;                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateTrackingCompletionDegreeLeft;                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateTrackingCompletionDegreeRight;               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateTrackingGiveUpDegree;                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotateTrackingSetDirectionOnStart : 1;             // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateTrackingSetDirectionOnStartLeft;             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateTrackingSetDirectionOnStartRight;            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELTrackingDirectionType                       RotateTrackingDirection;                           // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateTrackingRotateAngleOffset;                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RotateTrackingRotateAngleOffset_EarlyFinish : 1;   // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         MoveEnable : 1;                                    // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveRotYaw;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MoveToTargetUse : 1;                               // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveToTargetSpeed;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToTargetSpeedMin;                              // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToTargetSpeedMax;                              // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveToTargetOffsetDistance;                        // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PursuitToTargetScalingSpeedUse : 1;                // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PursuitToTargetScalingSpeedMin;                    // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PursuitToTargetScalingSpeedMax;                    // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PursuitToTargetScalingOffsetDistance;              // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MoveIgnoreRotateUse : 1;                           // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveDistance;                                      // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MoveCheckNavPath : 1;                              // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UObject>                 MoveCurve;                                         // 0x0078(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSkillMoveInfoOverride) == 0x000008, "Wrong alignment on FLSkillMoveInfoOverride");
static_assert(sizeof(FLSkillMoveInfoOverride) == 0x0000A0, "Wrong size on FLSkillMoveInfoOverride");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateLimit) == 0x000004, "Member 'FLSkillMoveInfoOverride::RotateLimit' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateAngle) == 0x00000C, "Member 'FLSkillMoveInfoOverride::RotateAngle' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingSpeed) == 0x000014, "Member 'FLSkillMoveInfoOverride::RotateTrackingSpeed' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingCompletionDegree) == 0x000018, "Member 'FLSkillMoveInfoOverride::RotateTrackingCompletionDegree' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingCompletionDegreeLeft) == 0x00001C, "Member 'FLSkillMoveInfoOverride::RotateTrackingCompletionDegreeLeft' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingCompletionDegreeRight) == 0x000020, "Member 'FLSkillMoveInfoOverride::RotateTrackingCompletionDegreeRight' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingGiveUpDegree) == 0x000024, "Member 'FLSkillMoveInfoOverride::RotateTrackingGiveUpDegree' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingSetDirectionOnStartLeft) == 0x00002C, "Member 'FLSkillMoveInfoOverride::RotateTrackingSetDirectionOnStartLeft' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingSetDirectionOnStartRight) == 0x000030, "Member 'FLSkillMoveInfoOverride::RotateTrackingSetDirectionOnStartRight' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingDirection) == 0x000034, "Member 'FLSkillMoveInfoOverride::RotateTrackingDirection' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, RotateTrackingRotateAngleOffset) == 0x000038, "Member 'FLSkillMoveInfoOverride::RotateTrackingRotateAngleOffset' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveRotYaw) == 0x000040, "Member 'FLSkillMoveInfoOverride::MoveRotYaw' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveToTargetSpeed) == 0x000048, "Member 'FLSkillMoveInfoOverride::MoveToTargetSpeed' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveToTargetSpeedMin) == 0x00004C, "Member 'FLSkillMoveInfoOverride::MoveToTargetSpeedMin' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveToTargetSpeedMax) == 0x000050, "Member 'FLSkillMoveInfoOverride::MoveToTargetSpeedMax' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveToTargetOffsetDistance) == 0x000054, "Member 'FLSkillMoveInfoOverride::MoveToTargetOffsetDistance' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, PursuitToTargetScalingSpeedMin) == 0x00005C, "Member 'FLSkillMoveInfoOverride::PursuitToTargetScalingSpeedMin' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, PursuitToTargetScalingSpeedMax) == 0x000060, "Member 'FLSkillMoveInfoOverride::PursuitToTargetScalingSpeedMax' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, PursuitToTargetScalingOffsetDistance) == 0x000064, "Member 'FLSkillMoveInfoOverride::PursuitToTargetScalingOffsetDistance' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveDistance) == 0x00006C, "Member 'FLSkillMoveInfoOverride::MoveDistance' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveSpeed) == 0x000070, "Member 'FLSkillMoveInfoOverride::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FLSkillMoveInfoOverride, MoveCurve) == 0x000078, "Member 'FLSkillMoveInfoOverride::MoveCurve' has a wrong offset!");

// ScriptStruct ProjectP.LBladeTrailTable
// 0x0008 (0x0008 - 0x0000)
struct FLBladeTrailTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLBladeTrailTable) == 0x000008, "Wrong alignment on FLBladeTrailTable");
static_assert(sizeof(FLBladeTrailTable) == 0x000008, "Wrong size on FLBladeTrailTable");
static_assert(offsetof(FLBladeTrailTable, Table) == 0x000000, "Member 'FLBladeTrailTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LBladeTrailTableRowType
// 0x0028 (0x0030 - 0x0008)
struct FLBladeTrailTableRowType final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UParticleSystem>         TrailParticle;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLBladeTrailTableRowType) == 0x000008, "Wrong alignment on FLBladeTrailTableRowType");
static_assert(sizeof(FLBladeTrailTableRowType) == 0x000030, "Wrong size on FLBladeTrailTableRowType");
static_assert(offsetof(FLBladeTrailTableRowType, TrailParticle) == 0x000008, "Member 'FLBladeTrailTableRowType::TrailParticle' has a wrong offset!");

// ScriptStruct ProjectP.LComponentDrop
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FLComponentDrop final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLComponentDrop) == 0x000008, "Wrong alignment on FLComponentDrop");
static_assert(sizeof(FLComponentDrop) == 0x000020, "Wrong size on FLComponentDrop");

// ScriptStruct ProjectP.LStain_Loop_Wet_Body_Info
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FLStain_Loop_Wet_Body_Info final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLStain_Loop_Wet_Body_Info) == 0x000004, "Wrong alignment on FLStain_Loop_Wet_Body_Info");
static_assert(sizeof(FLStain_Loop_Wet_Body_Info) == 0x000014, "Wrong size on FLStain_Loop_Wet_Body_Info");

// ScriptStruct ProjectP.LBTreePauseData
// 0x0008 (0x0008 - 0x0000)
struct FLBTreePauseData final
{
public:
	class FName                                   MetaName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLBTreePauseData) == 0x000004, "Wrong alignment on FLBTreePauseData");
static_assert(sizeof(FLBTreePauseData) == 0x000008, "Wrong size on FLBTreePauseData");
static_assert(offsetof(FLBTreePauseData, MetaName) == 0x000000, "Member 'FLBTreePauseData::MetaName' has a wrong offset!");

// ScriptStruct ProjectP.LBTreePauseList
// 0x0050 (0x0050 - 0x0000)
struct FLBTreePauseList final
{
public:
	TMap<class FName, struct FLBTreePauseData>    PauseList;                                         // 0x0000(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLBTreePauseList) == 0x000008, "Wrong alignment on FLBTreePauseList");
static_assert(sizeof(FLBTreePauseList) == 0x000050, "Wrong size on FLBTreePauseList");
static_assert(offsetof(FLBTreePauseList, PauseList) == 0x000000, "Member 'FLBTreePauseList::PauseList' has a wrong offset!");

// ScriptStruct ProjectP.LBTreeState
// 0x0020 (0x0020 - 0x0000)
struct FLBTreeState
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ConditionHP;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeactiveConditionCheckOnLeaveState;               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLBTreeState) == 0x000008, "Wrong alignment on FLBTreeState");
static_assert(sizeof(FLBTreeState) == 0x000020, "Wrong size on FLBTreeState");
static_assert(offsetof(FLBTreeState, BehaviorTree) == 0x000000, "Member 'FLBTreeState::BehaviorTree' has a wrong offset!");
static_assert(offsetof(FLBTreeState, ConditionHP) == 0x000008, "Member 'FLBTreeState::ConditionHP' has a wrong offset!");
static_assert(offsetof(FLBTreeState, bDeactiveConditionCheckOnLeaveState) == 0x000018, "Member 'FLBTreeState::bDeactiveConditionCheckOnLeaveState' has a wrong offset!");

// ScriptStruct ProjectP.LBTreeStateRuntime
// 0x00B0 (0x00D0 - 0x0020)
struct FLBTreeStateRuntime final : public FLBTreeState
{
public:
	class FName                                   StateName;                                         // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveCondition;                                  // 0x0028(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELBTreeStateConditionType                     ConditionType;                                     // 0x0029(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLBTreePauseList                       LastPauses;                                        // 0x0030(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	TSet<class FName>                             LastOnceConditionSet;                              // 0x0080(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLBTreeStateRuntime) == 0x000008, "Wrong alignment on FLBTreeStateRuntime");
static_assert(sizeof(FLBTreeStateRuntime) == 0x0000D0, "Wrong size on FLBTreeStateRuntime");
static_assert(offsetof(FLBTreeStateRuntime, StateName) == 0x000020, "Member 'FLBTreeStateRuntime::StateName' has a wrong offset!");
static_assert(offsetof(FLBTreeStateRuntime, bActiveCondition) == 0x000028, "Member 'FLBTreeStateRuntime::bActiveCondition' has a wrong offset!");
static_assert(offsetof(FLBTreeStateRuntime, ConditionType) == 0x000029, "Member 'FLBTreeStateRuntime::ConditionType' has a wrong offset!");
static_assert(offsetof(FLBTreeStateRuntime, LastPauses) == 0x000030, "Member 'FLBTreeStateRuntime::LastPauses' has a wrong offset!");
static_assert(offsetof(FLBTreeStateRuntime, LastOnceConditionSet) == 0x000080, "Member 'FLBTreeStateRuntime::LastOnceConditionSet' has a wrong offset!");

// ScriptStruct ProjectP.LBTreeStateMachine
// 0x0190 (0x0190 - 0x0000)
struct FLBTreeStateMachine final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULBTreeStateMachineData>    TestData;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLBTreeStateRuntime> StateMap;                                          // 0x0018(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class AAIController*                          Controller;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULBTreeStateMachineData*                RunningStateMachineData;                           // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class FName>                             OnceConditionSet;                                  // 0x0078(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FLBTreePauseList                       CurrentPauses;                                     // 0x00C8(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FLBTreePauseList                       MaintainPauses;                                    // 0x0118(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class FName                                   ReturnExtraToPrevStateName;                        // 0x0168(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBoostAIActivated : 1;                             // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_171[0x1F];                                     // 0x0171(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLBTreeStateMachine) == 0x000008, "Wrong alignment on FLBTreeStateMachine");
static_assert(sizeof(FLBTreeStateMachine) == 0x000190, "Wrong size on FLBTreeStateMachine");
static_assert(offsetof(FLBTreeStateMachine, TestData) == 0x000010, "Member 'FLBTreeStateMachine::TestData' has a wrong offset!");
static_assert(offsetof(FLBTreeStateMachine, StateMap) == 0x000018, "Member 'FLBTreeStateMachine::StateMap' has a wrong offset!");
static_assert(offsetof(FLBTreeStateMachine, Controller) == 0x000068, "Member 'FLBTreeStateMachine::Controller' has a wrong offset!");
static_assert(offsetof(FLBTreeStateMachine, RunningStateMachineData) == 0x000070, "Member 'FLBTreeStateMachine::RunningStateMachineData' has a wrong offset!");
static_assert(offsetof(FLBTreeStateMachine, OnceConditionSet) == 0x000078, "Member 'FLBTreeStateMachine::OnceConditionSet' has a wrong offset!");
static_assert(offsetof(FLBTreeStateMachine, CurrentPauses) == 0x0000C8, "Member 'FLBTreeStateMachine::CurrentPauses' has a wrong offset!");
static_assert(offsetof(FLBTreeStateMachine, MaintainPauses) == 0x000118, "Member 'FLBTreeStateMachine::MaintainPauses' has a wrong offset!");
static_assert(offsetof(FLBTreeStateMachine, ReturnExtraToPrevStateName) == 0x000168, "Member 'FLBTreeStateMachine::ReturnExtraToPrevStateName' has a wrong offset!");

// ScriptStruct ProjectP.LFatalIndicatorFx
// 0x0080 (0x0080 - 0x0000)
struct FLFatalIndicatorFx final
{
public:
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UNiagaraComponent>       FX_Attach;                                         // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         Sound_Attach;                                      // 0x0010(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UNiagaraComponent>       FX_Location_Active;                                // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         Sound_Location_Active;                             // 0x0020(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UNiagaraComponent>       FX_Location_Active_InRange;                        // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         Sound_Location_Active_InRange;                     // 0x0030(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UNiagaraComponent>       FX_Location_Success;                               // 0x0038(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         Sound_Location_Success;                            // 0x0040(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FxTransform;                                       // 0x0050(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFatalIndicatorFx) == 0x000010, "Wrong alignment on FLFatalIndicatorFx");
static_assert(sizeof(FLFatalIndicatorFx) == 0x000080, "Wrong size on FLFatalIndicatorFx");
static_assert(offsetof(FLFatalIndicatorFx, TargetActor) == 0x000000, "Member 'FLFatalIndicatorFx::TargetActor' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, FX_Attach) == 0x000008, "Member 'FLFatalIndicatorFx::FX_Attach' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, Sound_Attach) == 0x000010, "Member 'FLFatalIndicatorFx::Sound_Attach' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, FX_Location_Active) == 0x000018, "Member 'FLFatalIndicatorFx::FX_Location_Active' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, Sound_Location_Active) == 0x000020, "Member 'FLFatalIndicatorFx::Sound_Location_Active' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, FX_Location_Active_InRange) == 0x000028, "Member 'FLFatalIndicatorFx::FX_Location_Active_InRange' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, Sound_Location_Active_InRange) == 0x000030, "Member 'FLFatalIndicatorFx::Sound_Location_Active_InRange' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, FX_Location_Success) == 0x000038, "Member 'FLFatalIndicatorFx::FX_Location_Success' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, Sound_Location_Success) == 0x000040, "Member 'FLFatalIndicatorFx::Sound_Location_Success' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFx, FxTransform) == 0x000050, "Member 'FLFatalIndicatorFx::FxTransform' has a wrong offset!");

// ScriptStruct ProjectP.LFirstStatSimpleData
// 0x0008 (0x0008 - 0x0000)
struct FLFirstStatSimpleData final
{
public:
	ELFirstStat                                   StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StatData;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFirstStatSimpleData) == 0x000004, "Wrong alignment on FLFirstStatSimpleData");
static_assert(sizeof(FLFirstStatSimpleData) == 0x000008, "Wrong size on FLFirstStatSimpleData");
static_assert(offsetof(FLFirstStatSimpleData, StatType) == 0x000000, "Member 'FLFirstStatSimpleData::StatType' has a wrong offset!");
static_assert(offsetof(FLFirstStatSimpleData, StatData) == 0x000004, "Member 'FLFirstStatSimpleData::StatData' has a wrong offset!");

// ScriptStruct ProjectP.LQuartzSaveData
// 0x0020 (0x0020 - 0x0000)
struct FLQuartzSaveData final
{
public:
	bool                                          ActivateQuartzSystem;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CoreLevel;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLQuartzEffectSaveData>         EffectSaveDataList;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         CoreLevelupType;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLQuartzSaveData) == 0x000008, "Wrong alignment on FLQuartzSaveData");
static_assert(sizeof(FLQuartzSaveData) == 0x000020, "Wrong size on FLQuartzSaveData");
static_assert(offsetof(FLQuartzSaveData, ActivateQuartzSystem) == 0x000000, "Member 'FLQuartzSaveData::ActivateQuartzSystem' has a wrong offset!");
static_assert(offsetof(FLQuartzSaveData, CoreLevel) == 0x000004, "Member 'FLQuartzSaveData::CoreLevel' has a wrong offset!");
static_assert(offsetof(FLQuartzSaveData, EffectSaveDataList) == 0x000008, "Member 'FLQuartzSaveData::EffectSaveDataList' has a wrong offset!");
static_assert(offsetof(FLQuartzSaveData, CoreLevelupType) == 0x000018, "Member 'FLQuartzSaveData::CoreLevelupType' has a wrong offset!");

// ScriptStruct ProjectP.LAbnormalSaveData
// 0x0040 (0x0040 - 0x0000)
struct FLAbnormalSaveData final
{
public:
	int64                                         UniqueId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Running;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AbnormalName;                                      // 0x000C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Alter_AbnormalName;                                // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainDuration;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Forever;                                           // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         EnchantedWeaponId;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBuildupOverhit;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuildupGauge;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitForReduceBuildupGauge;                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAbnormalSaveData) == 0x000008, "Wrong alignment on FLAbnormalSaveData");
static_assert(sizeof(FLAbnormalSaveData) == 0x000040, "Wrong size on FLAbnormalSaveData");
static_assert(offsetof(FLAbnormalSaveData, UniqueId) == 0x000000, "Member 'FLAbnormalSaveData::UniqueId' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, Running) == 0x000008, "Member 'FLAbnormalSaveData::Running' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, AbnormalName) == 0x00000C, "Member 'FLAbnormalSaveData::AbnormalName' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, Alter_AbnormalName) == 0x000014, "Member 'FLAbnormalSaveData::Alter_AbnormalName' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, RemainDuration) == 0x00001C, "Member 'FLAbnormalSaveData::RemainDuration' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, Forever) == 0x000020, "Member 'FLAbnormalSaveData::Forever' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, EnchantedWeaponId) == 0x000028, "Member 'FLAbnormalSaveData::EnchantedWeaponId' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, IsBuildupOverhit) == 0x000030, "Member 'FLAbnormalSaveData::IsBuildupOverhit' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, BuildupGauge) == 0x000034, "Member 'FLAbnormalSaveData::BuildupGauge' has a wrong offset!");
static_assert(offsetof(FLAbnormalSaveData, WaitForReduceBuildupGauge) == 0x000038, "Member 'FLAbnormalSaveData::WaitForReduceBuildupGauge' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterAbnormalSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLCharacterAbnormalSaveData final
{
public:
	TArray<struct FLAbnormalSaveData>             PlayerAbnormals;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterAbnormalSaveData) == 0x000008, "Wrong alignment on FLCharacterAbnormalSaveData");
static_assert(sizeof(FLCharacterAbnormalSaveData) == 0x000010, "Wrong size on FLCharacterAbnormalSaveData");
static_assert(offsetof(FLCharacterAbnormalSaveData, PlayerAbnormals) == 0x000000, "Member 'FLCharacterAbnormalSaveData::PlayerAbnormals' has a wrong offset!");

// ScriptStruct ProjectP.LSlaveArmTreeSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLSlaveArmTreeSaveData final
{
public:
	TArray<class FName>                           ActivatedSlaveArmTreeList;                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSlaveArmTreeSaveData) == 0x000008, "Wrong alignment on FLSlaveArmTreeSaveData");
static_assert(sizeof(FLSlaveArmTreeSaveData) == 0x000010, "Wrong size on FLSlaveArmTreeSaveData");
static_assert(offsetof(FLSlaveArmTreeSaveData, ActivatedSlaveArmTreeList) == 0x000000, "Member 'FLSlaveArmTreeSaveData::ActivatedSlaveArmTreeList' has a wrong offset!");

// ScriptStruct ProjectP.LErgoDropData
// 0x0018 (0x0018 - 0x0000)
struct FLErgoDropData final
{
public:
	struct FVector                                DropLocation;                                      // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseErgo;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainErgo;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainFrenzyPoint;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLErgoDropData) == 0x000004, "Wrong alignment on FLErgoDropData");
static_assert(sizeof(FLErgoDropData) == 0x000018, "Wrong size on FLErgoDropData");
static_assert(offsetof(FLErgoDropData, DropLocation) == 0x000000, "Member 'FLErgoDropData::DropLocation' has a wrong offset!");
static_assert(offsetof(FLErgoDropData, BaseErgo) == 0x00000C, "Member 'FLErgoDropData::BaseErgo' has a wrong offset!");
static_assert(offsetof(FLErgoDropData, RemainErgo) == 0x000010, "Member 'FLErgoDropData::RemainErgo' has a wrong offset!");
static_assert(offsetof(FLErgoDropData, RemainFrenzyPoint) == 0x000014, "Member 'FLErgoDropData::RemainFrenzyPoint' has a wrong offset!");

// ScriptStruct ProjectP.LSpecialBuffSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLSpecialBuffSaveData final
{
public:
	class FName                                   SpecialBuffCodeName;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reason;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSpecialBuffSaveData) == 0x000004, "Wrong alignment on FLSpecialBuffSaveData");
static_assert(sizeof(FLSpecialBuffSaveData) == 0x000010, "Wrong size on FLSpecialBuffSaveData");
static_assert(offsetof(FLSpecialBuffSaveData, SpecialBuffCodeName) == 0x000000, "Member 'FLSpecialBuffSaveData::SpecialBuffCodeName' has a wrong offset!");
static_assert(offsetof(FLSpecialBuffSaveData, Reason) == 0x000008, "Member 'FLSpecialBuffSaveData::Reason' has a wrong offset!");

// ScriptStruct ProjectP.LSpecialBuffSystemSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLSpecialBuffSystemSaveData final
{
public:
	TArray<struct FLSpecialBuffSaveData>          SpecialBuffList;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSpecialBuffSystemSaveData) == 0x000008, "Wrong alignment on FLSpecialBuffSystemSaveData");
static_assert(sizeof(FLSpecialBuffSystemSaveData) == 0x000010, "Wrong size on FLSpecialBuffSystemSaveData");
static_assert(offsetof(FLSpecialBuffSystemSaveData, SpecialBuffList) == 0x000000, "Member 'FLSpecialBuffSystemSaveData::SpecialBuffList' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterSaveData
// 0x0360 (0x0360 - 0x0000)
struct FLCharacterSaveData final
{
public:
	class FString                                 CharacterName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterPlayTime;                                 // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AfterStarterPack : 1;                              // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NewGamePlus_Round;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bNewGamePlusProcess : 1;                           // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEyeColorChanged : 1;                              // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ELHairCategoryType                            HairCategoryType;                                  // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ELHairCategoryType>                    OwnHairCategoryTypeArray;                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         YouDieCount;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalReceiveDamage;                                // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcquisitionSoul;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextLevelUpRequireSoul;                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultStatCodeName;                               // 0x004C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLFirstStatSimpleData>          FirstStatSimpleList;                               // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         HumanityLevel;                                     // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AcquisitionHumanity;                               // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLCharacterItemSaveData                CharacterItem;                                     // 0x0070(0x00C0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLCharacterAbnormalSaveData            CharacterAbnormal;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLQuartzSaveData                       QuartzData;                                        // 0x0140(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLSlaveArmTreeSaveData                 SlaveArmTreeData;                                  // 0x0160(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLSpecialBuffSystemSaveData            SpecialBuffData;                                   // 0x0170(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayedBGMList;                                     // 0x0180(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           AcquiredHumanityRecordList;                        // 0x0190(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayedRecordList;                                  // 0x01A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<class FName>                           CollectedRecordList;                               // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	float                                         GoldenTreeCurrentSec;                              // 0x01C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldenTreeState;                                   // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldenTreeHarvestableCount;                        // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldenTreeRemainBoostCount;                        // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsPlayerReachedGoldenTree : 1;                     // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GoldenTreeBoostExcelSec;                           // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoldenTreeBoostExcelGoalSec;                       // 0x01D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResetCount_Quartz;                                 // 0x01DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResetCount_Stat;                                   // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResetCount_RegionArms;                             // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<class FString>                           AlreadyNotifiedUI;                                 // 0x01E8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLBuffIconData>                 BuffIconOrder;                                     // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LatestTransform;                                   // 0x0250(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ReserveRestartTransform;                           // 0x0280(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   LatestLocationName;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LatestPersistentLevelName;                         // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LatestWorldZoneName;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RespawnTeleportObject;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveTargetTeleportObject;                          // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RegistTorsionCoilName;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DepartureTeleportObject;                           // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondStat_HeadthPoint;                            // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondStat_FrenzyPoint;                            // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondStat_SlaveMagazinePoint;                     // 0x02F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondStat_PulseRechargePoint;                     // 0x02F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAttachedPCLamp : 1;                               // 0x02F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeatherCodeName;                                   // 0x02FC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeatherCodeNameReserve;                            // 0x0304(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLErgoDropData                         ErgoDropData;                                      // 0x030C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BossRoomSpotUniqueID;                              // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NpcSpotDieUniqueID;                                // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NpcSpotDieCondition;                               // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlatformActivity;                                  // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_354[0xC];                                      // 0x0354(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCharacterSaveData) == 0x000010, "Wrong alignment on FLCharacterSaveData");
static_assert(sizeof(FLCharacterSaveData) == 0x000360, "Wrong size on FLCharacterSaveData");
static_assert(offsetof(FLCharacterSaveData, CharacterName) == 0x000000, "Member 'FLCharacterSaveData::CharacterName' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, CharacterPlayTime) == 0x000010, "Member 'FLCharacterSaveData::CharacterPlayTime' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, NewGamePlus_Round) == 0x00001C, "Member 'FLCharacterSaveData::NewGamePlus_Round' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, HairCategoryType) == 0x000021, "Member 'FLCharacterSaveData::HairCategoryType' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, OwnHairCategoryTypeArray) == 0x000028, "Member 'FLCharacterSaveData::OwnHairCategoryTypeArray' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, YouDieCount) == 0x000038, "Member 'FLCharacterSaveData::YouDieCount' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, TotalReceiveDamage) == 0x00003C, "Member 'FLCharacterSaveData::TotalReceiveDamage' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, PlayerLevel) == 0x000040, "Member 'FLCharacterSaveData::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, AcquisitionSoul) == 0x000044, "Member 'FLCharacterSaveData::AcquisitionSoul' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, NextLevelUpRequireSoul) == 0x000048, "Member 'FLCharacterSaveData::NextLevelUpRequireSoul' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, DefaultStatCodeName) == 0x00004C, "Member 'FLCharacterSaveData::DefaultStatCodeName' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, FirstStatSimpleList) == 0x000058, "Member 'FLCharacterSaveData::FirstStatSimpleList' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, HumanityLevel) == 0x000068, "Member 'FLCharacterSaveData::HumanityLevel' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, AcquisitionHumanity) == 0x00006C, "Member 'FLCharacterSaveData::AcquisitionHumanity' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, CharacterItem) == 0x000070, "Member 'FLCharacterSaveData::CharacterItem' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, CharacterAbnormal) == 0x000130, "Member 'FLCharacterSaveData::CharacterAbnormal' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, QuartzData) == 0x000140, "Member 'FLCharacterSaveData::QuartzData' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, SlaveArmTreeData) == 0x000160, "Member 'FLCharacterSaveData::SlaveArmTreeData' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, SpecialBuffData) == 0x000170, "Member 'FLCharacterSaveData::SpecialBuffData' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, PlayedBGMList) == 0x000180, "Member 'FLCharacterSaveData::PlayedBGMList' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, AcquiredHumanityRecordList) == 0x000190, "Member 'FLCharacterSaveData::AcquiredHumanityRecordList' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, PlayedRecordList) == 0x0001A0, "Member 'FLCharacterSaveData::PlayedRecordList' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, CollectedRecordList) == 0x0001B0, "Member 'FLCharacterSaveData::CollectedRecordList' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, GoldenTreeCurrentSec) == 0x0001C0, "Member 'FLCharacterSaveData::GoldenTreeCurrentSec' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, GoldenTreeState) == 0x0001C4, "Member 'FLCharacterSaveData::GoldenTreeState' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, GoldenTreeHarvestableCount) == 0x0001C8, "Member 'FLCharacterSaveData::GoldenTreeHarvestableCount' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, GoldenTreeRemainBoostCount) == 0x0001CC, "Member 'FLCharacterSaveData::GoldenTreeRemainBoostCount' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, GoldenTreeBoostExcelSec) == 0x0001D4, "Member 'FLCharacterSaveData::GoldenTreeBoostExcelSec' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, GoldenTreeBoostExcelGoalSec) == 0x0001D8, "Member 'FLCharacterSaveData::GoldenTreeBoostExcelGoalSec' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, ResetCount_Quartz) == 0x0001DC, "Member 'FLCharacterSaveData::ResetCount_Quartz' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, ResetCount_Stat) == 0x0001E0, "Member 'FLCharacterSaveData::ResetCount_Stat' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, ResetCount_RegionArms) == 0x0001E4, "Member 'FLCharacterSaveData::ResetCount_RegionArms' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, AlreadyNotifiedUI) == 0x0001E8, "Member 'FLCharacterSaveData::AlreadyNotifiedUI' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, BuffIconOrder) == 0x000238, "Member 'FLCharacterSaveData::BuffIconOrder' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, LatestTransform) == 0x000250, "Member 'FLCharacterSaveData::LatestTransform' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, ReserveRestartTransform) == 0x000280, "Member 'FLCharacterSaveData::ReserveRestartTransform' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, LatestLocationName) == 0x0002B0, "Member 'FLCharacterSaveData::LatestLocationName' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, LatestPersistentLevelName) == 0x0002B8, "Member 'FLCharacterSaveData::LatestPersistentLevelName' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, LatestWorldZoneName) == 0x0002C0, "Member 'FLCharacterSaveData::LatestWorldZoneName' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, RespawnTeleportObject) == 0x0002C8, "Member 'FLCharacterSaveData::RespawnTeleportObject' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, MoveTargetTeleportObject) == 0x0002D0, "Member 'FLCharacterSaveData::MoveTargetTeleportObject' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, RegistTorsionCoilName) == 0x0002D8, "Member 'FLCharacterSaveData::RegistTorsionCoilName' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, DepartureTeleportObject) == 0x0002E0, "Member 'FLCharacterSaveData::DepartureTeleportObject' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, SecondStat_HeadthPoint) == 0x0002E8, "Member 'FLCharacterSaveData::SecondStat_HeadthPoint' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, SecondStat_FrenzyPoint) == 0x0002EC, "Member 'FLCharacterSaveData::SecondStat_FrenzyPoint' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, SecondStat_SlaveMagazinePoint) == 0x0002F0, "Member 'FLCharacterSaveData::SecondStat_SlaveMagazinePoint' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, SecondStat_PulseRechargePoint) == 0x0002F4, "Member 'FLCharacterSaveData::SecondStat_PulseRechargePoint' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, WeatherCodeName) == 0x0002FC, "Member 'FLCharacterSaveData::WeatherCodeName' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, WeatherCodeNameReserve) == 0x000304, "Member 'FLCharacterSaveData::WeatherCodeNameReserve' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, ErgoDropData) == 0x00030C, "Member 'FLCharacterSaveData::ErgoDropData' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, BossRoomSpotUniqueID) == 0x000328, "Member 'FLCharacterSaveData::BossRoomSpotUniqueID' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, NpcSpotDieUniqueID) == 0x000338, "Member 'FLCharacterSaveData::NpcSpotDieUniqueID' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, NpcSpotDieCondition) == 0x000348, "Member 'FLCharacterSaveData::NpcSpotDieCondition' has a wrong offset!");
static_assert(offsetof(FLCharacterSaveData, PlatformActivity) == 0x000350, "Member 'FLCharacterSaveData::PlatformActivity' has a wrong offset!");

// ScriptStruct ProjectP.LLazyCheckActionData
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FLLazyCheckActionData final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLazyCheckActionData) == 0x000004, "Wrong alignment on FLLazyCheckActionData");
static_assert(sizeof(FLLazyCheckActionData) == 0x00000C, "Wrong size on FLLazyCheckActionData");

// ScriptStruct ProjectP.LNPCSpecCondActivatorSet
// 0x0018 (0x0018 - 0x0000)
struct FLNPCSpecCondActivatorSet final
{
public:
	class ULNPCSpecConditionBase*                 Condition;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ULNPCSpecActionBase*>            Actions;                                           // 0x0008(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCSpecCondActivatorSet) == 0x000008, "Wrong alignment on FLNPCSpecCondActivatorSet");
static_assert(sizeof(FLNPCSpecCondActivatorSet) == 0x000018, "Wrong size on FLNPCSpecCondActivatorSet");
static_assert(offsetof(FLNPCSpecCondActivatorSet, Condition) == 0x000000, "Member 'FLNPCSpecCondActivatorSet::Condition' has a wrong offset!");
static_assert(offsetof(FLNPCSpecCondActivatorSet, Actions) == 0x000008, "Member 'FLNPCSpecCondActivatorSet::Actions' has a wrong offset!");

// ScriptStruct ProjectP.LCameraAttrModifierID
// 0x0010 (0x0010 - 0x0000)
struct FLCameraAttrModifierID final
{
public:
	TWeakObjectPtr<class UObject>                 Instigator;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLCameraAttrModifierID) == 0x000004, "Wrong alignment on FLCameraAttrModifierID");
static_assert(sizeof(FLCameraAttrModifierID) == 0x000010, "Wrong size on FLCameraAttrModifierID");
static_assert(offsetof(FLCameraAttrModifierID, Instigator) == 0x000000, "Member 'FLCameraAttrModifierID::Instigator' has a wrong offset!");
static_assert(offsetof(FLCameraAttrModifierID, Name) == 0x000008, "Member 'FLCameraAttrModifierID::Name' has a wrong offset!");

// ScriptStruct ProjectP.LFatalAttackInfo
// 0x0054 (0x0054 - 0x0000)
struct FLFatalAttackInfo final
{
public:
	uint8                                         IsValid : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EnableLocationFx : 1;                              // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ELFatalEnableRangeType                        FatalEnableRangeType;                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnableRadius;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableBoxWidth;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableBoxLength;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableVictimRadius;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableAttackerWidth;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EnableOffset;                                      // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttackerOffset;                                    // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackerOffsetAngle;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Replace_Fatal_Hit_Before_CodeName;                 // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Replace_Fatal_Hit_CodeName;                        // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Replace_Fatal_Hit_End_CodeName;                    // 0x0044(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsFromNotify : 1;                                  // 0x004C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InfoIndex;                                         // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFatalAttackInfo) == 0x000004, "Wrong alignment on FLFatalAttackInfo");
static_assert(sizeof(FLFatalAttackInfo) == 0x000054, "Wrong size on FLFatalAttackInfo");
static_assert(offsetof(FLFatalAttackInfo, FatalEnableRangeType) == 0x000001, "Member 'FLFatalAttackInfo::FatalEnableRangeType' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, EnableRadius) == 0x000004, "Member 'FLFatalAttackInfo::EnableRadius' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, EnableBoxWidth) == 0x000008, "Member 'FLFatalAttackInfo::EnableBoxWidth' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, EnableBoxLength) == 0x00000C, "Member 'FLFatalAttackInfo::EnableBoxLength' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, EnableVictimRadius) == 0x000010, "Member 'FLFatalAttackInfo::EnableVictimRadius' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, EnableAttackerWidth) == 0x000014, "Member 'FLFatalAttackInfo::EnableAttackerWidth' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, EnableOffset) == 0x000018, "Member 'FLFatalAttackInfo::EnableOffset' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, AttackerOffset) == 0x000024, "Member 'FLFatalAttackInfo::AttackerOffset' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, AttackerOffsetAngle) == 0x000030, "Member 'FLFatalAttackInfo::AttackerOffsetAngle' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, Replace_Fatal_Hit_Before_CodeName) == 0x000034, "Member 'FLFatalAttackInfo::Replace_Fatal_Hit_Before_CodeName' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, Replace_Fatal_Hit_CodeName) == 0x00003C, "Member 'FLFatalAttackInfo::Replace_Fatal_Hit_CodeName' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, Replace_Fatal_Hit_End_CodeName) == 0x000044, "Member 'FLFatalAttackInfo::Replace_Fatal_Hit_End_CodeName' has a wrong offset!");
static_assert(offsetof(FLFatalAttackInfo, InfoIndex) == 0x000050, "Member 'FLFatalAttackInfo::InfoIndex' has a wrong offset!");

// ScriptStruct ProjectP.LFatalIndicatorFxState
// 0x00A0 (0x00A0 - 0x0000)
struct FLFatalIndicatorFxState final
{
public:
	class FName                                   IndicatorKey;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFatalIndicatorState                         PrevState;                                         // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFatalIndicatorState                         CurrentState;                                      // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLFatalAttackInfo                      FatalAttackInfo;                                   // 0x0014(0x0054)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FxTransform;                                       // 0x0070(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFatalIndicatorFxState) == 0x000010, "Wrong alignment on FLFatalIndicatorFxState");
static_assert(sizeof(FLFatalIndicatorFxState) == 0x0000A0, "Wrong size on FLFatalIndicatorFxState");
static_assert(offsetof(FLFatalIndicatorFxState, IndicatorKey) == 0x000000, "Member 'FLFatalIndicatorFxState::IndicatorKey' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFxState, TargetActor) == 0x000008, "Member 'FLFatalIndicatorFxState::TargetActor' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFxState, PrevState) == 0x000010, "Member 'FLFatalIndicatorFxState::PrevState' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFxState, CurrentState) == 0x000011, "Member 'FLFatalIndicatorFxState::CurrentState' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFxState, FatalAttackInfo) == 0x000014, "Member 'FLFatalIndicatorFxState::FatalAttackInfo' has a wrong offset!");
static_assert(offsetof(FLFatalIndicatorFxState, FxTransform) == 0x000070, "Member 'FLFatalIndicatorFxState::FxTransform' has a wrong offset!");

// ScriptStruct ProjectP.LCameraAttrModifierBlendTime
// 0x0008 (0x0008 - 0x0000)
struct FLCameraAttrModifierBlendTime final
{
public:
	float                                         BlendIn;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOut;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCameraAttrModifierBlendTime) == 0x000004, "Wrong alignment on FLCameraAttrModifierBlendTime");
static_assert(sizeof(FLCameraAttrModifierBlendTime) == 0x000008, "Wrong size on FLCameraAttrModifierBlendTime");
static_assert(offsetof(FLCameraAttrModifierBlendTime, BlendIn) == 0x000000, "Member 'FLCameraAttrModifierBlendTime::BlendIn' has a wrong offset!");
static_assert(offsetof(FLCameraAttrModifierBlendTime, BlendOut) == 0x000004, "Member 'FLCameraAttrModifierBlendTime::BlendOut' has a wrong offset!");

// ScriptStruct ProjectP.LWorldEventData
// 0x0010 (0x0010 - 0x0000)
struct FLWorldEventData final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DetailIndex;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CallbackCount;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWorldEventData) == 0x000004, "Wrong alignment on FLWorldEventData");
static_assert(sizeof(FLWorldEventData) == 0x000010, "Wrong size on FLWorldEventData");
static_assert(offsetof(FLWorldEventData, CodeName) == 0x000000, "Member 'FLWorldEventData::CodeName' has a wrong offset!");
static_assert(offsetof(FLWorldEventData, DetailIndex) == 0x000008, "Member 'FLWorldEventData::DetailIndex' has a wrong offset!");
static_assert(offsetof(FLWorldEventData, CallbackCount) == 0x00000C, "Member 'FLWorldEventData::CallbackCount' has a wrong offset!");

// ScriptStruct ProjectP.LWorldEventSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLWorldEventSaveData final
{
public:
	TArray<struct FLWorldEventData>               WorldEventDataList;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWorldEventSaveData) == 0x000008, "Wrong alignment on FLWorldEventSaveData");
static_assert(sizeof(FLWorldEventSaveData) == 0x000010, "Wrong size on FLWorldEventSaveData");
static_assert(offsetof(FLWorldEventSaveData, WorldEventDataList) == 0x000000, "Member 'FLWorldEventSaveData::WorldEventDataList' has a wrong offset!");

// ScriptStruct ProjectP.LCameraMovingPitchSection
// 0x0010 (0x0010 - 0x0000)
struct FLCameraMovingPitchSection final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredPitch;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxModifyAmount;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCameraMovingPitchSection) == 0x000004, "Wrong alignment on FLCameraMovingPitchSection");
static_assert(sizeof(FLCameraMovingPitchSection) == 0x000010, "Wrong size on FLCameraMovingPitchSection");
static_assert(offsetof(FLCameraMovingPitchSection, Min) == 0x000000, "Member 'FLCameraMovingPitchSection::Min' has a wrong offset!");
static_assert(offsetof(FLCameraMovingPitchSection, Max) == 0x000004, "Member 'FLCameraMovingPitchSection::Max' has a wrong offset!");
static_assert(offsetof(FLCameraMovingPitchSection, DesiredPitch) == 0x000008, "Member 'FLCameraMovingPitchSection::DesiredPitch' has a wrong offset!");
static_assert(offsetof(FLCameraMovingPitchSection, MaxModifyAmount) == 0x00000C, "Member 'FLCameraMovingPitchSection::MaxModifyAmount' has a wrong offset!");

// ScriptStruct ProjectP.LCameraMovingPitch
// 0x0028 (0x0028 - 0x0000)
struct FLCameraMovingPitch final
{
public:
	float                                         ActiveTime;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLCameraMovingPitchSection>     PitchSections;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         PitchSpeedOn;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PitchSpeedOff;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLCameraMovingPitch) == 0x000008, "Wrong alignment on FLCameraMovingPitch");
static_assert(sizeof(FLCameraMovingPitch) == 0x000028, "Wrong size on FLCameraMovingPitch");
static_assert(offsetof(FLCameraMovingPitch, ActiveTime) == 0x000000, "Member 'FLCameraMovingPitch::ActiveTime' has a wrong offset!");
static_assert(offsetof(FLCameraMovingPitch, PitchSections) == 0x000010, "Member 'FLCameraMovingPitch::PitchSections' has a wrong offset!");
static_assert(offsetof(FLCameraMovingPitch, PitchSpeedOn) == 0x000020, "Member 'FLCameraMovingPitch::PitchSpeedOn' has a wrong offset!");
static_assert(offsetof(FLCameraMovingPitch, PitchSpeedOff) == 0x000024, "Member 'FLCameraMovingPitch::PitchSpeedOff' has a wrong offset!");

// ScriptStruct ProjectP.LLazyCheckActionCategoryResetData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLLazyCheckActionCategoryResetData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLazyCheckActionCategoryResetData) == 0x000008, "Wrong alignment on FLLazyCheckActionCategoryResetData");
static_assert(sizeof(FLLazyCheckActionCategoryResetData) == 0x000010, "Wrong size on FLLazyCheckActionCategoryResetData");

// ScriptStruct ProjectP.LLazyCheckActionStore
// 0x00A0 (0x00A0 - 0x0000)
struct FLLazyCheckActionStore final
{
public:
	TMap<ELActionCategory, struct FLLazyCheckActionData> ActionCategoryStoreDatas;                          // 0x0000(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TMap<ELActionCategory, struct FLLazyCheckActionCategoryResetData> ActionCategoryResetDatas;                          // 0x0050(0x0050)(Edit, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLLazyCheckActionStore) == 0x000008, "Wrong alignment on FLLazyCheckActionStore");
static_assert(sizeof(FLLazyCheckActionStore) == 0x0000A0, "Wrong size on FLLazyCheckActionStore");
static_assert(offsetof(FLLazyCheckActionStore, ActionCategoryStoreDatas) == 0x000000, "Member 'FLLazyCheckActionStore::ActionCategoryStoreDatas' has a wrong offset!");
static_assert(offsetof(FLLazyCheckActionStore, ActionCategoryResetDatas) == 0x000050, "Member 'FLLazyCheckActionStore::ActionCategoryResetDatas' has a wrong offset!");

// ScriptStruct ProjectP.LRotationAccordingToMovement
// 0x0050 (0x0050 - 0x0000)
struct FLRotationAccordingToMovement final
{
public:
	bool                                          bUseV2;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         V2_Yaw_Stop;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V2_Yaw_Move;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V2_Yaw_Speed;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V2_Pitch_Stop;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V2_Pitch_Move;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V2_Pitch_Speed;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x8];                                       // 0x001C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bActivated;                                        // 0x0024(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnable;                                           // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebug;                                            // 0x0026(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationAmount;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMovementVelocity;                              // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngleScaleOnFrontMove;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleScaleOnCenterMove;                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleScaleOnBackMove;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRotationSleep;                                 // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCachedCameraFixed;                                // 0x003D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CachedCameraLocation;                              // 0x0040(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationSleepTime;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLRotationAccordingToMovement) == 0x000004, "Wrong alignment on FLRotationAccordingToMovement");
static_assert(sizeof(FLRotationAccordingToMovement) == 0x000050, "Wrong size on FLRotationAccordingToMovement");
static_assert(offsetof(FLRotationAccordingToMovement, bUseV2) == 0x000000, "Member 'FLRotationAccordingToMovement::bUseV2' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, V2_Yaw_Stop) == 0x000004, "Member 'FLRotationAccordingToMovement::V2_Yaw_Stop' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, V2_Yaw_Move) == 0x000008, "Member 'FLRotationAccordingToMovement::V2_Yaw_Move' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, V2_Yaw_Speed) == 0x00000C, "Member 'FLRotationAccordingToMovement::V2_Yaw_Speed' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, V2_Pitch_Stop) == 0x000010, "Member 'FLRotationAccordingToMovement::V2_Pitch_Stop' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, V2_Pitch_Move) == 0x000014, "Member 'FLRotationAccordingToMovement::V2_Pitch_Move' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, V2_Pitch_Speed) == 0x000018, "Member 'FLRotationAccordingToMovement::V2_Pitch_Speed' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, bActivated) == 0x000024, "Member 'FLRotationAccordingToMovement::bActivated' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, bEnable) == 0x000025, "Member 'FLRotationAccordingToMovement::bEnable' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, bDebug) == 0x000026, "Member 'FLRotationAccordingToMovement::bDebug' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, RotationAmount) == 0x000028, "Member 'FLRotationAccordingToMovement::RotationAmount' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, bUseMovementVelocity) == 0x00002C, "Member 'FLRotationAccordingToMovement::bUseMovementVelocity' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, AngleScaleOnFrontMove) == 0x000030, "Member 'FLRotationAccordingToMovement::AngleScaleOnFrontMove' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, AngleScaleOnCenterMove) == 0x000034, "Member 'FLRotationAccordingToMovement::AngleScaleOnCenterMove' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, AngleScaleOnBackMove) == 0x000038, "Member 'FLRotationAccordingToMovement::AngleScaleOnBackMove' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, bUseRotationSleep) == 0x00003C, "Member 'FLRotationAccordingToMovement::bUseRotationSleep' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, bCachedCameraFixed) == 0x00003D, "Member 'FLRotationAccordingToMovement::bCachedCameraFixed' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, CachedCameraLocation) == 0x000040, "Member 'FLRotationAccordingToMovement::CachedCameraLocation' has a wrong offset!");
static_assert(offsetof(FLRotationAccordingToMovement, RotationSleepTime) == 0x00004C, "Member 'FLRotationAccordingToMovement::RotationSleepTime' has a wrong offset!");

// ScriptStruct ProjectP.LCameraShakeTable
// 0x0008 (0x0008 - 0x0000)
struct FLCameraShakeTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLCameraShakeTable) == 0x000008, "Wrong alignment on FLCameraShakeTable");
static_assert(sizeof(FLCameraShakeTable) == 0x000008, "Wrong size on FLCameraShakeTable");
static_assert(offsetof(FLCameraShakeTable, Table) == 0x000000, "Member 'FLCameraShakeTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LHitFXPlayData
// 0x0080 (0x0080 - 0x0000)
struct FLHitFXPlayData final
{
public:
	class AActor*                                 Attacker;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Victim;                                            // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALWeapon>                AttackerWeapon;                                    // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULPartsComponent>        PartsComp;                                         // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Attacker_Material;                                 // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Victim_Material;                                   // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVictimDead;                                      // 0x002A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPhysicalDamage;                                 // 0x002B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFxHitGuardType                              GuardType;                                         // 0x002C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCritical;                                         // 0x002D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParalyzation;                                     // 0x002E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponBreak;                                      // 0x002F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGuardBreak;                                       // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0040(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELBloodEffectType                             BloodType;                                         // 0x0070(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttackerStiffenDurationTime;                       // 0x0074(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFuryAttack;                                       // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCounter;                                          // 0x0079(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLHitFXPlayData) == 0x000010, "Wrong alignment on FLHitFXPlayData");
static_assert(sizeof(FLHitFXPlayData) == 0x000080, "Wrong size on FLHitFXPlayData");
static_assert(offsetof(FLHitFXPlayData, Attacker) == 0x000000, "Member 'FLHitFXPlayData::Attacker' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, Victim) == 0x000008, "Member 'FLHitFXPlayData::Victim' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, AttackerWeapon) == 0x000010, "Member 'FLHitFXPlayData::AttackerWeapon' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, PartsComp) == 0x000018, "Member 'FLHitFXPlayData::PartsComp' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, SkillHitCodeName) == 0x000020, "Member 'FLHitFXPlayData::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, Attacker_Material) == 0x000028, "Member 'FLHitFXPlayData::Attacker_Material' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, Victim_Material) == 0x000029, "Member 'FLHitFXPlayData::Victim_Material' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, IsVictimDead) == 0x00002A, "Member 'FLHitFXPlayData::IsVictimDead' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, HasPhysicalDamage) == 0x00002B, "Member 'FLHitFXPlayData::HasPhysicalDamage' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, GuardType) == 0x00002C, "Member 'FLHitFXPlayData::GuardType' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, bCritical) == 0x00002D, "Member 'FLHitFXPlayData::bCritical' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, bParalyzation) == 0x00002E, "Member 'FLHitFXPlayData::bParalyzation' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, bWeaponBreak) == 0x00002F, "Member 'FLHitFXPlayData::bWeaponBreak' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, bGuardBreak) == 0x000030, "Member 'FLHitFXPlayData::bGuardBreak' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, HitTransform) == 0x000040, "Member 'FLHitFXPlayData::HitTransform' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, BloodType) == 0x000070, "Member 'FLHitFXPlayData::BloodType' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, AttackerStiffenDurationTime) == 0x000074, "Member 'FLHitFXPlayData::AttackerStiffenDurationTime' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, bFuryAttack) == 0x000078, "Member 'FLHitFXPlayData::bFuryAttack' has a wrong offset!");
static_assert(offsetof(FLHitFXPlayData, bCounter) == 0x000079, "Member 'FLHitFXPlayData::bCounter' has a wrong offset!");

// ScriptStruct ProjectP.LCameraShakeTableRowType
// 0x0038 (0x0040 - 0x0008)
struct FLCameraShakeTableRowType final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   CameraShake;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCameraShakeTableRowType) == 0x000008, "Wrong alignment on FLCameraShakeTableRowType");
static_assert(sizeof(FLCameraShakeTableRowType) == 0x000040, "Wrong size on FLCameraShakeTableRowType");
static_assert(offsetof(FLCameraShakeTableRowType, CameraShake) == 0x000008, "Member 'FLCameraShakeTableRowType::CameraShake' has a wrong offset!");
static_assert(offsetof(FLCameraShakeTableRowType, InnerRadius) == 0x000030, "Member 'FLCameraShakeTableRowType::InnerRadius' has a wrong offset!");
static_assert(offsetof(FLCameraShakeTableRowType, OuterRadius) == 0x000034, "Member 'FLCameraShakeTableRowType::OuterRadius' has a wrong offset!");
static_assert(offsetof(FLCameraShakeTableRowType, Falloff) == 0x000038, "Member 'FLCameraShakeTableRowType::Falloff' has a wrong offset!");

// ScriptStruct ProjectP.LCarcassBodyOverlapData
// 0x000C (0x000C - 0x0000)
struct FLCarcassBodyOverlapData final
{
public:
	TWeakObjectPtr<class ALCharacter>             Character;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELCarcassBodyObjectOverlapState               State;                                             // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActiveAbnormalState;                               // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCarcassBodyOverlapData) == 0x000004, "Wrong alignment on FLCarcassBodyOverlapData");
static_assert(sizeof(FLCarcassBodyOverlapData) == 0x00000C, "Wrong size on FLCarcassBodyOverlapData");
static_assert(offsetof(FLCarcassBodyOverlapData, Character) == 0x000000, "Member 'FLCarcassBodyOverlapData::Character' has a wrong offset!");
static_assert(offsetof(FLCarcassBodyOverlapData, State) == 0x000008, "Member 'FLCarcassBodyOverlapData::State' has a wrong offset!");
static_assert(offsetof(FLCarcassBodyOverlapData, ActiveAbnormalState) == 0x000009, "Member 'FLCarcassBodyOverlapData::ActiveAbnormalState' has a wrong offset!");

// ScriptStruct ProjectP.LTalkerSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLTalkerSaveData final
{
public:
	TArray<struct FLTalkerData>                   TalkerDataList;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTalkerSaveData) == 0x000008, "Wrong alignment on FLTalkerSaveData");
static_assert(sizeof(FLTalkerSaveData) == 0x000010, "Wrong size on FLTalkerSaveData");
static_assert(offsetof(FLTalkerSaveData, TalkerDataList) == 0x000000, "Member 'FLTalkerSaveData::TalkerDataList' has a wrong offset!");

// ScriptStruct ProjectP.LPreloadBox
// 0x0030 (0x0030 - 0x0000)
struct FLPreloadBox final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        HoldingAssets;                                     // 0x0020(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLPreloadBox) == 0x000008, "Wrong alignment on FLPreloadBox");
static_assert(sizeof(FLPreloadBox) == 0x000030, "Wrong size on FLPreloadBox");
static_assert(offsetof(FLPreloadBox, HoldingAssets) == 0x000020, "Member 'FLPreloadBox::HoldingAssets' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterSoundTable
// 0x0058 (0x0058 - 0x0000)
struct FLCharacterSoundTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCharacterSoundTable) == 0x000008, "Wrong alignment on FLCharacterSoundTable");
static_assert(sizeof(FLCharacterSoundTable) == 0x000058, "Wrong size on FLCharacterSoundTable");
static_assert(offsetof(FLCharacterSoundTable, Table) == 0x000000, "Member 'FLCharacterSoundTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterSoundType
// 0x0008 (0x0008 - 0x0000)
struct FLCharacterSoundType final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterSoundType) == 0x000004, "Wrong alignment on FLCharacterSoundType");
static_assert(sizeof(FLCharacterSoundType) == 0x000008, "Wrong size on FLCharacterSoundType");
static_assert(offsetof(FLCharacterSoundType, CodeName) == 0x000000, "Member 'FLCharacterSoundType::CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterSoundTableRow
// 0x0038 (0x0040 - 0x0008)
struct FLCharacterSoundTableRow final : public FTableRowBase
{
public:
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLCharacterSoundType                   CharacterSoundType;                                // 0x0010(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterSoundTableRow) == 0x000008, "Wrong alignment on FLCharacterSoundTableRow");
static_assert(sizeof(FLCharacterSoundTableRow) == 0x000040, "Wrong size on FLCharacterSoundTableRow");
static_assert(offsetof(FLCharacterSoundTableRow, EventName) == 0x000008, "Member 'FLCharacterSoundTableRow::EventName' has a wrong offset!");
static_assert(offsetof(FLCharacterSoundTableRow, CharacterSoundType) == 0x000010, "Member 'FLCharacterSoundTableRow::CharacterSoundType' has a wrong offset!");
static_assert(offsetof(FLCharacterSoundTableRow, Sound) == 0x000018, "Member 'FLCharacterSoundTableRow::Sound' has a wrong offset!");

// ScriptStruct ProjectP.LFxContentParameter_Color
// 0x0008 (0x0008 - 0x0000)
struct FLFxContentParameter_Color final
{
public:
	ELFxParamterContentType                       ValueByContent;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFxContentParameter_Color) == 0x000004, "Wrong alignment on FLFxContentParameter_Color");
static_assert(sizeof(FLFxContentParameter_Color) == 0x000008, "Wrong size on FLFxContentParameter_Color");
static_assert(offsetof(FLFxContentParameter_Color, ValueByContent) == 0x000000, "Member 'FLFxContentParameter_Color::ValueByContent' has a wrong offset!");
static_assert(offsetof(FLFxContentParameter_Color, Value) == 0x000004, "Member 'FLFxContentParameter_Color::Value' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterFxTypeTable
// 0x0008 (0x0008 - 0x0000)
struct FLCharacterFxTypeTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLCharacterFxTypeTable) == 0x000008, "Wrong alignment on FLCharacterFxTypeTable");
static_assert(sizeof(FLCharacterFxTypeTable) == 0x000008, "Wrong size on FLCharacterFxTypeTable");
static_assert(offsetof(FLCharacterFxTypeTable, Table) == 0x000000, "Member 'FLCharacterFxTypeTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LReservedCommand
// 0x0018 (0x0018 - 0x0000)
struct FLReservedCommand final
{
public:
	class FName                                   Command;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Lever;                                             // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventTime;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLReservedCommand) == 0x000004, "Wrong alignment on FLReservedCommand");
static_assert(sizeof(FLReservedCommand) == 0x000018, "Wrong size on FLReservedCommand");
static_assert(offsetof(FLReservedCommand, Command) == 0x000000, "Member 'FLReservedCommand::Command' has a wrong offset!");
static_assert(offsetof(FLReservedCommand, Lever) == 0x000008, "Member 'FLReservedCommand::Lever' has a wrong offset!");
static_assert(offsetof(FLReservedCommand, EventTime) == 0x000014, "Member 'FLReservedCommand::EventTime' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterFxTypeTableRow
// 0x0008 (0x0010 - 0x0008)
struct FLCharacterFxTypeTableRow final : public FTableRowBase
{
public:
	class FName                                   Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterFxTypeTableRow) == 0x000008, "Wrong alignment on FLCharacterFxTypeTableRow");
static_assert(sizeof(FLCharacterFxTypeTableRow) == 0x000010, "Wrong size on FLCharacterFxTypeTableRow");
static_assert(offsetof(FLCharacterFxTypeTableRow, Description) == 0x000008, "Member 'FLCharacterFxTypeTableRow::Description' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterSoundTypeTable
// 0x0008 (0x0008 - 0x0000)
struct FLCharacterSoundTypeTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLCharacterSoundTypeTable) == 0x000008, "Wrong alignment on FLCharacterSoundTypeTable");
static_assert(sizeof(FLCharacterSoundTypeTable) == 0x000008, "Wrong size on FLCharacterSoundTypeTable");
static_assert(offsetof(FLCharacterSoundTypeTable, Table) == 0x000000, "Member 'FLCharacterSoundTypeTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialVaryingColor
// 0x0220 (0x0228 - 0x0008)
struct FLMaterialVaryingColor final : public FLMaterialVaryingValue
{
public:
	class FName                                   ParameterName;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeCurveLinearColor               CurveValue;                                        // 0x0020(0x0208)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMaterialVaryingColor) == 0x000008, "Wrong alignment on FLMaterialVaryingColor");
static_assert(sizeof(FLMaterialVaryingColor) == 0x000228, "Wrong size on FLMaterialVaryingColor");
static_assert(offsetof(FLMaterialVaryingColor, ParameterName) == 0x000008, "Member 'FLMaterialVaryingColor::ParameterName' has a wrong offset!");
static_assert(offsetof(FLMaterialVaryingColor, Value) == 0x000010, "Member 'FLMaterialVaryingColor::Value' has a wrong offset!");
static_assert(offsetof(FLMaterialVaryingColor, CurveValue) == 0x000020, "Member 'FLMaterialVaryingColor::CurveValue' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterSoundTypeTableRow
// 0x0008 (0x0010 - 0x0008)
struct FLCharacterSoundTypeTableRow final : public FTableRowBase
{
public:
	class FName                                   Description;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterSoundTypeTableRow) == 0x000008, "Wrong alignment on FLCharacterSoundTypeTableRow");
static_assert(sizeof(FLCharacterSoundTypeTableRow) == 0x000010, "Wrong size on FLCharacterSoundTypeTableRow");
static_assert(offsetof(FLCharacterSoundTypeTableRow, Description) == 0x000008, "Member 'FLCharacterSoundTypeTableRow::Description' has a wrong offset!");

// ScriptStruct ProjectP.CommandHotKeyMapping
// 0x0038 (0x0038 - 0x0000)
struct FCommandHotKeyMapping final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePC;                                             // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionName;                                        // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShift : 1;                                        // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCtrl : 1;                                         // 0x001C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlt : 1;                                          // 0x001C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCmd : 1;                                          // 0x001C(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0020(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommandHotKeyMapping) == 0x000008, "Wrong alignment on FCommandHotKeyMapping");
static_assert(sizeof(FCommandHotKeyMapping) == 0x000038, "Wrong size on FCommandHotKeyMapping");
static_assert(offsetof(FCommandHotKeyMapping, Command) == 0x000000, "Member 'FCommandHotKeyMapping::Command' has a wrong offset!");
static_assert(offsetof(FCommandHotKeyMapping, UsePC) == 0x000010, "Member 'FCommandHotKeyMapping::UsePC' has a wrong offset!");
static_assert(offsetof(FCommandHotKeyMapping, ActionName) == 0x000014, "Member 'FCommandHotKeyMapping::ActionName' has a wrong offset!");
static_assert(offsetof(FCommandHotKeyMapping, Key) == 0x000020, "Member 'FCommandHotKeyMapping::Key' has a wrong offset!");

// ScriptStruct ProjectP.LFxAttachCommonTable
// 0x0008 (0x0008 - 0x0000)
struct FLFxAttachCommonTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLFxAttachCommonTable) == 0x000008, "Wrong alignment on FLFxAttachCommonTable");
static_assert(sizeof(FLFxAttachCommonTable) == 0x000008, "Wrong size on FLFxAttachCommonTable");
static_assert(offsetof(FLFxAttachCommonTable, Table) == 0x000000, "Member 'FLFxAttachCommonTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LBGMTableRowType
// 0x0070 (0x0078 - 0x0008)
struct FLBGMTableRowType final : public FTableRowBase
{
public:
	class FName                                   SoundName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundCue>               SoundCue;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SoundLocalizeName;                                 // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class FName>                           BossCodeNameList;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PreloadNPCCodeNames;                               // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SoundGameString;                                   // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLBGMTableRowType) == 0x000008, "Wrong alignment on FLBGMTableRowType");
static_assert(sizeof(FLBGMTableRowType) == 0x000078, "Wrong size on FLBGMTableRowType");
static_assert(offsetof(FLBGMTableRowType, SoundName) == 0x000008, "Member 'FLBGMTableRowType::SoundName' has a wrong offset!");
static_assert(offsetof(FLBGMTableRowType, SoundCue) == 0x000010, "Member 'FLBGMTableRowType::SoundCue' has a wrong offset!");
static_assert(offsetof(FLBGMTableRowType, SoundLocalizeName) == 0x000038, "Member 'FLBGMTableRowType::SoundLocalizeName' has a wrong offset!");
static_assert(offsetof(FLBGMTableRowType, BossCodeNameList) == 0x000050, "Member 'FLBGMTableRowType::BossCodeNameList' has a wrong offset!");
static_assert(offsetof(FLBGMTableRowType, PreloadNPCCodeNames) == 0x000060, "Member 'FLBGMTableRowType::PreloadNPCCodeNames' has a wrong offset!");
static_assert(offsetof(FLBGMTableRowType, SoundGameString) == 0x000070, "Member 'FLBGMTableRowType::SoundGameString' has a wrong offset!");

// ScriptStruct ProjectP.LLoadingScreenImageTableRowType
// 0x0028 (0x0030 - 0x0008)
struct FLLoadingScreenImageTableRowType final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture2D>              Loading_Image;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLoadingScreenImageTableRowType) == 0x000008, "Wrong alignment on FLLoadingScreenImageTableRowType");
static_assert(sizeof(FLLoadingScreenImageTableRowType) == 0x000030, "Wrong size on FLLoadingScreenImageTableRowType");
static_assert(offsetof(FLLoadingScreenImageTableRowType, Loading_Image) == 0x000008, "Member 'FLLoadingScreenImageTableRowType::Loading_Image' has a wrong offset!");

// ScriptStruct ProjectP.LInteractionInfo
// 0x0040 (0x0040 - 0x0000)
struct FLInteractionInfo
{
public:
	TWeakObjectPtr<class ULInteractSphereComponent> InteractComp;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractionName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        TargetComponent;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AddLocation;                                       // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfrontAngle;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConfrontAngleProp;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageCodeName;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtSphereRadius;                                // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForOverlapCheck;                                   // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLInteractionInfo) == 0x000008, "Wrong alignment on FLInteractionInfo");
static_assert(sizeof(FLInteractionInfo) == 0x000040, "Wrong size on FLInteractionInfo");
static_assert(offsetof(FLInteractionInfo, InteractComp) == 0x000000, "Member 'FLInteractionInfo::InteractComp' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, InteractionName) == 0x000008, "Member 'FLInteractionInfo::InteractionName' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, TargetComponent) == 0x000010, "Member 'FLInteractionInfo::TargetComponent' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, AddLocation) == 0x000018, "Member 'FLInteractionInfo::AddLocation' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, SphereRadius) == 0x000024, "Member 'FLInteractionInfo::SphereRadius' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, ConfrontAngle) == 0x000028, "Member 'FLInteractionInfo::ConfrontAngle' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, ConfrontAngleProp) == 0x00002C, "Member 'FLInteractionInfo::ConfrontAngleProp' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, MessageCodeName) == 0x000030, "Member 'FLInteractionInfo::MessageCodeName' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, LookAtSphereRadius) == 0x000038, "Member 'FLInteractionInfo::LookAtSphereRadius' has a wrong offset!");
static_assert(offsetof(FLInteractionInfo, ForOverlapCheck) == 0x00003C, "Member 'FLInteractionInfo::ForOverlapCheck' has a wrong offset!");

// ScriptStruct ProjectP.LPropInteractionInfo
// 0x0028 (0x0068 - 0x0040)
struct FLPropInteractionInfo final : public FLInteractionInfo
{
public:
	ELPropInteractType                            InteractType;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ULInteractSphereComponent> ExternalInteractComp;                              // 0x0044(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         InteractStartComp;                                 // 0x004C(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         InteractStartCompInverse;                          // 0x0054(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  InteractActor;                                     // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckInverseConfrontAngleProp;                     // 0x0064(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPropInteractionInfo) == 0x000008, "Wrong alignment on FLPropInteractionInfo");
static_assert(sizeof(FLPropInteractionInfo) == 0x000068, "Wrong size on FLPropInteractionInfo");
static_assert(offsetof(FLPropInteractionInfo, InteractType) == 0x000040, "Member 'FLPropInteractionInfo::InteractType' has a wrong offset!");
static_assert(offsetof(FLPropInteractionInfo, ExternalInteractComp) == 0x000044, "Member 'FLPropInteractionInfo::ExternalInteractComp' has a wrong offset!");
static_assert(offsetof(FLPropInteractionInfo, InteractStartComp) == 0x00004C, "Member 'FLPropInteractionInfo::InteractStartComp' has a wrong offset!");
static_assert(offsetof(FLPropInteractionInfo, InteractStartCompInverse) == 0x000054, "Member 'FLPropInteractionInfo::InteractStartCompInverse' has a wrong offset!");
static_assert(offsetof(FLPropInteractionInfo, InteractActor) == 0x00005C, "Member 'FLPropInteractionInfo::InteractActor' has a wrong offset!");
static_assert(offsetof(FLPropInteractionInfo, CheckInverseConfrontAngleProp) == 0x000064, "Member 'FLPropInteractionInfo::CheckInverseConfrontAngleProp' has a wrong offset!");

// ScriptStruct ProjectP.LDitherFadeBone
// 0x0014 (0x0014 - 0x0000)
struct FLDitherFadeBone final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeStartDistance;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeEndDistance;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDitherFadeBone) == 0x000004, "Wrong alignment on FLDitherFadeBone");
static_assert(sizeof(FLDitherFadeBone) == 0x000014, "Wrong size on FLDitherFadeBone");
static_assert(offsetof(FLDitherFadeBone, BoneName) == 0x000000, "Member 'FLDitherFadeBone::BoneName' has a wrong offset!");
static_assert(offsetof(FLDitherFadeBone, FadeStartDistance) == 0x000008, "Member 'FLDitherFadeBone::FadeStartDistance' has a wrong offset!");
static_assert(offsetof(FLDitherFadeBone, FadeEndDistance) == 0x00000C, "Member 'FLDitherFadeBone::FadeEndDistance' has a wrong offset!");
static_assert(offsetof(FLDitherFadeBone, Power) == 0x000010, "Member 'FLDitherFadeBone::Power' has a wrong offset!");

// ScriptStruct ProjectP.LDitherFadeTableRowType
// 0x0020 (0x0028 - 0x0008)
struct FLDitherFadeTableRowType final : public FTableRowBase
{
public:
	bool                                          Enable;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAlpha;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereMask;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLDitherFadeBone>               Bones;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDitherFadeTableRowType) == 0x000008, "Wrong alignment on FLDitherFadeTableRowType");
static_assert(sizeof(FLDitherFadeTableRowType) == 0x000028, "Wrong size on FLDitherFadeTableRowType");
static_assert(offsetof(FLDitherFadeTableRowType, Enable) == 0x000008, "Member 'FLDitherFadeTableRowType::Enable' has a wrong offset!");
static_assert(offsetof(FLDitherFadeTableRowType, MinAlpha) == 0x00000C, "Member 'FLDitherFadeTableRowType::MinAlpha' has a wrong offset!");
static_assert(offsetof(FLDitherFadeTableRowType, SphereMask) == 0x000010, "Member 'FLDitherFadeTableRowType::SphereMask' has a wrong offset!");
static_assert(offsetof(FLDitherFadeTableRowType, Bones) == 0x000018, "Member 'FLDitherFadeTableRowType::Bones' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialVaryingTableRowType
// 0x0028 (0x0030 - 0x0008)
struct FLMaterialVaryingTableRowType final : public FTableRowBase
{
public:
	TSoftObjectPtr<class ULMaterialVarying>       Varying;                                           // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMaterialVaryingTableRowType) == 0x000008, "Wrong alignment on FLMaterialVaryingTableRowType");
static_assert(sizeof(FLMaterialVaryingTableRowType) == 0x000030, "Wrong size on FLMaterialVaryingTableRowType");
static_assert(offsetof(FLMaterialVaryingTableRowType, Varying) == 0x000008, "Member 'FLMaterialVaryingTableRowType::Varying' has a wrong offset!");

// ScriptStruct ProjectP.LLoadingScreenTableRowType
// 0x0030 (0x0038 - 0x0008)
struct FLLoadingScreenTableRowType final : public FTableRowBase
{
public:
	class FName                                   PickConditionQuestChk;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture2D>>      LoadingImages;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         TipSelectCount;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LoadingTipGameStringCodeNames;                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLoadingScreenTableRowType) == 0x000008, "Wrong alignment on FLLoadingScreenTableRowType");
static_assert(sizeof(FLLoadingScreenTableRowType) == 0x000038, "Wrong size on FLLoadingScreenTableRowType");
static_assert(offsetof(FLLoadingScreenTableRowType, PickConditionQuestChk) == 0x000008, "Member 'FLLoadingScreenTableRowType::PickConditionQuestChk' has a wrong offset!");
static_assert(offsetof(FLLoadingScreenTableRowType, LoadingImages) == 0x000010, "Member 'FLLoadingScreenTableRowType::LoadingImages' has a wrong offset!");
static_assert(offsetof(FLLoadingScreenTableRowType, TipSelectCount) == 0x000020, "Member 'FLLoadingScreenTableRowType::TipSelectCount' has a wrong offset!");
static_assert(offsetof(FLLoadingScreenTableRowType, LoadingTipGameStringCodeNames) == 0x000028, "Member 'FLLoadingScreenTableRowType::LoadingTipGameStringCodeNames' has a wrong offset!");

// ScriptStruct ProjectP.LAnimRootMotionTranslationScaleContext
// 0x0028 (0x0028 - 0x0000)
struct FLAnimRootMotionTranslationScaleContext final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Invalidated;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAnimRootMotionScaleOperationType            OperationType;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale_Velocity_Vertical;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale_Velocity_Horizontal;                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvalidateWhenInstigatorIsInvalid;                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 Instigator;                                        // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAnimRootMotionTranslationScaleContext) == 0x000004, "Wrong alignment on FLAnimRootMotionTranslationScaleContext");
static_assert(sizeof(FLAnimRootMotionTranslationScaleContext) == 0x000028, "Wrong size on FLAnimRootMotionTranslationScaleContext");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, Handle) == 0x000000, "Member 'FLAnimRootMotionTranslationScaleContext::Handle' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, Invalidated) == 0x000004, "Member 'FLAnimRootMotionTranslationScaleContext::Invalidated' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, OperationType) == 0x000005, "Member 'FLAnimRootMotionTranslationScaleContext::OperationType' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, Scale) == 0x000008, "Member 'FLAnimRootMotionTranslationScaleContext::Scale' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, Scale_Velocity_Vertical) == 0x00000C, "Member 'FLAnimRootMotionTranslationScaleContext::Scale_Velocity_Vertical' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, Scale_Velocity_Horizontal) == 0x000010, "Member 'FLAnimRootMotionTranslationScaleContext::Scale_Velocity_Horizontal' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, Duration) == 0x000014, "Member 'FLAnimRootMotionTranslationScaleContext::Duration' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, InvalidateWhenInstigatorIsInvalid) == 0x000018, "Member 'FLAnimRootMotionTranslationScaleContext::InvalidateWhenInstigatorIsInvalid' has a wrong offset!");
static_assert(offsetof(FLAnimRootMotionTranslationScaleContext, Instigator) == 0x00001C, "Member 'FLAnimRootMotionTranslationScaleContext::Instigator' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponAssetTable
// 0x0008 (0x0008 - 0x0000)
struct FLWeaponAssetTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLWeaponAssetTable) == 0x000008, "Wrong alignment on FLWeaponAssetTable");
static_assert(sizeof(FLWeaponAssetTable) == 0x000008, "Wrong size on FLWeaponAssetTable");
static_assert(offsetof(FLWeaponAssetTable, Table) == 0x000000, "Member 'FLWeaponAssetTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponAssetTableRowType
// 0x0028 (0x0030 - 0x0008)
struct FLWeaponAssetTableRowType final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   Weapon_Blueprint;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWeaponAssetTableRowType) == 0x000008, "Wrong alignment on FLWeaponAssetTableRowType");
static_assert(sizeof(FLWeaponAssetTableRowType) == 0x000030, "Wrong size on FLWeaponAssetTableRowType");
static_assert(offsetof(FLWeaponAssetTableRowType, Weapon_Blueprint) == 0x000008, "Member 'FLWeaponAssetTableRowType::Weapon_Blueprint' has a wrong offset!");

// ScriptStruct ProjectP.LCalcBuildupData
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FLCalcBuildupData final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCalcBuildupData) == 0x000004, "Wrong alignment on FLCalcBuildupData");
static_assert(sizeof(FLCalcBuildupData) == 0x00001C, "Wrong size on FLCalcBuildupData");

// ScriptStruct ProjectP.LDamagePerTime
// 0x0014 (0x0014 - 0x0000)
struct FLDamagePerTime final
{
public:
	TWeakObjectPtr<class ALCharacter>             TargetCharacter;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainTime;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainDamage;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalApplyDamage;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDamagePerTime) == 0x000004, "Wrong alignment on FLDamagePerTime");
static_assert(sizeof(FLDamagePerTime) == 0x000014, "Wrong size on FLDamagePerTime");
static_assert(offsetof(FLDamagePerTime, TargetCharacter) == 0x000000, "Member 'FLDamagePerTime::TargetCharacter' has a wrong offset!");
static_assert(offsetof(FLDamagePerTime, RemainTime) == 0x000008, "Member 'FLDamagePerTime::RemainTime' has a wrong offset!");
static_assert(offsetof(FLDamagePerTime, RemainDamage) == 0x00000C, "Member 'FLDamagePerTime::RemainDamage' has a wrong offset!");
static_assert(offsetof(FLDamagePerTime, TotalApplyDamage) == 0x000010, "Member 'FLDamagePerTime::TotalApplyDamage' has a wrong offset!");

// ScriptStruct ProjectP.LCodeNameList
// 0x0010 (0x0010 - 0x0000)
struct FLCodeNameList final
{
public:
	TArray<class FName>                           CodeNames;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCodeNameList) == 0x000008, "Wrong alignment on FLCodeNameList");
static_assert(sizeof(FLCodeNameList) == 0x000010, "Wrong size on FLCodeNameList");
static_assert(offsetof(FLCodeNameList, CodeNames) == 0x000000, "Member 'FLCodeNameList::CodeNames' has a wrong offset!");

// ScriptStruct ProjectP.LPreloadProjectileChildSpawnCodeNameData
// 0x0050 (0x0050 - 0x0000)
struct FLPreloadProjectileChildSpawnCodeNameData final
{
public:
	TMap<class FName, struct FLCodeNameList>      ChildMap;                                          // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPreloadProjectileChildSpawnCodeNameData) == 0x000008, "Wrong alignment on FLPreloadProjectileChildSpawnCodeNameData");
static_assert(sizeof(FLPreloadProjectileChildSpawnCodeNameData) == 0x000050, "Wrong size on FLPreloadProjectileChildSpawnCodeNameData");
static_assert(offsetof(FLPreloadProjectileChildSpawnCodeNameData, ChildMap) == 0x000000, "Member 'FLPreloadProjectileChildSpawnCodeNameData::ChildMap' has a wrong offset!");

// ScriptStruct ProjectP.LAcquiredItemInfo
// 0x000C (0x000C - 0x0000)
struct FLAcquiredItemInfo final
{
public:
	class FName                                   ItemTableID;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAcquiredItemInfo) == 0x000004, "Wrong alignment on FLAcquiredItemInfo");
static_assert(sizeof(FLAcquiredItemInfo) == 0x00000C, "Wrong size on FLAcquiredItemInfo");
static_assert(offsetof(FLAcquiredItemInfo, ItemTableID) == 0x000000, "Member 'FLAcquiredItemInfo::ItemTableID' has a wrong offset!");
static_assert(offsetof(FLAcquiredItemInfo, ItemCount) == 0x000008, "Member 'FLAcquiredItemInfo::ItemCount' has a wrong offset!");

// ScriptStruct ProjectP.LDropItemData
// 0x0060 (0x0060 - 0x0000)
struct FLDropItemData final
{
public:
	bool                                          SaveFlag;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPackageOfferMethodType                       PackageOfferMethod;                                // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceAcquisition;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AcquisitionDelayMs;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DropLocation;                                      // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DropOffset;                                        // 0x0014(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NpcSpotDieProcess;                                 // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  DropActor;                                         // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpotUniqueID;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropCodeName;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemPackageCodeName;                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLAcquiredItemInfo>             AcquiredItemInfoList;                              // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDropItemData) == 0x000008, "Wrong alignment on FLDropItemData");
static_assert(sizeof(FLDropItemData) == 0x000060, "Wrong size on FLDropItemData");
static_assert(offsetof(FLDropItemData, SaveFlag) == 0x000000, "Member 'FLDropItemData::SaveFlag' has a wrong offset!");
static_assert(offsetof(FLDropItemData, PackageOfferMethod) == 0x000001, "Member 'FLDropItemData::PackageOfferMethod' has a wrong offset!");
static_assert(offsetof(FLDropItemData, ForceAcquisition) == 0x000002, "Member 'FLDropItemData::ForceAcquisition' has a wrong offset!");
static_assert(offsetof(FLDropItemData, AcquisitionDelayMs) == 0x000004, "Member 'FLDropItemData::AcquisitionDelayMs' has a wrong offset!");
static_assert(offsetof(FLDropItemData, DropLocation) == 0x000008, "Member 'FLDropItemData::DropLocation' has a wrong offset!");
static_assert(offsetof(FLDropItemData, DropOffset) == 0x000014, "Member 'FLDropItemData::DropOffset' has a wrong offset!");
static_assert(offsetof(FLDropItemData, NpcSpotDieProcess) == 0x000020, "Member 'FLDropItemData::NpcSpotDieProcess' has a wrong offset!");
static_assert(offsetof(FLDropItemData, DropActor) == 0x000024, "Member 'FLDropItemData::DropActor' has a wrong offset!");
static_assert(offsetof(FLDropItemData, SpotUniqueID) == 0x000030, "Member 'FLDropItemData::SpotUniqueID' has a wrong offset!");
static_assert(offsetof(FLDropItemData, PropCodeName) == 0x000040, "Member 'FLDropItemData::PropCodeName' has a wrong offset!");
static_assert(offsetof(FLDropItemData, ItemPackageCodeName) == 0x000048, "Member 'FLDropItemData::ItemPackageCodeName' has a wrong offset!");
static_assert(offsetof(FLDropItemData, AcquiredItemInfoList) == 0x000050, "Member 'FLDropItemData::AcquiredItemInfoList' has a wrong offset!");

// ScriptStruct ProjectP.LPreloadNPCData
// 0x0058 (0x0058 - 0x0000)
struct FLPreloadNPCData final
{
public:
	class FName                                   NPCCodeName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  PartsPaths;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPreloadNPCData) == 0x000008, "Wrong alignment on FLPreloadNPCData");
static_assert(sizeof(FLPreloadNPCData) == 0x000058, "Wrong size on FLPreloadNPCData");
static_assert(offsetof(FLPreloadNPCData, NPCCodeName) == 0x000000, "Member 'FLPreloadNPCData::NPCCodeName' has a wrong offset!");
static_assert(offsetof(FLPreloadNPCData, PartsPaths) == 0x000008, "Member 'FLPreloadNPCData::PartsPaths' has a wrong offset!");

// ScriptStruct ProjectP.LDoorSpotData
// 0x0000 (0x0038 - 0x0038)
struct FLDoorSpotData final : public FLPropSpotData
{
};
static_assert(alignof(FLDoorSpotData) == 0x000008, "Wrong alignment on FLDoorSpotData");
static_assert(sizeof(FLDoorSpotData) == 0x000038, "Wrong size on FLDoorSpotData");

// ScriptStruct ProjectP.LPreloadActionGroupData
// 0x0078 (0x0078 - 0x0000)
struct FLPreloadActionGroupData final
{
public:
	class FName                                   ActionGroupCodeName;                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                AnimMontagePaths;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLActionGroupMontageValidMap> AnimMontageValidateMap;                            // 0x0018(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                ProjectilePaths;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPreloadActionGroupData) == 0x000008, "Wrong alignment on FLPreloadActionGroupData");
static_assert(sizeof(FLPreloadActionGroupData) == 0x000078, "Wrong size on FLPreloadActionGroupData");
static_assert(offsetof(FLPreloadActionGroupData, ActionGroupCodeName) == 0x000000, "Member 'FLPreloadActionGroupData::ActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(FLPreloadActionGroupData, AnimMontagePaths) == 0x000008, "Member 'FLPreloadActionGroupData::AnimMontagePaths' has a wrong offset!");
static_assert(offsetof(FLPreloadActionGroupData, AnimMontageValidateMap) == 0x000018, "Member 'FLPreloadActionGroupData::AnimMontageValidateMap' has a wrong offset!");
static_assert(offsetof(FLPreloadActionGroupData, ProjectilePaths) == 0x000068, "Member 'FLPreloadActionGroupData::ProjectilePaths' has a wrong offset!");

// ScriptStruct ProjectP.LDeadExplosionTable
// 0x0008 (0x0008 - 0x0000)
struct FLDeadExplosionTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLDeadExplosionTable) == 0x000008, "Wrong alignment on FLDeadExplosionTable");
static_assert(sizeof(FLDeadExplosionTable) == 0x000008, "Wrong size on FLDeadExplosionTable");
static_assert(offsetof(FLDeadExplosionTable, Table) == 0x000000, "Member 'FLDeadExplosionTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LTeleportLocation
// 0x0020 (0x0020 - 0x0000)
struct FLTeleportLocation final
{
public:
	class FName                                   TorsionCoilName;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseEnable;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConditionBlock;                                    // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UObject>>         IconList;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTeleportLocation) == 0x000008, "Wrong alignment on FLTeleportLocation");
static_assert(sizeof(FLTeleportLocation) == 0x000020, "Wrong size on FLTeleportLocation");
static_assert(offsetof(FLTeleportLocation, TorsionCoilName) == 0x000000, "Member 'FLTeleportLocation::TorsionCoilName' has a wrong offset!");
static_assert(offsetof(FLTeleportLocation, UseEnable) == 0x000008, "Member 'FLTeleportLocation::UseEnable' has a wrong offset!");
static_assert(offsetof(FLTeleportLocation, ConditionBlock) == 0x000009, "Member 'FLTeleportLocation::ConditionBlock' has a wrong offset!");
static_assert(offsetof(FLTeleportLocation, IconList) == 0x000010, "Member 'FLTeleportLocation::IconList' has a wrong offset!");

// ScriptStruct ProjectP.LTeleportLocationChapter
// 0x0018 (0x0018 - 0x0000)
struct FLTeleportLocationChapter final
{
public:
	int32                                         ChapterId;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLTeleportLocation>             TeleportLocationList;                              // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTeleportLocationChapter) == 0x000008, "Wrong alignment on FLTeleportLocationChapter");
static_assert(sizeof(FLTeleportLocationChapter) == 0x000018, "Wrong size on FLTeleportLocationChapter");
static_assert(offsetof(FLTeleportLocationChapter, ChapterId) == 0x000000, "Member 'FLTeleportLocationChapter::ChapterId' has a wrong offset!");
static_assert(offsetof(FLTeleportLocationChapter, TeleportLocationList) == 0x000008, "Member 'FLTeleportLocationChapter::TeleportLocationList' has a wrong offset!");

// ScriptStruct ProjectP.LExplosionMeshInfoOverride
// 0x0080 (0x0080 - 0x0000)
struct FLExplosionMeshInfoOverride final
{
public:
	ELExplosionMeshType                           ExplosionMeshType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          PhysicsAsset_Override;                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           FxSocketNameArray;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MeshHideTime_CarcassOnly;                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalKillPower_ToUp;                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalKillPower_RootToCut;                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillPowerWeight;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillPowerWeightForSphere;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxCutRadius;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxCutSpawnT;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FxCutOffset;                                       // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetachBoneName;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideBoneName;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectTableCodeName_Override;                      // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundTableCodeName_Override;                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillPowerSphereSocketName;                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                KillPowerSphereOffset;                             // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CarcassHybridPuppet;                               // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLExplosionMeshInfoOverride) == 0x000008, "Wrong alignment on FLExplosionMeshInfoOverride");
static_assert(sizeof(FLExplosionMeshInfoOverride) == 0x000080, "Wrong size on FLExplosionMeshInfoOverride");
static_assert(offsetof(FLExplosionMeshInfoOverride, ExplosionMeshType) == 0x000000, "Member 'FLExplosionMeshInfoOverride::ExplosionMeshType' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, PhysicsAsset_Override) == 0x000008, "Member 'FLExplosionMeshInfoOverride::PhysicsAsset_Override' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, FxSocketNameArray) == 0x000010, "Member 'FLExplosionMeshInfoOverride::FxSocketNameArray' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, MeshHideTime_CarcassOnly) == 0x000020, "Member 'FLExplosionMeshInfoOverride::MeshHideTime_CarcassOnly' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, AdditionalKillPower_ToUp) == 0x000024, "Member 'FLExplosionMeshInfoOverride::AdditionalKillPower_ToUp' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, AdditionalKillPower_RootToCut) == 0x000028, "Member 'FLExplosionMeshInfoOverride::AdditionalKillPower_RootToCut' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, KillPowerWeight) == 0x00002C, "Member 'FLExplosionMeshInfoOverride::KillPowerWeight' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, KillPowerWeightForSphere) == 0x000030, "Member 'FLExplosionMeshInfoOverride::KillPowerWeightForSphere' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, FxCutRadius) == 0x000034, "Member 'FLExplosionMeshInfoOverride::FxCutRadius' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, FxCutSpawnT) == 0x000038, "Member 'FLExplosionMeshInfoOverride::FxCutSpawnT' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, FxCutOffset) == 0x00003C, "Member 'FLExplosionMeshInfoOverride::FxCutOffset' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, DetachBoneName) == 0x000048, "Member 'FLExplosionMeshInfoOverride::DetachBoneName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, HideBoneName) == 0x000050, "Member 'FLExplosionMeshInfoOverride::HideBoneName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, EffectTableCodeName_Override) == 0x000058, "Member 'FLExplosionMeshInfoOverride::EffectTableCodeName_Override' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, SoundTableCodeName_Override) == 0x000060, "Member 'FLExplosionMeshInfoOverride::SoundTableCodeName_Override' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, KillPowerSphereSocketName) == 0x000068, "Member 'FLExplosionMeshInfoOverride::KillPowerSphereSocketName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, KillPowerSphereOffset) == 0x000070, "Member 'FLExplosionMeshInfoOverride::KillPowerSphereOffset' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfoOverride, CarcassHybridPuppet) == 0x00007C, "Member 'FLExplosionMeshInfoOverride::CarcassHybridPuppet' has a wrong offset!");

// ScriptStruct ProjectP.LDeadExplosionTableRowType
// 0x0010 (0x0018 - 0x0008)
struct FLDeadExplosionTableRowType final : public FTableRowBase
{
public:
	TArray<struct FLExplosionMeshInfoOverride>    ExplosionMeshInfoArray;                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDeadExplosionTableRowType) == 0x000008, "Wrong alignment on FLDeadExplosionTableRowType");
static_assert(sizeof(FLDeadExplosionTableRowType) == 0x000018, "Wrong size on FLDeadExplosionTableRowType");
static_assert(offsetof(FLDeadExplosionTableRowType, ExplosionMeshInfoArray) == 0x000008, "Member 'FLDeadExplosionTableRowType::ExplosionMeshInfoArray' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialParamCollection
// 0x0030 (0x0030 - 0x0000)
struct FLMaterialParamCollection final
{
public:
	TArray<struct FLMaterialParamScalar>          ScalarParams;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLMaterialParamVector>          VectorParams;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           MaterialSlotNames;                                 // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMaterialParamCollection) == 0x000008, "Wrong alignment on FLMaterialParamCollection");
static_assert(sizeof(FLMaterialParamCollection) == 0x000030, "Wrong size on FLMaterialParamCollection");
static_assert(offsetof(FLMaterialParamCollection, ScalarParams) == 0x000000, "Member 'FLMaterialParamCollection::ScalarParams' has a wrong offset!");
static_assert(offsetof(FLMaterialParamCollection, VectorParams) == 0x000010, "Member 'FLMaterialParamCollection::VectorParams' has a wrong offset!");
static_assert(offsetof(FLMaterialParamCollection, MaterialSlotNames) == 0x000020, "Member 'FLMaterialParamCollection::MaterialSlotNames' has a wrong offset!");

// ScriptStruct ProjectP.LPartsAnimStateType
// 0x0008 (0x0008 - 0x0000)
struct FLPartsAnimStateType final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPartsAnimStateType) == 0x000004, "Wrong alignment on FLPartsAnimStateType");
static_assert(sizeof(FLPartsAnimStateType) == 0x000008, "Wrong size on FLPartsAnimStateType");
static_assert(offsetof(FLPartsAnimStateType, CodeName) == 0x000000, "Member 'FLPartsAnimStateType::CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponAnimStateType
// 0x0008 (0x0008 - 0x0000)
struct FLWeaponAnimStateType final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWeaponAnimStateType) == 0x000004, "Wrong alignment on FLWeaponAnimStateType");
static_assert(sizeof(FLWeaponAnimStateType) == 0x000008, "Wrong size on FLWeaponAnimStateType");
static_assert(offsetof(FLWeaponAnimStateType, CodeName) == 0x000000, "Member 'FLWeaponAnimStateType::CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LAbnormalCodeNameType
// 0x0008 (0x0008 - 0x0000)
struct FLAbnormalCodeNameType final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAbnormalCodeNameType) == 0x000004, "Wrong alignment on FLAbnormalCodeNameType");
static_assert(sizeof(FLAbnormalCodeNameType) == 0x000008, "Wrong size on FLAbnormalCodeNameType");
static_assert(offsetof(FLAbnormalCodeNameType, CodeName) == 0x000000, "Member 'FLAbnormalCodeNameType::CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LShapeObjectSpotData
// 0x0010 (0x0048 - 0x0038)
struct FLShapeObjectSpotData final : public FLPropSpotData
{
public:
	class FName                                   ShapeObjectCodeName;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetState;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLShapeObjectSpotData) == 0x000008, "Wrong alignment on FLShapeObjectSpotData");
static_assert(sizeof(FLShapeObjectSpotData) == 0x000048, "Wrong size on FLShapeObjectSpotData");
static_assert(offsetof(FLShapeObjectSpotData, ShapeObjectCodeName) == 0x000038, "Member 'FLShapeObjectSpotData::ShapeObjectCodeName' has a wrong offset!");
static_assert(offsetof(FLShapeObjectSpotData, ResetState) == 0x000040, "Member 'FLShapeObjectSpotData::ResetState' has a wrong offset!");

// ScriptStruct ProjectP.LBladeTrailType
// 0x0008 (0x0008 - 0x0000)
struct FLBladeTrailType final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLBladeTrailType) == 0x000004, "Wrong alignment on FLBladeTrailType");
static_assert(sizeof(FLBladeTrailType) == 0x000008, "Wrong size on FLBladeTrailType");
static_assert(offsetof(FLBladeTrailType, CodeName) == 0x000000, "Member 'FLBladeTrailType::CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterFxType
// 0x0008 (0x0008 - 0x0000)
struct FLCharacterFxType final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterFxType) == 0x000004, "Wrong alignment on FLCharacterFxType");
static_assert(sizeof(FLCharacterFxType) == 0x000008, "Wrong size on FLCharacterFxType");
static_assert(offsetof(FLCharacterFxType, CodeName) == 0x000000, "Member 'FLCharacterFxType::CodeName' has a wrong offset!");

// ScriptStruct ProjectP.LBossRoomSpotData
// 0x0018 (0x0050 - 0x0038)
struct FLBossRoomSpotData final : public FLPropSpotData
{
public:
	bool                                          BossIsDead;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckDefaultStatus;                                // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BossRoomActiveState;                               // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DefaultActorSpawnableList;                         // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLBossRoomSpotData) == 0x000008, "Wrong alignment on FLBossRoomSpotData");
static_assert(sizeof(FLBossRoomSpotData) == 0x000050, "Wrong size on FLBossRoomSpotData");
static_assert(offsetof(FLBossRoomSpotData, BossIsDead) == 0x000038, "Member 'FLBossRoomSpotData::BossIsDead' has a wrong offset!");
static_assert(offsetof(FLBossRoomSpotData, CheckDefaultStatus) == 0x000039, "Member 'FLBossRoomSpotData::CheckDefaultStatus' has a wrong offset!");
static_assert(offsetof(FLBossRoomSpotData, BossRoomActiveState) == 0x00003A, "Member 'FLBossRoomSpotData::BossRoomActiveState' has a wrong offset!");
static_assert(offsetof(FLBossRoomSpotData, DefaultActorSpawnableList) == 0x000040, "Member 'FLBossRoomSpotData::DefaultActorSpawnableList' has a wrong offset!");

// ScriptStruct ProjectP.LEasingData
// 0x000C (0x000C - 0x0000)
struct FLEasingData final
{
public:
	ELEasingType                                  EasingType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLEasingData) == 0x000004, "Wrong alignment on FLEasingData");
static_assert(sizeof(FLEasingData) == 0x00000C, "Wrong size on FLEasingData");
static_assert(offsetof(FLEasingData, EasingType) == 0x000000, "Member 'FLEasingData::EasingType' has a wrong offset!");
static_assert(offsetof(FLEasingData, BlendExp) == 0x000004, "Member 'FLEasingData::BlendExp' has a wrong offset!");
static_assert(offsetof(FLEasingData, Steps) == 0x000008, "Member 'FLEasingData::Steps' has a wrong offset!");

// ScriptStruct ProjectP.LGameCommandBookEntity
// 0x0050 (0x0050 - 0x0000)
struct FLGameCommandBookEntity final
{
public:
	class FString                                 CommandName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CategoryName;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         CommandLines;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInputChord                            HotKey;                                            // 0x0030(0x0020)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGameCommandBookEntity) == 0x000008, "Wrong alignment on FLGameCommandBookEntity");
static_assert(sizeof(FLGameCommandBookEntity) == 0x000050, "Wrong size on FLGameCommandBookEntity");
static_assert(offsetof(FLGameCommandBookEntity, CommandName) == 0x000000, "Member 'FLGameCommandBookEntity::CommandName' has a wrong offset!");
static_assert(offsetof(FLGameCommandBookEntity, CategoryName) == 0x000010, "Member 'FLGameCommandBookEntity::CategoryName' has a wrong offset!");
static_assert(offsetof(FLGameCommandBookEntity, CommandLines) == 0x000020, "Member 'FLGameCommandBookEntity::CommandLines' has a wrong offset!");
static_assert(offsetof(FLGameCommandBookEntity, HotKey) == 0x000030, "Member 'FLGameCommandBookEntity::HotKey' has a wrong offset!");

// ScriptStruct ProjectP.LSpotEventData
// 0x0038 (0x0038 - 0x0000)
struct FLSpotEventData final
{
public:
	class FString                                 SpotUniqueID;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActorSpawnable;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PropState;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bTouchedTalker;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TalkerCodeName;                                    // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFactionType                                  Faction;                                           // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReserveActorSpawn;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReserveActorDespawn;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TorsionCoilActivate;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSpotEventData) == 0x000008, "Wrong alignment on FLSpotEventData");
static_assert(sizeof(FLSpotEventData) == 0x000038, "Wrong size on FLSpotEventData");
static_assert(offsetof(FLSpotEventData, SpotUniqueID) == 0x000000, "Member 'FLSpotEventData::SpotUniqueID' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, ActorSpawnable) == 0x000010, "Member 'FLSpotEventData::ActorSpawnable' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, PropState) == 0x000014, "Member 'FLSpotEventData::PropState' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, bTouchedTalker) == 0x000018, "Member 'FLSpotEventData::bTouchedTalker' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, TalkerCodeName) == 0x00001C, "Member 'FLSpotEventData::TalkerCodeName' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, Faction) == 0x000024, "Member 'FLSpotEventData::Faction' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, ReserveActorSpawn) == 0x000028, "Member 'FLSpotEventData::ReserveActorSpawn' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, ReserveActorDespawn) == 0x00002C, "Member 'FLSpotEventData::ReserveActorDespawn' has a wrong offset!");
static_assert(offsetof(FLSpotEventData, TorsionCoilActivate) == 0x000030, "Member 'FLSpotEventData::TorsionCoilActivate' has a wrong offset!");

// ScriptStruct ProjectP.LDialogSoundTableRowType
// 0x0030 (0x0038 - 0x0008)
struct FLDialogSoundTableRowType final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USoundCue>               Source;                                            // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSoundMix;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDialogSoundTableRowType) == 0x000008, "Wrong alignment on FLDialogSoundTableRowType");
static_assert(sizeof(FLDialogSoundTableRowType) == 0x000038, "Wrong size on FLDialogSoundTableRowType");
static_assert(offsetof(FLDialogSoundTableRowType, Source) == 0x000008, "Member 'FLDialogSoundTableRowType::Source' has a wrong offset!");
static_assert(offsetof(FLDialogSoundTableRowType, UseSoundMix) == 0x000030, "Member 'FLDialogSoundTableRowType::UseSoundMix' has a wrong offset!");

// ScriptStruct ProjectP.LDynamicDamageVolume_TargetInfo
// 0x000C (0x000C - 0x0000)
struct FLDynamicDamageVolume_TargetInfo final
{
public:
	TWeakObjectPtr<class ALCharacter>             TargetCharacter;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeElasped;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDynamicDamageVolume_TargetInfo) == 0x000004, "Wrong alignment on FLDynamicDamageVolume_TargetInfo");
static_assert(sizeof(FLDynamicDamageVolume_TargetInfo) == 0x00000C, "Wrong size on FLDynamicDamageVolume_TargetInfo");
static_assert(offsetof(FLDynamicDamageVolume_TargetInfo, TargetCharacter) == 0x000000, "Member 'FLDynamicDamageVolume_TargetInfo::TargetCharacter' has a wrong offset!");
static_assert(offsetof(FLDynamicDamageVolume_TargetInfo, TimeElasped) == 0x000008, "Member 'FLDynamicDamageVolume_TargetInfo::TimeElasped' has a wrong offset!");

// ScriptStruct ProjectP.LWeatherSettings
// 0x0040 (0x0040 - 0x0000)
struct FLWeatherSettings final
{
public:
	uint8                                         bOverride_WetColor : 1;                            // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WetSpecular : 1;                         // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WetRoughness : 1;                        // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_WetAmount : 1;                           // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RainIntensity : 1;                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RainColorIntensity : 1;                  // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RainSprayColorIntensity : 1;             // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RainDropSize : 1;                        // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RainVelocity : 1;                        // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RainWidth : 1;                           // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_RainLength : 1;                          // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Dust : 1;                                // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Rain_Raxasia : 1;                        // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           WetColor;                                          // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WetSpecular;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WetRoughness;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WetAmount;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainIntensity;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainColorIntensity;                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainSprayColorIntensity;                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainDropSize;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainVelocity;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainWidth;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainLength;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Dust;                                              // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Rain_Raxasia;                                      // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWeatherSettings) == 0x000004, "Wrong alignment on FLWeatherSettings");
static_assert(sizeof(FLWeatherSettings) == 0x000040, "Wrong size on FLWeatherSettings");
static_assert(offsetof(FLWeatherSettings, WetColor) == 0x000004, "Member 'FLWeatherSettings::WetColor' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, WetSpecular) == 0x000014, "Member 'FLWeatherSettings::WetSpecular' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, WetRoughness) == 0x000018, "Member 'FLWeatherSettings::WetRoughness' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, WetAmount) == 0x00001C, "Member 'FLWeatherSettings::WetAmount' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, RainIntensity) == 0x000020, "Member 'FLWeatherSettings::RainIntensity' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, RainColorIntensity) == 0x000024, "Member 'FLWeatherSettings::RainColorIntensity' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, RainSprayColorIntensity) == 0x000028, "Member 'FLWeatherSettings::RainSprayColorIntensity' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, RainDropSize) == 0x00002C, "Member 'FLWeatherSettings::RainDropSize' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, RainVelocity) == 0x000030, "Member 'FLWeatherSettings::RainVelocity' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, RainWidth) == 0x000034, "Member 'FLWeatherSettings::RainWidth' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, RainLength) == 0x000038, "Member 'FLWeatherSettings::RainLength' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, Dust) == 0x00003C, "Member 'FLWeatherSettings::Dust' has a wrong offset!");
static_assert(offsetof(FLWeatherSettings, Rain_Raxasia) == 0x00003D, "Member 'FLWeatherSettings::Rain_Raxasia' has a wrong offset!");

// ScriptStruct ProjectP.LSkySphereSettings
// 0x0094 (0x0094 - 0x0000)
struct FLSkySphereSettings final
{
public:
	uint8                                         bOverride_OverallIntensity : 1;                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Contrast : 1;                            // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Saturation : 1;                          // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LitIntensity : 1;                        // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonDiskColor : 1;                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_StarsColor : 1;                          // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonDiskIntensity : 1;                   // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonGlowIntensity : 1;                   // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonPhase : 1;                           // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonDarkSideBrightness : 1;              // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonScale : 1;                           // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_MoonAngle : 1;                           // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_StarsIntensity : 1;                      // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_StarsTiling : 1;                         // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_HorizonBaseColor : 1;                    // 0x0001(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_ZenithBaseColor : 1;                     // 0x0001(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_NightSkyGlowColor : 1;                   // 0x0002(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_OvercastContribution : 1;                // 0x0002(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverallIntensity;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Contrast;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Saturation;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LitIntensity;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MoonDiskColor;                                     // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           StarsColor;                                        // 0x0024(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonDiskIntensity;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonGlowIntensity;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonPhase;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonDarkSideBrightness;                            // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonScale;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoonAngle;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsIntensity;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StarsTiling;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HorizonBaseColor;                                  // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ZenithBaseColor;                                   // 0x0064(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NightSkyGlowColor;                                 // 0x0074(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OvercastContribution;                              // 0x0084(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSkySphereSettings) == 0x000004, "Wrong alignment on FLSkySphereSettings");
static_assert(sizeof(FLSkySphereSettings) == 0x000094, "Wrong size on FLSkySphereSettings");
static_assert(offsetof(FLSkySphereSettings, OverallIntensity) == 0x000004, "Member 'FLSkySphereSettings::OverallIntensity' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, Contrast) == 0x000008, "Member 'FLSkySphereSettings::Contrast' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, Saturation) == 0x00000C, "Member 'FLSkySphereSettings::Saturation' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, LitIntensity) == 0x000010, "Member 'FLSkySphereSettings::LitIntensity' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, MoonDiskColor) == 0x000014, "Member 'FLSkySphereSettings::MoonDiskColor' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, StarsColor) == 0x000024, "Member 'FLSkySphereSettings::StarsColor' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, MoonDiskIntensity) == 0x000034, "Member 'FLSkySphereSettings::MoonDiskIntensity' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, MoonGlowIntensity) == 0x000038, "Member 'FLSkySphereSettings::MoonGlowIntensity' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, MoonPhase) == 0x00003C, "Member 'FLSkySphereSettings::MoonPhase' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, MoonDarkSideBrightness) == 0x000040, "Member 'FLSkySphereSettings::MoonDarkSideBrightness' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, MoonScale) == 0x000044, "Member 'FLSkySphereSettings::MoonScale' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, MoonAngle) == 0x000048, "Member 'FLSkySphereSettings::MoonAngle' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, StarsIntensity) == 0x00004C, "Member 'FLSkySphereSettings::StarsIntensity' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, StarsTiling) == 0x000050, "Member 'FLSkySphereSettings::StarsTiling' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, HorizonBaseColor) == 0x000054, "Member 'FLSkySphereSettings::HorizonBaseColor' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, ZenithBaseColor) == 0x000064, "Member 'FLSkySphereSettings::ZenithBaseColor' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, NightSkyGlowColor) == 0x000074, "Member 'FLSkySphereSettings::NightSkyGlowColor' has a wrong offset!");
static_assert(offsetof(FLSkySphereSettings, OvercastContribution) == 0x000084, "Member 'FLSkySphereSettings::OvercastContribution' has a wrong offset!");

// ScriptStruct ProjectP.LHeightFogSettings
// 0x006C (0x006C - 0x0000)
struct FLHeightFogSettings final
{
public:
	uint8                                         bOverride_FogDensity : 1;                          // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FogHeightFalloff : 1;                    // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FogHeightOffset : 1;                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FogInscatteringColor : 1;                // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_FogMaxOpacity : 1;                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_StartDistance : 1;                       // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionalInscatteringExponent : 1;     // 0x0000(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionalInscatteringStartDistance : 1; // 0x0000(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_DirectionalInscatteringColor : 1;        // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VolumetricFogScatteringDistribution : 1; // 0x0001(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VolumetricFogAlbedo : 1;                 // 0x0001(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VolumetricFogEmissive : 1;               // 0x0001(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VolumetricFogExtinctionScale : 1;        // 0x0001(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_VolumetricFogDistance : 1;               // 0x0001(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FogDensity;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightOffset;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringColor;                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringExponent;                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringStartDistance;              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringColor;                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogScatteringDistribution;               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VolumetricFogAlbedo;                               // 0x0044(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VolumetricFogEmissive;                             // 0x0054(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogExtinctionScale;                      // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogDistance;                             // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLHeightFogSettings) == 0x000004, "Wrong alignment on FLHeightFogSettings");
static_assert(sizeof(FLHeightFogSettings) == 0x00006C, "Wrong size on FLHeightFogSettings");
static_assert(offsetof(FLHeightFogSettings, FogDensity) == 0x000004, "Member 'FLHeightFogSettings::FogDensity' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, FogHeightFalloff) == 0x000008, "Member 'FLHeightFogSettings::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, FogHeightOffset) == 0x00000C, "Member 'FLHeightFogSettings::FogHeightOffset' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, FogInscatteringColor) == 0x000010, "Member 'FLHeightFogSettings::FogInscatteringColor' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, FogMaxOpacity) == 0x000020, "Member 'FLHeightFogSettings::FogMaxOpacity' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, StartDistance) == 0x000024, "Member 'FLHeightFogSettings::StartDistance' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, DirectionalInscatteringExponent) == 0x000028, "Member 'FLHeightFogSettings::DirectionalInscatteringExponent' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, DirectionalInscatteringStartDistance) == 0x00002C, "Member 'FLHeightFogSettings::DirectionalInscatteringStartDistance' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, DirectionalInscatteringColor) == 0x000030, "Member 'FLHeightFogSettings::DirectionalInscatteringColor' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, VolumetricFogScatteringDistribution) == 0x000040, "Member 'FLHeightFogSettings::VolumetricFogScatteringDistribution' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, VolumetricFogAlbedo) == 0x000044, "Member 'FLHeightFogSettings::VolumetricFogAlbedo' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, VolumetricFogEmissive) == 0x000054, "Member 'FLHeightFogSettings::VolumetricFogEmissive' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, VolumetricFogExtinctionScale) == 0x000064, "Member 'FLHeightFogSettings::VolumetricFogExtinctionScale' has a wrong offset!");
static_assert(offsetof(FLHeightFogSettings, VolumetricFogDistance) == 0x000068, "Member 'FLHeightFogSettings::VolumetricFogDistance' has a wrong offset!");

// ScriptStruct ProjectP.LDirectionalLightNoShadowSettings
// 0x002C (0x002C - 0x0000)
struct FLDirectionalLightNoShadowSettings final
{
public:
	uint8                                         bOverride_Rotation : 1;                            // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Intensity : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_LightColor : 1;                          // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_Temperature : 1;                         // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOverride_SpecularScale : 1;                       // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Rotation;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LightColor;                                        // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Temperature;                                       // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecularScale;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDirectionalLightNoShadowSettings) == 0x000004, "Wrong alignment on FLDirectionalLightNoShadowSettings");
static_assert(sizeof(FLDirectionalLightNoShadowSettings) == 0x00002C, "Wrong size on FLDirectionalLightNoShadowSettings");
static_assert(offsetof(FLDirectionalLightNoShadowSettings, Rotation) == 0x000004, "Member 'FLDirectionalLightNoShadowSettings::Rotation' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightNoShadowSettings, Intensity) == 0x000010, "Member 'FLDirectionalLightNoShadowSettings::Intensity' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightNoShadowSettings, LightColor) == 0x000014, "Member 'FLDirectionalLightNoShadowSettings::LightColor' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightNoShadowSettings, Temperature) == 0x000024, "Member 'FLDirectionalLightNoShadowSettings::Temperature' has a wrong offset!");
static_assert(offsetof(FLDirectionalLightNoShadowSettings, SpecularScale) == 0x000028, "Member 'FLDirectionalLightNoShadowSettings::SpecularScale' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponAttachPoint
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FLWeaponAttachPoint final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWeaponAttachPoint) == 0x000004, "Wrong alignment on FLWeaponAttachPoint");
static_assert(sizeof(FLWeaponAttachPoint) == 0x000008, "Wrong size on FLWeaponAttachPoint");

// ScriptStruct ProjectP.LDecoMeshData
// 0x0030 (0x0030 - 0x0000)
struct FLDecoMeshData final
{
public:
	class FName                                   MeshName;                                          // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0008(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        Shape;                                             // 0x0010(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResponseCollision;                                // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropedPhysics;                                    // 0x0021(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropCollisionBlockTime;                            // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bDisappear;                                        // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDecoMeshData) == 0x000008, "Wrong alignment on FLDecoMeshData");
static_assert(sizeof(FLDecoMeshData) == 0x000030, "Wrong size on FLDecoMeshData");
static_assert(offsetof(FLDecoMeshData, MeshName) == 0x000000, "Member 'FLDecoMeshData::MeshName' has a wrong offset!");
static_assert(offsetof(FLDecoMeshData, StaticMesh) == 0x000008, "Member 'FLDecoMeshData::StaticMesh' has a wrong offset!");
static_assert(offsetof(FLDecoMeshData, Shape) == 0x000010, "Member 'FLDecoMeshData::Shape' has a wrong offset!");
static_assert(offsetof(FLDecoMeshData, AttachSocketName) == 0x000018, "Member 'FLDecoMeshData::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FLDecoMeshData, bResponseCollision) == 0x000020, "Member 'FLDecoMeshData::bResponseCollision' has a wrong offset!");
static_assert(offsetof(FLDecoMeshData, bDropedPhysics) == 0x000021, "Member 'FLDecoMeshData::bDropedPhysics' has a wrong offset!");
static_assert(offsetof(FLDecoMeshData, DropCollisionBlockTime) == 0x000024, "Member 'FLDecoMeshData::DropCollisionBlockTime' has a wrong offset!");
static_assert(offsetof(FLDecoMeshData, bDisappear) == 0x000028, "Member 'FLDecoMeshData::bDisappear' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponTransformData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FLWeaponTransformData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWeaponTransformData) == 0x000004, "Wrong alignment on FLWeaponTransformData");
static_assert(sizeof(FLWeaponTransformData) == 0x000010, "Wrong size on FLWeaponTransformData");

// ScriptStruct ProjectP.LWeaponSetupID
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FLWeaponSetupID final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWeaponSetupID) == 0x000004, "Wrong alignment on FLWeaponSetupID");
static_assert(sizeof(FLWeaponSetupID) == 0x000020, "Wrong size on FLWeaponSetupID");

// ScriptStruct ProjectP.LFootStepFxTable
// 0x0008 (0x0008 - 0x0000)
struct FLFootStepFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLFootStepFxTable) == 0x000008, "Wrong alignment on FLFootStepFxTable");
static_assert(sizeof(FLFootStepFxTable) == 0x000008, "Wrong size on FLFootStepFxTable");
static_assert(offsetof(FLFootStepFxTable, Table) == 0x000000, "Member 'FLFootStepFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LFootStepFxRow
// 0x09E0 (0x09E8 - 0x0008)
struct FLFootStepFxRow final : public FTableRowBase
{
public:
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Default;                                           // 0x0010(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Water;                                             // 0x0088(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Oil;                                               // 0x0100(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Blood;                                             // 0x0178(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Liquid;                                            // 0x01F0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Fluid;                                             // 0x0268(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Ash;                                               // 0x02E0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Snow;                                              // 0x0358(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Grass;                                             // 0x03D0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Dirt;                                              // 0x0448(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Skin;                                              // 0x04C0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Plastic;                                           // 0x0538(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Crystal;                                           // 0x05B0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Metal;                                             // 0x0628(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Stone;                                             // 0x06A0(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Wood;                                              // 0x0718(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Glass;                                             // 0x0790(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       CarcassSkin;                                       // 0x0808(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Carpet;                                            // 0x0880(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Tree;                                              // 0x08F8(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLFootStepFxData                       Carbon;                                            // 0x0970(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFootStepFxRow) == 0x000008, "Wrong alignment on FLFootStepFxRow");
static_assert(sizeof(FLFootStepFxRow) == 0x0009E8, "Wrong size on FLFootStepFxRow");
static_assert(offsetof(FLFootStepFxRow, EventName) == 0x000008, "Member 'FLFootStepFxRow::EventName' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Default) == 0x000010, "Member 'FLFootStepFxRow::Default' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Water) == 0x000088, "Member 'FLFootStepFxRow::Water' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Oil) == 0x000100, "Member 'FLFootStepFxRow::Oil' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Blood) == 0x000178, "Member 'FLFootStepFxRow::Blood' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Liquid) == 0x0001F0, "Member 'FLFootStepFxRow::Liquid' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Fluid) == 0x000268, "Member 'FLFootStepFxRow::Fluid' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Ash) == 0x0002E0, "Member 'FLFootStepFxRow::Ash' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Snow) == 0x000358, "Member 'FLFootStepFxRow::Snow' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Grass) == 0x0003D0, "Member 'FLFootStepFxRow::Grass' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Dirt) == 0x000448, "Member 'FLFootStepFxRow::Dirt' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Skin) == 0x0004C0, "Member 'FLFootStepFxRow::Skin' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Plastic) == 0x000538, "Member 'FLFootStepFxRow::Plastic' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Crystal) == 0x0005B0, "Member 'FLFootStepFxRow::Crystal' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Metal) == 0x000628, "Member 'FLFootStepFxRow::Metal' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Stone) == 0x0006A0, "Member 'FLFootStepFxRow::Stone' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Wood) == 0x000718, "Member 'FLFootStepFxRow::Wood' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Glass) == 0x000790, "Member 'FLFootStepFxRow::Glass' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, CarcassSkin) == 0x000808, "Member 'FLFootStepFxRow::CarcassSkin' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Carpet) == 0x000880, "Member 'FLFootStepFxRow::Carpet' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Tree) == 0x0008F8, "Member 'FLFootStepFxRow::Tree' has a wrong offset!");
static_assert(offsetof(FLFootStepFxRow, Carbon) == 0x000970, "Member 'FLFootStepFxRow::Carbon' has a wrong offset!");

// ScriptStruct ProjectP.LFrenzyEffectData
// 0x002C (0x002C - 0x0000)
struct FLFrenzyEffectData final
{
public:
	class FName                                   FX_Codename;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocket;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x1C];                                      // 0x0010(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLFrenzyEffectData) == 0x000004, "Wrong alignment on FLFrenzyEffectData");
static_assert(sizeof(FLFrenzyEffectData) == 0x00002C, "Wrong size on FLFrenzyEffectData");
static_assert(offsetof(FLFrenzyEffectData, FX_Codename) == 0x000000, "Member 'FLFrenzyEffectData::FX_Codename' has a wrong offset!");
static_assert(offsetof(FLFrenzyEffectData, AttachSocket) == 0x000008, "Member 'FLFrenzyEffectData::AttachSocket' has a wrong offset!");

// ScriptStruct ProjectP.LFxContentParameter_Scalar
// 0x0008 (0x0008 - 0x0000)
struct FLFxContentParameter_Scalar final
{
public:
	ELFxParamterContentType                       ValueByContent;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFxContentParameter_Scalar) == 0x000004, "Wrong alignment on FLFxContentParameter_Scalar");
static_assert(sizeof(FLFxContentParameter_Scalar) == 0x000008, "Wrong size on FLFxContentParameter_Scalar");
static_assert(offsetof(FLFxContentParameter_Scalar, ValueByContent) == 0x000000, "Member 'FLFxContentParameter_Scalar::ValueByContent' has a wrong offset!");
static_assert(offsetof(FLFxContentParameter_Scalar, Value) == 0x000004, "Member 'FLFxContentParameter_Scalar::Value' has a wrong offset!");

// ScriptStruct ProjectP.LFxAttachCommonTableRow
// 0x00F8 (0x0100 - 0x0008)
struct FLFxAttachCommonTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UFXSystemAsset>          Fx;                                                // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLFxContentParameter_Scalar> FxParameters_Scalar;                               // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLFxContentParameter_Color> FxParameters_Color;                                // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bUseAbsoluteRotation;                              // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x00D8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFxAttachCommonTableRow) == 0x000008, "Wrong alignment on FLFxAttachCommonTableRow");
static_assert(sizeof(FLFxAttachCommonTableRow) == 0x000100, "Wrong size on FLFxAttachCommonTableRow");
static_assert(offsetof(FLFxAttachCommonTableRow, Fx) == 0x000008, "Member 'FLFxAttachCommonTableRow::Fx' has a wrong offset!");
static_assert(offsetof(FLFxAttachCommonTableRow, FxParameters_Scalar) == 0x000030, "Member 'FLFxAttachCommonTableRow::FxParameters_Scalar' has a wrong offset!");
static_assert(offsetof(FLFxAttachCommonTableRow, FxParameters_Color) == 0x000080, "Member 'FLFxAttachCommonTableRow::FxParameters_Color' has a wrong offset!");
static_assert(offsetof(FLFxAttachCommonTableRow, bUseAbsoluteRotation) == 0x0000D0, "Member 'FLFxAttachCommonTableRow::bUseAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(FLFxAttachCommonTableRow, Sound) == 0x0000D8, "Member 'FLFxAttachCommonTableRow::Sound' has a wrong offset!");

// ScriptStruct ProjectP.LEnvSoundTable
// 0x0008 (0x0008 - 0x0000)
struct FLEnvSoundTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLEnvSoundTable) == 0x000008, "Wrong alignment on FLEnvSoundTable");
static_assert(sizeof(FLEnvSoundTable) == 0x000008, "Wrong size on FLEnvSoundTable");
static_assert(offsetof(FLEnvSoundTable, Table) == 0x000000, "Member 'FLEnvSoundTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LFXTrailEmitter
// 0x0040 (0x0040 - 0x0000)
struct FLFXTrailEmitter final
{
public:
	class UObject*                                Instigator;                                        // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PSTemplate;                                        // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstSocketName;                                   // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0020(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReserveStopTime;                                   // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x14];                                      // 0x002C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLFXTrailEmitter) == 0x000008, "Wrong alignment on FLFXTrailEmitter");
static_assert(sizeof(FLFXTrailEmitter) == 0x000040, "Wrong size on FLFXTrailEmitter");
static_assert(offsetof(FLFXTrailEmitter, Instigator) == 0x000000, "Member 'FLFXTrailEmitter::Instigator' has a wrong offset!");
static_assert(offsetof(FLFXTrailEmitter, PSTemplate) == 0x000008, "Member 'FLFXTrailEmitter::PSTemplate' has a wrong offset!");
static_assert(offsetof(FLFXTrailEmitter, FirstSocketName) == 0x000010, "Member 'FLFXTrailEmitter::FirstSocketName' has a wrong offset!");
static_assert(offsetof(FLFXTrailEmitter, SecondSocketName) == 0x000018, "Member 'FLFXTrailEmitter::SecondSocketName' has a wrong offset!");
static_assert(offsetof(FLFXTrailEmitter, MeshComp) == 0x000020, "Member 'FLFXTrailEmitter::MeshComp' has a wrong offset!");
static_assert(offsetof(FLFXTrailEmitter, ReserveStopTime) == 0x000028, "Member 'FLFXTrailEmitter::ReserveStopTime' has a wrong offset!");

// ScriptStruct ProjectP.LWeatherSoundTableRow
// 0x00C8 (0x00D0 - 0x0008)
struct FLWeatherSoundTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      DefaultScalarParameters;                           // 0x0030(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              DefaultColorParameters;                            // 0x0080(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWeatherSoundTableRow) == 0x000008, "Wrong alignment on FLWeatherSoundTableRow");
static_assert(sizeof(FLWeatherSoundTableRow) == 0x0000D0, "Wrong size on FLWeatherSoundTableRow");
static_assert(offsetof(FLWeatherSoundTableRow, Sound) == 0x000008, "Member 'FLWeatherSoundTableRow::Sound' has a wrong offset!");
static_assert(offsetof(FLWeatherSoundTableRow, DefaultScalarParameters) == 0x000030, "Member 'FLWeatherSoundTableRow::DefaultScalarParameters' has a wrong offset!");
static_assert(offsetof(FLWeatherSoundTableRow, DefaultColorParameters) == 0x000080, "Member 'FLWeatherSoundTableRow::DefaultColorParameters' has a wrong offset!");

// ScriptStruct ProjectP.LWidgetTableRow
// 0x0038 (0x0040 - 0x0008)
struct FLWidgetTableRow final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   Class;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWidgetDepth                                 Depth;                                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrder;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWidgetLoading                               LoadingType;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWidgetTableRow) == 0x000008, "Wrong alignment on FLWidgetTableRow");
static_assert(sizeof(FLWidgetTableRow) == 0x000040, "Wrong size on FLWidgetTableRow");
static_assert(offsetof(FLWidgetTableRow, Class) == 0x000008, "Member 'FLWidgetTableRow::Class' has a wrong offset!");
static_assert(offsetof(FLWidgetTableRow, Depth) == 0x000030, "Member 'FLWidgetTableRow::Depth' has a wrong offset!");
static_assert(offsetof(FLWidgetTableRow, ZOrder) == 0x000034, "Member 'FLWidgetTableRow::ZOrder' has a wrong offset!");
static_assert(offsetof(FLWidgetTableRow, LoadingType) == 0x000038, "Member 'FLWidgetTableRow::LoadingType' has a wrong offset!");

// ScriptStruct ProjectP.LFXByActionState
// 0x002C (0x002C - 0x0000)
struct alignas(0x04) FLFXByActionState final
{
public:
	uint8                                         Pad_0[0x2C];                                       // 0x0000(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLFXByActionState) == 0x000004, "Wrong alignment on FLFXByActionState");
static_assert(sizeof(FLFXByActionState) == 0x00002C, "Wrong size on FLFXByActionState");

// ScriptStruct ProjectP.MonsterMonologueCooltimeInfo
// 0x000C (0x000C - 0x0000)
struct FMonsterMonologueCooltimeInfo final
{
public:
	class FName                                   SpotUniqueID;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolTime;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMonsterMonologueCooltimeInfo) == 0x000004, "Wrong alignment on FMonsterMonologueCooltimeInfo");
static_assert(sizeof(FMonsterMonologueCooltimeInfo) == 0x00000C, "Wrong size on FMonsterMonologueCooltimeInfo");
static_assert(offsetof(FMonsterMonologueCooltimeInfo, SpotUniqueID) == 0x000000, "Member 'FMonsterMonologueCooltimeInfo::SpotUniqueID' has a wrong offset!");
static_assert(offsetof(FMonsterMonologueCooltimeInfo, CoolTime) == 0x000008, "Member 'FMonsterMonologueCooltimeInfo::CoolTime' has a wrong offset!");

// ScriptStruct ProjectP.LSmashFXPlayData
// 0x0050 (0x0050 - 0x0000)
struct FLSmashFXPlayData final
{
public:
	class ALWeapon*                               AttackerWeapon;                                    // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              GroundMaterial;                                    // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HitTransform;                                      // 0x0020(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSmashFXPlayData) == 0x000010, "Wrong alignment on FLSmashFXPlayData");
static_assert(sizeof(FLSmashFXPlayData) == 0x000050, "Wrong size on FLSmashFXPlayData");
static_assert(offsetof(FLSmashFXPlayData, AttackerWeapon) == 0x000000, "Member 'FLSmashFXPlayData::AttackerWeapon' has a wrong offset!");
static_assert(offsetof(FLSmashFXPlayData, SkillHitCodeName) == 0x000008, "Member 'FLSmashFXPlayData::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(FLSmashFXPlayData, GroundMaterial) == 0x000010, "Member 'FLSmashFXPlayData::GroundMaterial' has a wrong offset!");
static_assert(offsetof(FLSmashFXPlayData, HitTransform) == 0x000020, "Member 'FLSmashFXPlayData::HitTransform' has a wrong offset!");

// ScriptStruct ProjectP.LGalleryAssetTableRowType
// 0x0050 (0x0058 - 0x0008)
struct FLGalleryAssetTableRowType final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon_Unlock;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ModelResource;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGalleryAssetTableRowType) == 0x000008, "Wrong alignment on FLGalleryAssetTableRowType");
static_assert(sizeof(FLGalleryAssetTableRowType) == 0x000058, "Wrong size on FLGalleryAssetTableRowType");
static_assert(offsetof(FLGalleryAssetTableRowType, Icon_Unlock) == 0x000008, "Member 'FLGalleryAssetTableRowType::Icon_Unlock' has a wrong offset!");
static_assert(offsetof(FLGalleryAssetTableRowType, ModelResource) == 0x000030, "Member 'FLGalleryAssetTableRowType::ModelResource' has a wrong offset!");

// ScriptStruct ProjectP.LSoundFadeData
// 0x0010 (0x0010 - 0x0000)
struct FLSoundFadeData final
{
public:
	uint8                                         bUseFade : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeDuration;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeVolumeLevel;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAudioFaderCurve                              FadeCurve;                                         // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSoundFadeData) == 0x000004, "Wrong alignment on FLSoundFadeData");
static_assert(sizeof(FLSoundFadeData) == 0x000010, "Wrong size on FLSoundFadeData");
static_assert(offsetof(FLSoundFadeData, FadeDuration) == 0x000004, "Member 'FLSoundFadeData::FadeDuration' has a wrong offset!");
static_assert(offsetof(FLSoundFadeData, FadeVolumeLevel) == 0x000008, "Member 'FLSoundFadeData::FadeVolumeLevel' has a wrong offset!");
static_assert(offsetof(FLSoundFadeData, FadeCurve) == 0x00000C, "Member 'FLSoundFadeData::FadeCurve' has a wrong offset!");

// ScriptStruct ProjectP.LOverlapResult
// 0x0018 (0x0018 - 0x0000)
struct FLOverlapResult final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     Component;                                         // 0x0008(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bBlockingHit : 1;                                  // 0x0014(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLOverlapResult) == 0x000004, "Wrong alignment on FLOverlapResult");
static_assert(sizeof(FLOverlapResult) == 0x000018, "Wrong size on FLOverlapResult");
static_assert(offsetof(FLOverlapResult, Actor) == 0x000000, "Member 'FLOverlapResult::Actor' has a wrong offset!");
static_assert(offsetof(FLOverlapResult, Component) == 0x000008, "Member 'FLOverlapResult::Component' has a wrong offset!");

// ScriptStruct ProjectP.LGuardStatOverride
// 0x0024 (0x0024 - 0x0000)
struct FLGuardStatOverride final
{
public:
	uint8                                         IsValid : 1;                                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GuardDurationRatio;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardKnockbackDistanceReductionRatio;              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardPhysicaldamageReductionRatio;                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardFiredamageReductionRatio;                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardElectricdamageReductionRatio;                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardAciddamageReductionRatio;                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PerfectGuardDecreaseEnemyWeaponDurability;         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GuardRegainPerfectGuardHeal;                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGuardStatOverride) == 0x000004, "Wrong alignment on FLGuardStatOverride");
static_assert(sizeof(FLGuardStatOverride) == 0x000024, "Wrong size on FLGuardStatOverride");
static_assert(offsetof(FLGuardStatOverride, GuardDurationRatio) == 0x000004, "Member 'FLGuardStatOverride::GuardDurationRatio' has a wrong offset!");
static_assert(offsetof(FLGuardStatOverride, GuardKnockbackDistanceReductionRatio) == 0x000008, "Member 'FLGuardStatOverride::GuardKnockbackDistanceReductionRatio' has a wrong offset!");
static_assert(offsetof(FLGuardStatOverride, GuardPhysicaldamageReductionRatio) == 0x00000C, "Member 'FLGuardStatOverride::GuardPhysicaldamageReductionRatio' has a wrong offset!");
static_assert(offsetof(FLGuardStatOverride, GuardFiredamageReductionRatio) == 0x000010, "Member 'FLGuardStatOverride::GuardFiredamageReductionRatio' has a wrong offset!");
static_assert(offsetof(FLGuardStatOverride, GuardElectricdamageReductionRatio) == 0x000014, "Member 'FLGuardStatOverride::GuardElectricdamageReductionRatio' has a wrong offset!");
static_assert(offsetof(FLGuardStatOverride, GuardAciddamageReductionRatio) == 0x000018, "Member 'FLGuardStatOverride::GuardAciddamageReductionRatio' has a wrong offset!");
static_assert(offsetof(FLGuardStatOverride, PerfectGuardDecreaseEnemyWeaponDurability) == 0x00001C, "Member 'FLGuardStatOverride::PerfectGuardDecreaseEnemyWeaponDurability' has a wrong offset!");
static_assert(offsetof(FLGuardStatOverride, GuardRegainPerfectGuardHeal) == 0x000020, "Member 'FLGuardStatOverride::GuardRegainPerfectGuardHeal' has a wrong offset!");

// ScriptStruct ProjectP.LExplosionMeshInfo
// 0x00A8 (0x00A8 - 0x0000)
struct FLExplosionMeshInfo final
{
public:
	ELExplosionMeshType                           ExplosionMeshType;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPhysicsAsset>           PhysicsAsset;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FxSocketNameArray;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         CarcassMeshHideTime;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalKillPower_ToUp;                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalKillPower_RootToCut;                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillPowerWeight;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillPowerWeightForSphere;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxCutRadius;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FxCutSpawnT;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FxCutOffset;                                       // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetachBoneName;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideBoneName;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EffectTableCodeName;                               // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoundTableCodeName;                                // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KillPowerSphereSocketName;                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                KillPowerSphereOffset;                             // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CarcassHybridPuppet;                               // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HideBoneName_Parent;                               // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent_Body;                        // 0x0088(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent_Extra;                       // 0x0090(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent_Explode;                     // 0x0098(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent_Cut;                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLExplosionMeshInfo) == 0x000008, "Wrong alignment on FLExplosionMeshInfo");
static_assert(sizeof(FLExplosionMeshInfo) == 0x0000A8, "Wrong size on FLExplosionMeshInfo");
static_assert(offsetof(FLExplosionMeshInfo, ExplosionMeshType) == 0x000000, "Member 'FLExplosionMeshInfo::ExplosionMeshType' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, PhysicsAsset) == 0x000004, "Member 'FLExplosionMeshInfo::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, FxSocketNameArray) == 0x000010, "Member 'FLExplosionMeshInfo::FxSocketNameArray' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, CarcassMeshHideTime) == 0x000020, "Member 'FLExplosionMeshInfo::CarcassMeshHideTime' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, AdditionalKillPower_ToUp) == 0x000024, "Member 'FLExplosionMeshInfo::AdditionalKillPower_ToUp' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, AdditionalKillPower_RootToCut) == 0x000028, "Member 'FLExplosionMeshInfo::AdditionalKillPower_RootToCut' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, KillPowerWeight) == 0x00002C, "Member 'FLExplosionMeshInfo::KillPowerWeight' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, KillPowerWeightForSphere) == 0x000030, "Member 'FLExplosionMeshInfo::KillPowerWeightForSphere' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, FxCutRadius) == 0x000034, "Member 'FLExplosionMeshInfo::FxCutRadius' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, FxCutSpawnT) == 0x000038, "Member 'FLExplosionMeshInfo::FxCutSpawnT' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, FxCutOffset) == 0x00003C, "Member 'FLExplosionMeshInfo::FxCutOffset' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, DetachBoneName) == 0x000048, "Member 'FLExplosionMeshInfo::DetachBoneName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, HideBoneName) == 0x000050, "Member 'FLExplosionMeshInfo::HideBoneName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, EffectTableCodeName) == 0x000058, "Member 'FLExplosionMeshInfo::EffectTableCodeName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, SoundTableCodeName) == 0x000060, "Member 'FLExplosionMeshInfo::SoundTableCodeName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, KillPowerSphereSocketName) == 0x000068, "Member 'FLExplosionMeshInfo::KillPowerSphereSocketName' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, KillPowerSphereOffset) == 0x000070, "Member 'FLExplosionMeshInfo::KillPowerSphereOffset' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, CarcassHybridPuppet) == 0x00007C, "Member 'FLExplosionMeshInfo::CarcassHybridPuppet' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, HideBoneName_Parent) == 0x000080, "Member 'FLExplosionMeshInfo::HideBoneName_Parent' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, SkeletalMeshComponent_Body) == 0x000088, "Member 'FLExplosionMeshInfo::SkeletalMeshComponent_Body' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, SkeletalMeshComponent_Extra) == 0x000090, "Member 'FLExplosionMeshInfo::SkeletalMeshComponent_Extra' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, SkeletalMeshComponent_Explode) == 0x000098, "Member 'FLExplosionMeshInfo::SkeletalMeshComponent_Explode' has a wrong offset!");
static_assert(offsetof(FLExplosionMeshInfo, SkeletalMeshComponent_Cut) == 0x0000A0, "Member 'FLExplosionMeshInfo::SkeletalMeshComponent_Cut' has a wrong offset!");

// ScriptStruct ProjectP.LHitCollisionInfo
// 0x0088 (0x0088 - 0x0000)
struct FLHitCollisionInfo final
{
public:
	ELCollisionOwnerType                          DynamicCollisionType;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAttackCollision;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSweepTest;                                      // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillCodeNameOverride;                             // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitIndex;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TickInterval_MaxCount;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLHitIndexInfo                         HitIndexInfo;                                      // 0x0018(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	ELHitCollisionCheckType                       HitCheckType;                                      // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachToInstigator;                                // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 AttachSocketOwnerMesh;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfileName;                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Box_Extend;                                        // 0x0048(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Capsule_Radius;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Capsule_Length;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sphere_Radius;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset_Location;                                   // 0x0060(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Offset_Rotation;                                   // 0x006C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ELGuardingObjectType                          GuardType;                                         // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELWeaponAttachPointType                       WeaponAttachPoint;                                 // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPartsRepulse;                                    // 0x007A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PartsCodeName;                                     // 0x007C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Override_PhysicalSurface;                          // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLHitCollisionInfo) == 0x000008, "Wrong alignment on FLHitCollisionInfo");
static_assert(sizeof(FLHitCollisionInfo) == 0x000088, "Wrong size on FLHitCollisionInfo");
static_assert(offsetof(FLHitCollisionInfo, DynamicCollisionType) == 0x000000, "Member 'FLHitCollisionInfo::DynamicCollisionType' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, IsAttackCollision) == 0x000001, "Member 'FLHitCollisionInfo::IsAttackCollision' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, UseSweepTest) == 0x000002, "Member 'FLHitCollisionInfo::UseSweepTest' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, SkillCodeNameOverride) == 0x000004, "Member 'FLHitCollisionInfo::SkillCodeNameOverride' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, HitIndex) == 0x00000C, "Member 'FLHitCollisionInfo::HitIndex' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, TickInterval) == 0x000010, "Member 'FLHitCollisionInfo::TickInterval' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, TickInterval_MaxCount) == 0x000014, "Member 'FLHitCollisionInfo::TickInterval_MaxCount' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, HitIndexInfo) == 0x000018, "Member 'FLHitCollisionInfo::HitIndexInfo' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, HitCheckType) == 0x00002C, "Member 'FLHitCollisionInfo::HitCheckType' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, AttachToInstigator) == 0x00002D, "Member 'FLHitCollisionInfo::AttachToInstigator' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, AttachSocketOwnerMesh) == 0x000030, "Member 'FLHitCollisionInfo::AttachSocketOwnerMesh' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, SocketName) == 0x000038, "Member 'FLHitCollisionInfo::SocketName' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, CollisionProfileName) == 0x000040, "Member 'FLHitCollisionInfo::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, Box_Extend) == 0x000048, "Member 'FLHitCollisionInfo::Box_Extend' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, Capsule_Radius) == 0x000054, "Member 'FLHitCollisionInfo::Capsule_Radius' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, Capsule_Length) == 0x000058, "Member 'FLHitCollisionInfo::Capsule_Length' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, Sphere_Radius) == 0x00005C, "Member 'FLHitCollisionInfo::Sphere_Radius' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, Offset_Location) == 0x000060, "Member 'FLHitCollisionInfo::Offset_Location' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, Offset_Rotation) == 0x00006C, "Member 'FLHitCollisionInfo::Offset_Rotation' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, GuardType) == 0x000078, "Member 'FLHitCollisionInfo::GuardType' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, WeaponAttachPoint) == 0x000079, "Member 'FLHitCollisionInfo::WeaponAttachPoint' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, IsPartsRepulse) == 0x00007A, "Member 'FLHitCollisionInfo::IsPartsRepulse' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, PartsCodeName) == 0x00007C, "Member 'FLHitCollisionInfo::PartsCodeName' has a wrong offset!");
static_assert(offsetof(FLHitCollisionInfo, Override_PhysicalSurface) == 0x000084, "Member 'FLHitCollisionInfo::Override_PhysicalSurface' has a wrong offset!");

// ScriptStruct ProjectP.LGrabReleaseInfo
// 0x0020 (0x0020 - 0x0000)
struct FLGrabReleaseInfo final
{
public:
	uint8                                         IsValidInfo : 1;                                   // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DoForceRelease : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ELGrabReleaseMotionType                       TargetActionType;                                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           TargetMontage;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TargetMontageFront;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TargetMontageBack;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLGrabReleaseInfo) == 0x000008, "Wrong alignment on FLGrabReleaseInfo");
static_assert(sizeof(FLGrabReleaseInfo) == 0x000020, "Wrong size on FLGrabReleaseInfo");
static_assert(offsetof(FLGrabReleaseInfo, TargetActionType) == 0x000001, "Member 'FLGrabReleaseInfo::TargetActionType' has a wrong offset!");
static_assert(offsetof(FLGrabReleaseInfo, TargetMontage) == 0x000008, "Member 'FLGrabReleaseInfo::TargetMontage' has a wrong offset!");
static_assert(offsetof(FLGrabReleaseInfo, TargetMontageFront) == 0x000010, "Member 'FLGrabReleaseInfo::TargetMontageFront' has a wrong offset!");
static_assert(offsetof(FLGrabReleaseInfo, TargetMontageBack) == 0x000018, "Member 'FLGrabReleaseInfo::TargetMontageBack' has a wrong offset!");

// ScriptStruct ProjectP.LCollectAssets
// 0x0010 (0x0010 - 0x0000)
struct FLCollectAssets final
{
public:
	TArray<struct FSoftObjectPath>                PathArray;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCollectAssets) == 0x000008, "Wrong alignment on FLCollectAssets");
static_assert(sizeof(FLCollectAssets) == 0x000010, "Wrong size on FLCollectAssets");
static_assert(offsetof(FLCollectAssets, PathArray) == 0x000000, "Member 'FLCollectAssets::PathArray' has a wrong offset!");

// ScriptStruct ProjectP.LCachedComponentAttachment
// 0x0050 (0x0050 - 0x0000)
struct FLCachedComponentAttachment final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachParent;                                      // 0x0008(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachSocketName;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0020(0x0030)(Edit, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCachedComponentAttachment) == 0x000010, "Wrong alignment on FLCachedComponentAttachment");
static_assert(sizeof(FLCachedComponentAttachment) == 0x000050, "Wrong size on FLCachedComponentAttachment");
static_assert(offsetof(FLCachedComponentAttachment, Component) == 0x000000, "Member 'FLCachedComponentAttachment::Component' has a wrong offset!");
static_assert(offsetof(FLCachedComponentAttachment, AttachParent) == 0x000008, "Member 'FLCachedComponentAttachment::AttachParent' has a wrong offset!");
static_assert(offsetof(FLCachedComponentAttachment, AttachSocketName) == 0x000010, "Member 'FLCachedComponentAttachment::AttachSocketName' has a wrong offset!");
static_assert(offsetof(FLCachedComponentAttachment, RelativeTransform) == 0x000020, "Member 'FLCachedComponentAttachment::RelativeTransform' has a wrong offset!");

// ScriptStruct ProjectP.LNpcSpotWakeUpData
// 0x0008 (0x0008 - 0x0000)
struct FLNpcSpotWakeUpData final
{
public:
	float                                         WakeUpDelay;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WakeUpDelayRandom;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNpcSpotWakeUpData) == 0x000004, "Wrong alignment on FLNpcSpotWakeUpData");
static_assert(sizeof(FLNpcSpotWakeUpData) == 0x000008, "Wrong size on FLNpcSpotWakeUpData");
static_assert(offsetof(FLNpcSpotWakeUpData, WakeUpDelay) == 0x000000, "Member 'FLNpcSpotWakeUpData::WakeUpDelay' has a wrong offset!");
static_assert(offsetof(FLNpcSpotWakeUpData, WakeUpDelayRandom) == 0x000004, "Member 'FLNpcSpotWakeUpData::WakeUpDelayRandom' has a wrong offset!");

// ScriptStruct ProjectP.LSkillLinkInfoOverride
// 0x0060 (0x0060 - 0x0000)
struct FLSkillLinkInfoOverride final
{
public:
	uint8                                         ConditionPercent : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PercentValue;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionRange : 1;                                // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ELAIRangeCheckType                            SkillrangeChecktype;                               // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkillDistMin;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDistMax;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillRangeAngleStart;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillRangeAngleEnd;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillDistHeight;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionHitTarget : 1;                            // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HitTargetActionEventAlias;                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIDamageType                                HitDamageType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UseSkillId;                                        // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionDefenceSkill : 1;                         // 0x0044(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConditionPartNeeded;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionBeHit : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	ELPhysicalDamageType                          BeHitByPhysicalDamageType;                         // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELElementDamageType                           BeHitByElementDamageType;                          // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LinkSkillUseCooltime : 1;                          // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         ConditionCooltime : 1;                             // 0x0058(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         ConditionCollideCeiling : 1;                       // 0x0058(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollideCeilingHeight;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSkillLinkInfoOverride) == 0x000008, "Wrong alignment on FLSkillLinkInfoOverride");
static_assert(sizeof(FLSkillLinkInfoOverride) == 0x000060, "Wrong size on FLSkillLinkInfoOverride");
static_assert(offsetof(FLSkillLinkInfoOverride, PercentValue) == 0x000004, "Member 'FLSkillLinkInfoOverride::PercentValue' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, SkillrangeChecktype) == 0x000009, "Member 'FLSkillLinkInfoOverride::SkillrangeChecktype' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, SkillDistMin) == 0x00000C, "Member 'FLSkillLinkInfoOverride::SkillDistMin' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, SkillDistMax) == 0x000010, "Member 'FLSkillLinkInfoOverride::SkillDistMax' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, SkillRangeAngleStart) == 0x000014, "Member 'FLSkillLinkInfoOverride::SkillRangeAngleStart' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, SkillRangeAngleEnd) == 0x000018, "Member 'FLSkillLinkInfoOverride::SkillRangeAngleEnd' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, SkillDistHeight) == 0x00001C, "Member 'FLSkillLinkInfoOverride::SkillDistHeight' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, HitTargetActionEventAlias) == 0x000028, "Member 'FLSkillLinkInfoOverride::HitTargetActionEventAlias' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, HitDamageType) == 0x000038, "Member 'FLSkillLinkInfoOverride::HitDamageType' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, UseSkillId) == 0x00003C, "Member 'FLSkillLinkInfoOverride::UseSkillId' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, ConditionPartNeeded) == 0x000048, "Member 'FLSkillLinkInfoOverride::ConditionPartNeeded' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, BeHitByPhysicalDamageType) == 0x000051, "Member 'FLSkillLinkInfoOverride::BeHitByPhysicalDamageType' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, BeHitByElementDamageType) == 0x000052, "Member 'FLSkillLinkInfoOverride::BeHitByElementDamageType' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, Priority) == 0x000054, "Member 'FLSkillLinkInfoOverride::Priority' has a wrong offset!");
static_assert(offsetof(FLSkillLinkInfoOverride, CollideCeilingHeight) == 0x00005C, "Member 'FLSkillLinkInfoOverride::CollideCeilingHeight' has a wrong offset!");

// ScriptStruct ProjectP.LNPCShareData
// 0x0050 (0x0050 - 0x0000)
struct FLNPCShareData final
{
public:
	TSet<class FName>                             UniqueEvents;                                      // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCShareData) == 0x000008, "Wrong alignment on FLNPCShareData");
static_assert(sizeof(FLNPCShareData) == 0x000050, "Wrong size on FLNPCShareData");
static_assert(offsetof(FLNPCShareData, UniqueEvents) == 0x000000, "Member 'FLNPCShareData::UniqueEvents' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponDestructDurabilityEnable
// 0x0014 (0x0014 - 0x0000)
struct FLWeaponDestructDurabilityEnable final
{
public:
	ELWeaponAttachPointType                       WeaponAttackPoint;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartAngle;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndAngle;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsageGuard;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWeaponDestructDurabilityEnable) == 0x000004, "Wrong alignment on FLWeaponDestructDurabilityEnable");
static_assert(sizeof(FLWeaponDestructDurabilityEnable) == 0x000014, "Wrong size on FLWeaponDestructDurabilityEnable");
static_assert(offsetof(FLWeaponDestructDurabilityEnable, WeaponAttackPoint) == 0x000000, "Member 'FLWeaponDestructDurabilityEnable::WeaponAttackPoint' has a wrong offset!");
static_assert(offsetof(FLWeaponDestructDurabilityEnable, StartAngle) == 0x000004, "Member 'FLWeaponDestructDurabilityEnable::StartAngle' has a wrong offset!");
static_assert(offsetof(FLWeaponDestructDurabilityEnable, EndAngle) == 0x000008, "Member 'FLWeaponDestructDurabilityEnable::EndAngle' has a wrong offset!");
static_assert(offsetof(FLWeaponDestructDurabilityEnable, Distance) == 0x00000C, "Member 'FLWeaponDestructDurabilityEnable::Distance' has a wrong offset!");
static_assert(offsetof(FLWeaponDestructDurabilityEnable, bUsageGuard) == 0x000010, "Member 'FLWeaponDestructDurabilityEnable::bUsageGuard' has a wrong offset!");

// ScriptStruct ProjectP.LFatalAttackResultInfo
// 0x0028 (0x0028 - 0x0000)
struct FLFatalAttackResultInfo final
{
public:
	TWeakObjectPtr<class AActor>                  Cached_FatalAttack_Victim;                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Cached_FatalAttack_Attacker;                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim_BeforeHit;                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FatalAttack_ReplacedAnim_End;                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLFatalAttackResultInfo) == 0x000004, "Wrong alignment on FLFatalAttackResultInfo");
static_assert(sizeof(FLFatalAttackResultInfo) == 0x000028, "Wrong size on FLFatalAttackResultInfo");
static_assert(offsetof(FLFatalAttackResultInfo, Cached_FatalAttack_Victim) == 0x000000, "Member 'FLFatalAttackResultInfo::Cached_FatalAttack_Victim' has a wrong offset!");
static_assert(offsetof(FLFatalAttackResultInfo, Cached_FatalAttack_Attacker) == 0x000008, "Member 'FLFatalAttackResultInfo::Cached_FatalAttack_Attacker' has a wrong offset!");
static_assert(offsetof(FLFatalAttackResultInfo, FatalAttack_ReplacedAnim_BeforeHit) == 0x000010, "Member 'FLFatalAttackResultInfo::FatalAttack_ReplacedAnim_BeforeHit' has a wrong offset!");
static_assert(offsetof(FLFatalAttackResultInfo, FatalAttack_ReplacedAnim) == 0x000018, "Member 'FLFatalAttackResultInfo::FatalAttack_ReplacedAnim' has a wrong offset!");
static_assert(offsetof(FLFatalAttackResultInfo, FatalAttack_ReplacedAnim_End) == 0x000020, "Member 'FLFatalAttackResultInfo::FatalAttack_ReplacedAnim_End' has a wrong offset!");

// ScriptStruct ProjectP.LLoopAttachFxData
// 0x0028 (0x0028 - 0x0000)
struct FLLoopAttachFxData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      NiagaraComponent;                                  // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLoopAttachFxData) == 0x000008, "Wrong alignment on FLLoopAttachFxData");
static_assert(sizeof(FLLoopAttachFxData) == 0x000028, "Wrong size on FLLoopAttachFxData");
static_assert(offsetof(FLLoopAttachFxData, NiagaraComponent) == 0x000008, "Member 'FLLoopAttachFxData::NiagaraComponent' has a wrong offset!");

// ScriptStruct ProjectP.LSequenceBindActor
// 0x001C (0x001C - 0x0000)
struct FLSequenceBindActor final
{
public:
	class FName                                   BindTagName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ALSpot>                  BindSpot;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  BindActor;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipRelatedSpot;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSequenceBindActor) == 0x000004, "Wrong alignment on FLSequenceBindActor");
static_assert(sizeof(FLSequenceBindActor) == 0x00001C, "Wrong size on FLSequenceBindActor");
static_assert(offsetof(FLSequenceBindActor, BindTagName) == 0x000000, "Member 'FLSequenceBindActor::BindTagName' has a wrong offset!");
static_assert(offsetof(FLSequenceBindActor, BindSpot) == 0x000008, "Member 'FLSequenceBindActor::BindSpot' has a wrong offset!");
static_assert(offsetof(FLSequenceBindActor, BindActor) == 0x000010, "Member 'FLSequenceBindActor::BindActor' has a wrong offset!");
static_assert(offsetof(FLSequenceBindActor, SkipRelatedSpot) == 0x000018, "Member 'FLSequenceBindActor::SkipRelatedSpot' has a wrong offset!");

// ScriptStruct ProjectP.LTutorialDetailInfo
// 0x000C (0x000C - 0x0000)
struct FLTutorialDetailInfo final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayCount;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTutorialDetailInfo) == 0x000004, "Wrong alignment on FLTutorialDetailInfo");
static_assert(sizeof(FLTutorialDetailInfo) == 0x00000C, "Wrong size on FLTutorialDetailInfo");
static_assert(offsetof(FLTutorialDetailInfo, TutorialCodeName) == 0x000000, "Member 'FLTutorialDetailInfo::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(FLTutorialDetailInfo, PlayCount) == 0x000008, "Member 'FLTutorialDetailInfo::PlayCount' has a wrong offset!");

// ScriptStruct ProjectP.QuestDetailInfo
// 0x0018 (0x0018 - 0x0000)
struct FQuestDetailInfo final
{
public:
	class FName                                   QuestCodeName;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELQuestState                                  QuestState;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QuestStepNum;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestVariable;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DialogSelectNum;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestDetailInfo) == 0x000004, "Wrong alignment on FQuestDetailInfo");
static_assert(sizeof(FQuestDetailInfo) == 0x000018, "Wrong size on FQuestDetailInfo");
static_assert(offsetof(FQuestDetailInfo, QuestCodeName) == 0x000000, "Member 'FQuestDetailInfo::QuestCodeName' has a wrong offset!");
static_assert(offsetof(FQuestDetailInfo, QuestState) == 0x000008, "Member 'FQuestDetailInfo::QuestState' has a wrong offset!");
static_assert(offsetof(FQuestDetailInfo, QuestStepNum) == 0x00000C, "Member 'FQuestDetailInfo::QuestStepNum' has a wrong offset!");
static_assert(offsetof(FQuestDetailInfo, QuestVariable) == 0x000010, "Member 'FQuestDetailInfo::QuestVariable' has a wrong offset!");
static_assert(offsetof(FQuestDetailInfo, DialogSelectNum) == 0x000014, "Member 'FQuestDetailInfo::DialogSelectNum' has a wrong offset!");

// ScriptStruct ProjectP.LNameList
// 0x0010 (0x0010 - 0x0000)
struct FLNameList final
{
public:
	TArray<class FName>                           DataList;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNameList) == 0x000008, "Wrong alignment on FLNameList");
static_assert(sizeof(FLNameList) == 0x000010, "Wrong size on FLNameList");
static_assert(offsetof(FLNameList, DataList) == 0x000000, "Member 'FLNameList::DataList' has a wrong offset!");

// ScriptStruct ProjectP.LReceiveDamageResults
// 0x0014 (0x0014 - 0x0000)
struct FLReceiveDamageResults final
{
public:
	int32                                         Damage;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitPartsName;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitPartsDestoryed;                                // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DamageCurrentHP;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLReceiveDamageResults) == 0x000004, "Wrong alignment on FLReceiveDamageResults");
static_assert(sizeof(FLReceiveDamageResults) == 0x000014, "Wrong size on FLReceiveDamageResults");
static_assert(offsetof(FLReceiveDamageResults, Damage) == 0x000000, "Member 'FLReceiveDamageResults::Damage' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageResults, HitPartsName) == 0x000004, "Member 'FLReceiveDamageResults::HitPartsName' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageResults, bHitPartsDestoryed) == 0x00000C, "Member 'FLReceiveDamageResults::bHitPartsDestoryed' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageResults, DamageCurrentHP) == 0x000010, "Member 'FLReceiveDamageResults::DamageCurrentHP' has a wrong offset!");

// ScriptStruct ProjectP.LReceiveDamageParams
// 0x00D0 (0x00D0 - 0x0000)
struct FLReceiveDamageParams final
{
public:
	TWeakObjectPtr<class ULHitProcContext>        HitProcContext;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Attacker;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillHitCodeName;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELPhysicalDamageType, float>             PhysicalDamages;                                   // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<ELElementDamageType, float>              ElementDamages;                                    // 0x0078(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bIsGuarding : 1;                                   // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSkipUIUpdate : 1;                                 // 0x00C8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsFallingDamage : 1;                              // 0x00C8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLReceiveDamageParams) == 0x000008, "Wrong alignment on FLReceiveDamageParams");
static_assert(sizeof(FLReceiveDamageParams) == 0x0000D0, "Wrong size on FLReceiveDamageParams");
static_assert(offsetof(FLReceiveDamageParams, HitProcContext) == 0x000000, "Member 'FLReceiveDamageParams::HitProcContext' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageParams, Damage) == 0x000008, "Member 'FLReceiveDamageParams::Damage' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageParams, Attacker) == 0x000010, "Member 'FLReceiveDamageParams::Attacker' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageParams, SkillHitCodeName) == 0x000018, "Member 'FLReceiveDamageParams::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageParams, HitComponent) == 0x000020, "Member 'FLReceiveDamageParams::HitComponent' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageParams, PhysicalDamages) == 0x000028, "Member 'FLReceiveDamageParams::PhysicalDamages' has a wrong offset!");
static_assert(offsetof(FLReceiveDamageParams, ElementDamages) == 0x000078, "Member 'FLReceiveDamageParams::ElementDamages' has a wrong offset!");

// ScriptStruct ProjectP.LCalcDamageData
// 0x0110 (0x0110 - 0x0000)
struct FLCalcDamageData final
{
public:
	int32                                         TotalPhysicalDamage;                               // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalElementDamage;                                // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ELPhysicalDamageType, float>             PhysicalDamages;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ELElementDamageType, float>              ElementDamages;                                    // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<ELElementDamageType, int32>              PureElementDamages;                                // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FLCalcBuildupData>              BuildupDatas;                                      // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         GuardRegainHp;                                     // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCalcDamageData) == 0x000008, "Wrong alignment on FLCalcDamageData");
static_assert(sizeof(FLCalcDamageData) == 0x000110, "Wrong size on FLCalcDamageData");
static_assert(offsetof(FLCalcDamageData, TotalPhysicalDamage) == 0x000000, "Member 'FLCalcDamageData::TotalPhysicalDamage' has a wrong offset!");
static_assert(offsetof(FLCalcDamageData, TotalElementDamage) == 0x000004, "Member 'FLCalcDamageData::TotalElementDamage' has a wrong offset!");
static_assert(offsetof(FLCalcDamageData, PhysicalDamages) == 0x000008, "Member 'FLCalcDamageData::PhysicalDamages' has a wrong offset!");
static_assert(offsetof(FLCalcDamageData, ElementDamages) == 0x000058, "Member 'FLCalcDamageData::ElementDamages' has a wrong offset!");
static_assert(offsetof(FLCalcDamageData, PureElementDamages) == 0x0000A8, "Member 'FLCalcDamageData::PureElementDamages' has a wrong offset!");
static_assert(offsetof(FLCalcDamageData, BuildupDatas) == 0x0000F8, "Member 'FLCalcDamageData::BuildupDatas' has a wrong offset!");
static_assert(offsetof(FLCalcDamageData, GuardRegainHp) == 0x000108, "Member 'FLCalcDamageData::GuardRegainHp' has a wrong offset!");

// ScriptStruct ProjectP.LActionStateInfo
// 0x0048 (0x0048 - 0x0000)
struct FLActionStateInfo final
{
public:
	class FName                                   State;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Invalidated;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvalidatedByImmune;                               // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 Instigator;                                        // 0x000C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULActBase>               OwnerAction;                                       // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELImmuneSourceType                            ImmuneSourceType;                                  // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RegisteredActionFrame;                             // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriggeredMontageInstanceID;                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpirationTime;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DebugInfo;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLActionStateInfo) == 0x000008, "Wrong alignment on FLActionStateInfo");
static_assert(sizeof(FLActionStateInfo) == 0x000048, "Wrong size on FLActionStateInfo");
static_assert(offsetof(FLActionStateInfo, State) == 0x000000, "Member 'FLActionStateInfo::State' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, Invalidated) == 0x000008, "Member 'FLActionStateInfo::Invalidated' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, InvalidatedByImmune) == 0x000009, "Member 'FLActionStateInfo::InvalidatedByImmune' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, Instigator) == 0x00000C, "Member 'FLActionStateInfo::Instigator' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, OwnerAction) == 0x000014, "Member 'FLActionStateInfo::OwnerAction' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, ImmuneSourceType) == 0x00001C, "Member 'FLActionStateInfo::ImmuneSourceType' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, RegisteredActionFrame) == 0x000020, "Member 'FLActionStateInfo::RegisteredActionFrame' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, TriggeredMontageInstanceID) == 0x000024, "Member 'FLActionStateInfo::TriggeredMontageInstanceID' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, ExpirationTime) == 0x000028, "Member 'FLActionStateInfo::ExpirationTime' has a wrong offset!");
static_assert(offsetof(FLActionStateInfo, DebugInfo) == 0x000030, "Member 'FLActionStateInfo::DebugInfo' has a wrong offset!");

// ScriptStruct ProjectP.LAnimRateScaleContext
// 0x0030 (0x0030 - 0x0000)
struct FLAnimRateScaleContext final
{
public:
	struct FLGameObjectHandle                     Handle;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Invalidated;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAnimRateScaleOperationType                  OperationType;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RateScale;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAnimMontage>            AnimMontage;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExclusiveMontageSlotName;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvalidateWhenInstigatorIsInvalid;                 // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 Instigator;                                        // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAnimRateScaleContext) == 0x000004, "Wrong alignment on FLAnimRateScaleContext");
static_assert(sizeof(FLAnimRateScaleContext) == 0x000030, "Wrong size on FLAnimRateScaleContext");
static_assert(offsetof(FLAnimRateScaleContext, Handle) == 0x000000, "Member 'FLAnimRateScaleContext::Handle' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, Invalidated) == 0x000004, "Member 'FLAnimRateScaleContext::Invalidated' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, OperationType) == 0x000005, "Member 'FLAnimRateScaleContext::OperationType' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, RateScale) == 0x000008, "Member 'FLAnimRateScaleContext::RateScale' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, Duration) == 0x00000C, "Member 'FLAnimRateScaleContext::Duration' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, AnimMontage) == 0x000010, "Member 'FLAnimRateScaleContext::AnimMontage' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, ExclusiveMontageSlotName) == 0x000018, "Member 'FLAnimRateScaleContext::ExclusiveMontageSlotName' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, InvalidateWhenInstigatorIsInvalid) == 0x000020, "Member 'FLAnimRateScaleContext::InvalidateWhenInstigatorIsInvalid' has a wrong offset!");
static_assert(offsetof(FLAnimRateScaleContext, Instigator) == 0x000024, "Member 'FLAnimRateScaleContext::Instigator' has a wrong offset!");

// ScriptStruct ProjectP.LMaterialParamDefaults
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x08) FLMaterialParamDefaults final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLMaterialParamDefaults) == 0x000008, "Wrong alignment on FLMaterialParamDefaults");
static_assert(sizeof(FLMaterialParamDefaults) == 0x0000A0, "Wrong size on FLMaterialParamDefaults");

// ScriptStruct ProjectP.LDropErgoData
// 0x0030 (0x0030 - 0x0000)
struct FLDropErgoData final
{
public:
	class FString                                 SpotUniqueID;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  DropActor;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DropLocation;                                      // 0x0018(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ErgoExp;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TemporaryData;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDropErgoData) == 0x000008, "Wrong alignment on FLDropErgoData");
static_assert(sizeof(FLDropErgoData) == 0x000030, "Wrong size on FLDropErgoData");
static_assert(offsetof(FLDropErgoData, SpotUniqueID) == 0x000000, "Member 'FLDropErgoData::SpotUniqueID' has a wrong offset!");
static_assert(offsetof(FLDropErgoData, DropActor) == 0x000010, "Member 'FLDropErgoData::DropActor' has a wrong offset!");
static_assert(offsetof(FLDropErgoData, DropLocation) == 0x000018, "Member 'FLDropErgoData::DropLocation' has a wrong offset!");
static_assert(offsetof(FLDropErgoData, ErgoExp) == 0x000024, "Member 'FLDropErgoData::ErgoExp' has a wrong offset!");
static_assert(offsetof(FLDropErgoData, TemporaryData) == 0x000028, "Member 'FLDropErgoData::TemporaryData' has a wrong offset!");

// ScriptStruct ProjectP.LVariableData
// 0x000C (0x000C - 0x0000)
struct FLVariableData final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLVariableData) == 0x000004, "Wrong alignment on FLVariableData");
static_assert(sizeof(FLVariableData) == 0x00000C, "Wrong size on FLVariableData");
static_assert(offsetof(FLVariableData, CodeName) == 0x000000, "Member 'FLVariableData::CodeName' has a wrong offset!");
static_assert(offsetof(FLVariableData, Value) == 0x000008, "Member 'FLVariableData::Value' has a wrong offset!");

// ScriptStruct ProjectP.LHelpMateSpotData
// 0x0000 (0x0038 - 0x0038)
struct FLHelpMateSpotData final : public FLPropSpotData
{
};
static_assert(alignof(FLHelpMateSpotData) == 0x000008, "Wrong alignment on FLHelpMateSpotData");
static_assert(sizeof(FLHelpMateSpotData) == 0x000038, "Wrong size on FLHelpMateSpotData");

// ScriptStruct ProjectP.LProjectileSpotData
// 0x0000 (0x0038 - 0x0038)
struct FLProjectileSpotData final : public FLPropSpotData
{
};
static_assert(alignof(FLProjectileSpotData) == 0x000008, "Wrong alignment on FLProjectileSpotData");
static_assert(sizeof(FLProjectileSpotData) == 0x000038, "Wrong size on FLProjectileSpotData");

// ScriptStruct ProjectP.LLevelSequenceSpotData
// 0x0008 (0x0040 - 0x0038)
struct FLLevelSequenceSpotData final : public FLPropSpotData
{
public:
	bool                                          IsPlayed;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayReverse;                                     // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTogglePlay;                                      // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLevelSequenceSpotData) == 0x000008, "Wrong alignment on FLLevelSequenceSpotData");
static_assert(sizeof(FLLevelSequenceSpotData) == 0x000040, "Wrong size on FLLevelSequenceSpotData");
static_assert(offsetof(FLLevelSequenceSpotData, IsPlayed) == 0x000038, "Member 'FLLevelSequenceSpotData::IsPlayed' has a wrong offset!");
static_assert(offsetof(FLLevelSequenceSpotData, IsPlayReverse) == 0x000039, "Member 'FLLevelSequenceSpotData::IsPlayReverse' has a wrong offset!");
static_assert(offsetof(FLLevelSequenceSpotData, IsTogglePlay) == 0x00003A, "Member 'FLLevelSequenceSpotData::IsTogglePlay' has a wrong offset!");

// ScriptStruct ProjectP.LDestructionSpotData
// 0x0010 (0x0048 - 0x0038)
struct FLDestructionSpotData final : public FLPropSpotData
{
public:
	class FName                                   DestructionCodeName;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestructionObjectCrashed;                          // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLDestructionSpotData) == 0x000008, "Wrong alignment on FLDestructionSpotData");
static_assert(sizeof(FLDestructionSpotData) == 0x000048, "Wrong size on FLDestructionSpotData");
static_assert(offsetof(FLDestructionSpotData, DestructionCodeName) == 0x000038, "Member 'FLDestructionSpotData::DestructionCodeName' has a wrong offset!");
static_assert(offsetof(FLDestructionSpotData, DestructionObjectCrashed) == 0x000040, "Member 'FLDestructionSpotData::DestructionObjectCrashed' has a wrong offset!");

// ScriptStruct ProjectP.LLadderSpotData
// 0x0008 (0x0040 - 0x0038)
struct FLLadderSpotData final : public FLPropSpotData
{
public:
	class FName                                   LadderCodeName;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLadderSpotData) == 0x000008, "Wrong alignment on FLLadderSpotData");
static_assert(sizeof(FLLadderSpotData) == 0x000040, "Wrong size on FLLadderSpotData");
static_assert(offsetof(FLLadderSpotData, LadderCodeName) == 0x000038, "Member 'FLLadderSpotData::LadderCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LTeleportObjectSpotData
// 0x0010 (0x0048 - 0x0038)
struct FLTeleportObjectSpotData final : public FLPropSpotData
{
public:
	class FName                                   TeleportObjectCodeName;                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TorsionCoilActivate;                               // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELStargazerType                               StargazerType;                                     // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLTeleportObjectSpotData) == 0x000008, "Wrong alignment on FLTeleportObjectSpotData");
static_assert(sizeof(FLTeleportObjectSpotData) == 0x000048, "Wrong size on FLTeleportObjectSpotData");
static_assert(offsetof(FLTeleportObjectSpotData, TeleportObjectCodeName) == 0x000038, "Member 'FLTeleportObjectSpotData::TeleportObjectCodeName' has a wrong offset!");
static_assert(offsetof(FLTeleportObjectSpotData, TorsionCoilActivate) == 0x000040, "Member 'FLTeleportObjectSpotData::TorsionCoilActivate' has a wrong offset!");
static_assert(offsetof(FLTeleportObjectSpotData, StargazerType) == 0x000041, "Member 'FLTeleportObjectSpotData::StargazerType' has a wrong offset!");

// ScriptStruct ProjectP.LNpcSpotData
// 0x0068 (0x0098 - 0x0030)
struct FLNpcSpotData final : public FLSpotData
{
public:
	bool                                          IsDeadState;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StolenDropErgo;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsRespawnEnable : 1;                              // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsHideDespawn : 1;                                // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseModifySpawnIdle : 1;                           // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EFactionType                                  Faction;                                           // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SwapNpcIndex;                                      // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bExecuteWakeUp : 1;                                // 0x003B(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bExecuteFloatingStop : 1;                          // 0x003B(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            PartsItemDropCount;                                // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	class FName                                   ModifySpawnIdleCodeName;                           // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNpcSpotData) == 0x000008, "Wrong alignment on FLNpcSpotData");
static_assert(sizeof(FLNpcSpotData) == 0x000098, "Wrong size on FLNpcSpotData");
static_assert(offsetof(FLNpcSpotData, IsDeadState) == 0x000030, "Member 'FLNpcSpotData::IsDeadState' has a wrong offset!");
static_assert(offsetof(FLNpcSpotData, StolenDropErgo) == 0x000034, "Member 'FLNpcSpotData::StolenDropErgo' has a wrong offset!");
static_assert(offsetof(FLNpcSpotData, Faction) == 0x000039, "Member 'FLNpcSpotData::Faction' has a wrong offset!");
static_assert(offsetof(FLNpcSpotData, SwapNpcIndex) == 0x00003A, "Member 'FLNpcSpotData::SwapNpcIndex' has a wrong offset!");
static_assert(offsetof(FLNpcSpotData, PartsItemDropCount) == 0x000040, "Member 'FLNpcSpotData::PartsItemDropCount' has a wrong offset!");
static_assert(offsetof(FLNpcSpotData, ModifySpawnIdleCodeName) == 0x000090, "Member 'FLNpcSpotData::ModifySpawnIdleCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LQuestHierarchyInfo
// 0x0058 (0x0058 - 0x0000)
struct FLQuestHierarchyInfo final
{
public:
	struct FQuestDescInfoPtr                      DescInfo;                                          // 0x0000(0x0008)(NoDestructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FQuestStepInfoPtr>         SetpInfoMap;                                       // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLQuestHierarchyInfo) == 0x000008, "Wrong alignment on FLQuestHierarchyInfo");
static_assert(sizeof(FLQuestHierarchyInfo) == 0x000058, "Wrong size on FLQuestHierarchyInfo");
static_assert(offsetof(FLQuestHierarchyInfo, DescInfo) == 0x000000, "Member 'FLQuestHierarchyInfo::DescInfo' has a wrong offset!");
static_assert(offsetof(FLQuestHierarchyInfo, SetpInfoMap) == 0x000008, "Member 'FLQuestHierarchyInfo::SetpInfoMap' has a wrong offset!");

// ScriptStruct ProjectP.LCustomizedInput
// 0x0020 (0x0020 - 0x0000)
struct FLCustomizedInput final
{
public:
	class FName                                   InputAction;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCustomizedInput) == 0x000008, "Wrong alignment on FLCustomizedInput");
static_assert(sizeof(FLCustomizedInput) == 0x000020, "Wrong size on FLCustomizedInput");
static_assert(offsetof(FLCustomizedInput, InputAction) == 0x000000, "Member 'FLCustomizedInput::InputAction' has a wrong offset!");
static_assert(offsetof(FLCustomizedInput, Key) == 0x000008, "Member 'FLCustomizedInput::Key' has a wrong offset!");

// ScriptStruct ProjectP.LCustomizedInputInfo
// 0x0010 (0x0010 - 0x0000)
struct FLCustomizedInputInfo final
{
public:
	TArray<struct FLCustomizedInput>              CustomizedInputArray;                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCustomizedInputInfo) == 0x000008, "Wrong alignment on FLCustomizedInputInfo");
static_assert(sizeof(FLCustomizedInputInfo) == 0x000010, "Wrong size on FLCustomizedInputInfo");
static_assert(offsetof(FLCustomizedInputInfo, CustomizedInputArray) == 0x000000, "Member 'FLCustomizedInputInfo::CustomizedInputArray' has a wrong offset!");

// ScriptStruct ProjectP.LOptionData
// 0x00B8 (0x00B8 - 0x0000)
struct FLOptionData final
{
public:
	bool                                          UseAutoTargeting;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAutoNewTargetLockOn;                            // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentLockOnImportanceStep;                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableTutorial : 1;                               // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HUDVisibility;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableBlood : 1;                                  // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableVideoSubtitle : 1;                          // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          DirectLockOnDash;                                  // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultFontSize;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VerticalCameraSpeedIdx_GamePad;                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HorizontalCameraSpeedIdx_GamePad;                  // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VerticalCameraSpeedIdx_Keyboard;                   // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HorizontalCameraSpeedIdx_Keyboard;                 // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VerticalCameraInvert_GamePad;                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HorizontalCameraInvert_GamePad;                    // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VerticalCameraInvert_Keyboard;                     // 0x002A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HorizontalCameraInvert_Keyboard;                   // 0x002B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableMoveCameraUpDown : 1;                       // 0x002C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableAlignmentToCamera : 1;                      // 0x002C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableCameraShake : 1;                            // 0x002C(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          EnableAutoCameraRotate;                            // 0x002D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MotionBlurEnabled;                                 // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MasterVolumeIdx;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BGMVolumeIdx;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmbienceVolumeIdx;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterVolumeIdx;                                // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CinematicsVolumeIdx;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SystemVolumeIdx;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoicVolumeIdx;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFristLanguageSetting;                             // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFristBrightnessSetting;                           // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirstAutoSaveAlert;                               // 0x0062(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ForceFeedbackStep;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeadZoneStep_L;                                    // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DeadZoneStep_R;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KeyboardInputPresetName;                           // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GamepadInputPresetName;                            // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLCustomizedInputInfo                  CustomizedInputInfo;                               // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLCustomizedInputInfo                  CustomizedInputInfo_Keyboard;                      // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLCustomizedInputInfo                  CustomizedInputInfo_Gamepad;                       // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	int32                                         MouseSensitivityStep;                              // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLOptionData) == 0x000008, "Wrong alignment on FLOptionData");
static_assert(sizeof(FLOptionData) == 0x0000B8, "Wrong size on FLOptionData");
static_assert(offsetof(FLOptionData, UseAutoTargeting) == 0x000000, "Member 'FLOptionData::UseAutoTargeting' has a wrong offset!");
static_assert(offsetof(FLOptionData, UseAutoNewTargetLockOn) == 0x000001, "Member 'FLOptionData::UseAutoNewTargetLockOn' has a wrong offset!");
static_assert(offsetof(FLOptionData, CurrentLockOnImportanceStep) == 0x000004, "Member 'FLOptionData::CurrentLockOnImportanceStep' has a wrong offset!");
static_assert(offsetof(FLOptionData, HUDVisibility) == 0x00000C, "Member 'FLOptionData::HUDVisibility' has a wrong offset!");
static_assert(offsetof(FLOptionData, DirectLockOnDash) == 0x000011, "Member 'FLOptionData::DirectLockOnDash' has a wrong offset!");
static_assert(offsetof(FLOptionData, DefaultFontSize) == 0x000014, "Member 'FLOptionData::DefaultFontSize' has a wrong offset!");
static_assert(offsetof(FLOptionData, VerticalCameraSpeedIdx_GamePad) == 0x000018, "Member 'FLOptionData::VerticalCameraSpeedIdx_GamePad' has a wrong offset!");
static_assert(offsetof(FLOptionData, HorizontalCameraSpeedIdx_GamePad) == 0x00001C, "Member 'FLOptionData::HorizontalCameraSpeedIdx_GamePad' has a wrong offset!");
static_assert(offsetof(FLOptionData, VerticalCameraSpeedIdx_Keyboard) == 0x000020, "Member 'FLOptionData::VerticalCameraSpeedIdx_Keyboard' has a wrong offset!");
static_assert(offsetof(FLOptionData, HorizontalCameraSpeedIdx_Keyboard) == 0x000024, "Member 'FLOptionData::HorizontalCameraSpeedIdx_Keyboard' has a wrong offset!");
static_assert(offsetof(FLOptionData, VerticalCameraInvert_GamePad) == 0x000028, "Member 'FLOptionData::VerticalCameraInvert_GamePad' has a wrong offset!");
static_assert(offsetof(FLOptionData, HorizontalCameraInvert_GamePad) == 0x000029, "Member 'FLOptionData::HorizontalCameraInvert_GamePad' has a wrong offset!");
static_assert(offsetof(FLOptionData, VerticalCameraInvert_Keyboard) == 0x00002A, "Member 'FLOptionData::VerticalCameraInvert_Keyboard' has a wrong offset!");
static_assert(offsetof(FLOptionData, HorizontalCameraInvert_Keyboard) == 0x00002B, "Member 'FLOptionData::HorizontalCameraInvert_Keyboard' has a wrong offset!");
static_assert(offsetof(FLOptionData, EnableAutoCameraRotate) == 0x00002D, "Member 'FLOptionData::EnableAutoCameraRotate' has a wrong offset!");
static_assert(offsetof(FLOptionData, Language) == 0x000030, "Member 'FLOptionData::Language' has a wrong offset!");
static_assert(offsetof(FLOptionData, MotionBlurEnabled) == 0x000040, "Member 'FLOptionData::MotionBlurEnabled' has a wrong offset!");
static_assert(offsetof(FLOptionData, MasterVolumeIdx) == 0x000044, "Member 'FLOptionData::MasterVolumeIdx' has a wrong offset!");
static_assert(offsetof(FLOptionData, BGMVolumeIdx) == 0x000048, "Member 'FLOptionData::BGMVolumeIdx' has a wrong offset!");
static_assert(offsetof(FLOptionData, AmbienceVolumeIdx) == 0x00004C, "Member 'FLOptionData::AmbienceVolumeIdx' has a wrong offset!");
static_assert(offsetof(FLOptionData, CharacterVolumeIdx) == 0x000050, "Member 'FLOptionData::CharacterVolumeIdx' has a wrong offset!");
static_assert(offsetof(FLOptionData, CinematicsVolumeIdx) == 0x000054, "Member 'FLOptionData::CinematicsVolumeIdx' has a wrong offset!");
static_assert(offsetof(FLOptionData, SystemVolumeIdx) == 0x000058, "Member 'FLOptionData::SystemVolumeIdx' has a wrong offset!");
static_assert(offsetof(FLOptionData, VoicVolumeIdx) == 0x00005C, "Member 'FLOptionData::VoicVolumeIdx' has a wrong offset!");
static_assert(offsetof(FLOptionData, bFristLanguageSetting) == 0x000060, "Member 'FLOptionData::bFristLanguageSetting' has a wrong offset!");
static_assert(offsetof(FLOptionData, bFristBrightnessSetting) == 0x000061, "Member 'FLOptionData::bFristBrightnessSetting' has a wrong offset!");
static_assert(offsetof(FLOptionData, bFirstAutoSaveAlert) == 0x000062, "Member 'FLOptionData::bFirstAutoSaveAlert' has a wrong offset!");
static_assert(offsetof(FLOptionData, ForceFeedbackStep) == 0x000064, "Member 'FLOptionData::ForceFeedbackStep' has a wrong offset!");
static_assert(offsetof(FLOptionData, DeadZoneStep_L) == 0x000068, "Member 'FLOptionData::DeadZoneStep_L' has a wrong offset!");
static_assert(offsetof(FLOptionData, DeadZoneStep_R) == 0x00006C, "Member 'FLOptionData::DeadZoneStep_R' has a wrong offset!");
static_assert(offsetof(FLOptionData, KeyboardInputPresetName) == 0x000070, "Member 'FLOptionData::KeyboardInputPresetName' has a wrong offset!");
static_assert(offsetof(FLOptionData, GamepadInputPresetName) == 0x000078, "Member 'FLOptionData::GamepadInputPresetName' has a wrong offset!");
static_assert(offsetof(FLOptionData, CustomizedInputInfo) == 0x000080, "Member 'FLOptionData::CustomizedInputInfo' has a wrong offset!");
static_assert(offsetof(FLOptionData, CustomizedInputInfo_Keyboard) == 0x000090, "Member 'FLOptionData::CustomizedInputInfo_Keyboard' has a wrong offset!");
static_assert(offsetof(FLOptionData, CustomizedInputInfo_Gamepad) == 0x0000A0, "Member 'FLOptionData::CustomizedInputInfo_Gamepad' has a wrong offset!");
static_assert(offsetof(FLOptionData, MouseSensitivityStep) == 0x0000B0, "Member 'FLOptionData::MouseSensitivityStep' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileHitInfo
// 0x0090 (0x0090 - 0x0000)
struct FLProjectileHitInfo final
{
public:
	class FName                                   SkillHitCodeName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileHitGenerateEnumType                HitGenerateType;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillHitCollisionProfile;                          // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialStartDelay;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitCollisionCheckType                       CollisionType;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Capsule_Radius;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Capsule_Length;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sphere_Radius;                                     // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Box_Extend;                                        // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cylinder_Max_Distance;                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cylinder_Min_Distance;                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cylinder_Height;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitTraceDistance;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0050(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsUniqueSkillHit;                                  // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UniqueSkillHitIgnoreTime;                          // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLProjectileHitInfo) == 0x000010, "Wrong alignment on FLProjectileHitInfo");
static_assert(sizeof(FLProjectileHitInfo) == 0x000090, "Wrong size on FLProjectileHitInfo");
static_assert(offsetof(FLProjectileHitInfo, SkillHitCodeName) == 0x000000, "Member 'FLProjectileHitInfo::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, HitGenerateType) == 0x000008, "Member 'FLProjectileHitInfo::HitGenerateType' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, SkillHitCollisionProfile) == 0x00000C, "Member 'FLProjectileHitInfo::SkillHitCollisionProfile' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, InitialStartDelay) == 0x000014, "Member 'FLProjectileHitInfo::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Interval) == 0x000018, "Member 'FLProjectileHitInfo::Interval' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, MaxCount) == 0x00001C, "Member 'FLProjectileHitInfo::MaxCount' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, CollisionType) == 0x000020, "Member 'FLProjectileHitInfo::CollisionType' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Capsule_Radius) == 0x000024, "Member 'FLProjectileHitInfo::Capsule_Radius' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Capsule_Length) == 0x000028, "Member 'FLProjectileHitInfo::Capsule_Length' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Sphere_Radius) == 0x00002C, "Member 'FLProjectileHitInfo::Sphere_Radius' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Box_Extend) == 0x000030, "Member 'FLProjectileHitInfo::Box_Extend' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Cylinder_Max_Distance) == 0x00003C, "Member 'FLProjectileHitInfo::Cylinder_Max_Distance' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Cylinder_Min_Distance) == 0x000040, "Member 'FLProjectileHitInfo::Cylinder_Min_Distance' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Cylinder_Height) == 0x000044, "Member 'FLProjectileHitInfo::Cylinder_Height' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, HitTraceDistance) == 0x000048, "Member 'FLProjectileHitInfo::HitTraceDistance' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, Offset) == 0x000050, "Member 'FLProjectileHitInfo::Offset' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, IsUniqueSkillHit) == 0x000080, "Member 'FLProjectileHitInfo::IsUniqueSkillHit' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo, UniqueSkillHitIgnoreTime) == 0x000084, "Member 'FLProjectileHitInfo::UniqueSkillHitIgnoreTime' has a wrong offset!");

// ScriptStruct ProjectP.LUseItemSlotData
// 0x0014 (0x0014 - 0x0000)
struct FLUseItemSlotData final
{
public:
	bool                                          IsSlotFirstLine;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemCodeName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlock;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLUseItemSlotData) == 0x000004, "Wrong alignment on FLUseItemSlotData");
static_assert(sizeof(FLUseItemSlotData) == 0x000014, "Wrong size on FLUseItemSlotData");
static_assert(offsetof(FLUseItemSlotData, IsSlotFirstLine) == 0x000000, "Member 'FLUseItemSlotData::IsSlotFirstLine' has a wrong offset!");
static_assert(offsetof(FLUseItemSlotData, SlotIndex) == 0x000004, "Member 'FLUseItemSlotData::SlotIndex' has a wrong offset!");
static_assert(offsetof(FLUseItemSlotData, ItemCodeName) == 0x000008, "Member 'FLUseItemSlotData::ItemCodeName' has a wrong offset!");
static_assert(offsetof(FLUseItemSlotData, bUnlock) == 0x000010, "Member 'FLUseItemSlotData::bUnlock' has a wrong offset!");

// ScriptStruct ProjectP.LUseItemSlotsData
// 0x0028 (0x0028 - 0x0000)
struct FLUseItemSlotsData final
{
public:
	bool                                          IsFirstLineSave;                                   // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSecondLineSave;                                  // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLUseItemSlotData>              UseSlots1;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLUseItemSlotData>              UseSlots2;                                         // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLUseItemSlotsData) == 0x000008, "Wrong alignment on FLUseItemSlotsData");
static_assert(sizeof(FLUseItemSlotsData) == 0x000028, "Wrong size on FLUseItemSlotsData");
static_assert(offsetof(FLUseItemSlotsData, IsFirstLineSave) == 0x000000, "Member 'FLUseItemSlotsData::IsFirstLineSave' has a wrong offset!");
static_assert(offsetof(FLUseItemSlotsData, IsSecondLineSave) == 0x000001, "Member 'FLUseItemSlotsData::IsSecondLineSave' has a wrong offset!");
static_assert(offsetof(FLUseItemSlotsData, UseSlots1) == 0x000008, "Member 'FLUseItemSlotsData::UseSlots1' has a wrong offset!");
static_assert(offsetof(FLUseItemSlotsData, UseSlots2) == 0x000018, "Member 'FLUseItemSlotsData::UseSlots2' has a wrong offset!");

// ScriptStruct ProjectP.LAssistUseItemSlotData
// 0x000C (0x000C - 0x0000)
struct FLAssistUseItemSlotData final
{
public:
	ELAssistUseItemSlotType                       SlotType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemCodeName;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAssistUseItemSlotData) == 0x000004, "Wrong alignment on FLAssistUseItemSlotData");
static_assert(sizeof(FLAssistUseItemSlotData) == 0x00000C, "Wrong size on FLAssistUseItemSlotData");
static_assert(offsetof(FLAssistUseItemSlotData, SlotType) == 0x000000, "Member 'FLAssistUseItemSlotData::SlotType' has a wrong offset!");
static_assert(offsetof(FLAssistUseItemSlotData, ItemCodeName) == 0x000004, "Member 'FLAssistUseItemSlotData::ItemCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LAssistUseSlotData
// 0x0058 (0x0058 - 0x0000)
struct FLAssistUseSlotData final
{
public:
	bool                                          IsSave;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELAssistUseItemSlotType, struct FLAssistUseItemSlotData> AssistUseSlots;                                    // 0x0008(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAssistUseSlotData) == 0x000008, "Wrong alignment on FLAssistUseSlotData");
static_assert(sizeof(FLAssistUseSlotData) == 0x000058, "Wrong size on FLAssistUseSlotData");
static_assert(offsetof(FLAssistUseSlotData, IsSave) == 0x000000, "Member 'FLAssistUseSlotData::IsSave' has a wrong offset!");
static_assert(offsetof(FLAssistUseSlotData, AssistUseSlots) == 0x000008, "Member 'FLAssistUseSlotData::AssistUseSlots' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterStorageData
// 0x00C8 (0x00C8 - 0x0000)
struct FLCharacterStorageData final
{
public:
	class FString                                 CharacterName;                                     // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastLocation;                                      // 0x0014(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportObjectName;                                // 0x001C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              UtcDateTime;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CharacterPlayTime;                                 // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewGamePlus;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AfterStarterPack : 1;                              // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SaveIndex;                                         // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlatformActivity;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLUseItemSlotsData                     UseSlotData;                                       // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	struct FLAssistUseSlotData                    AssistUseSlot;                                     // 0x0070(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCharacterStorageData) == 0x000008, "Wrong alignment on FLCharacterStorageData");
static_assert(sizeof(FLCharacterStorageData) == 0x0000C8, "Wrong size on FLCharacterStorageData");
static_assert(offsetof(FLCharacterStorageData, CharacterName) == 0x000000, "Member 'FLCharacterStorageData::CharacterName' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, CharacterLevel) == 0x000010, "Member 'FLCharacterStorageData::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, LastLocation) == 0x000014, "Member 'FLCharacterStorageData::LastLocation' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, TeleportObjectName) == 0x00001C, "Member 'FLCharacterStorageData::TeleportObjectName' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, UtcDateTime) == 0x000028, "Member 'FLCharacterStorageData::UtcDateTime' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, CharacterPlayTime) == 0x000030, "Member 'FLCharacterStorageData::CharacterPlayTime' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, NewGamePlus) == 0x000038, "Member 'FLCharacterStorageData::NewGamePlus' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, SaveIndex) == 0x00003D, "Member 'FLCharacterStorageData::SaveIndex' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, PlatformActivity) == 0x000040, "Member 'FLCharacterStorageData::PlatformActivity' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, UseSlotData) == 0x000048, "Member 'FLCharacterStorageData::UseSlotData' has a wrong offset!");
static_assert(offsetof(FLCharacterStorageData, AssistUseSlot) == 0x000070, "Member 'FLCharacterStorageData::AssistUseSlot' has a wrong offset!");

// ScriptStruct ProjectP.LRigUnit_FootTraceWorld
// 0x0030 (0x0098 - 0x0068)
struct FLRigUnit_FootTraceWorld final : public FRigUnit_HighlevelBaseMutable
{
public:
	struct FRigElementKey                         Item;                                              // 0x0068(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TraceAboveDistance;                                // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TraceBelowDistance;                                // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x007C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x007D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0080(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x008C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLRigUnit_FootTraceWorld) == 0x000008, "Wrong alignment on FLRigUnit_FootTraceWorld");
static_assert(sizeof(FLRigUnit_FootTraceWorld) == 0x000098, "Wrong size on FLRigUnit_FootTraceWorld");
static_assert(offsetof(FLRigUnit_FootTraceWorld, Item) == 0x000068, "Member 'FLRigUnit_FootTraceWorld::Item' has a wrong offset!");
static_assert(offsetof(FLRigUnit_FootTraceWorld, TraceAboveDistance) == 0x000074, "Member 'FLRigUnit_FootTraceWorld::TraceAboveDistance' has a wrong offset!");
static_assert(offsetof(FLRigUnit_FootTraceWorld, TraceBelowDistance) == 0x000078, "Member 'FLRigUnit_FootTraceWorld::TraceBelowDistance' has a wrong offset!");
static_assert(offsetof(FLRigUnit_FootTraceWorld, bDebugDraw) == 0x00007C, "Member 'FLRigUnit_FootTraceWorld::bDebugDraw' has a wrong offset!");
static_assert(offsetof(FLRigUnit_FootTraceWorld, bHit) == 0x00007D, "Member 'FLRigUnit_FootTraceWorld::bHit' has a wrong offset!");
static_assert(offsetof(FLRigUnit_FootTraceWorld, HitLocation) == 0x000080, "Member 'FLRigUnit_FootTraceWorld::HitLocation' has a wrong offset!");
static_assert(offsetof(FLRigUnit_FootTraceWorld, HitNormal) == 0x00008C, "Member 'FLRigUnit_FootTraceWorld::HitNormal' has a wrong offset!");

// ScriptStruct ProjectP.LRepulseFxTableRowType
// 0x00D0 (0x00D8 - 0x0008)
struct FLRepulseFxTableRowType final : public FTableRowBase
{
public:
	ELPhysicalSurfaceType                         Attacker_Material;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Ground_Material;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ColorParameters;                                   // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLRepulseFxTableRowType) == 0x000008, "Wrong alignment on FLRepulseFxTableRowType");
static_assert(sizeof(FLRepulseFxTableRowType) == 0x0000D8, "Wrong size on FLRepulseFxTableRowType");
static_assert(offsetof(FLRepulseFxTableRowType, Attacker_Material) == 0x000008, "Member 'FLRepulseFxTableRowType::Attacker_Material' has a wrong offset!");
static_assert(offsetof(FLRepulseFxTableRowType, Ground_Material) == 0x000009, "Member 'FLRepulseFxTableRowType::Ground_Material' has a wrong offset!");
static_assert(offsetof(FLRepulseFxTableRowType, Niagara) == 0x000010, "Member 'FLRepulseFxTableRowType::Niagara' has a wrong offset!");
static_assert(offsetof(FLRepulseFxTableRowType, ScalarParameters) == 0x000038, "Member 'FLRepulseFxTableRowType::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FLRepulseFxTableRowType, ColorParameters) == 0x000088, "Member 'FLRepulseFxTableRowType::ColorParameters' has a wrong offset!");

// ScriptStruct ProjectP.LDLCSaveData_Account
// 0x0050 (0x0050 - 0x0000)
struct FLDLCSaveData_Account final
{
public:
	TMap<class FString, class FName>              AppliedDLCs;                                       // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDLCSaveData_Account) == 0x000008, "Wrong alignment on FLDLCSaveData_Account");
static_assert(sizeof(FLDLCSaveData_Account) == 0x000050, "Wrong size on FLDLCSaveData_Account");
static_assert(offsetof(FLDLCSaveData_Account, AppliedDLCs) == 0x000000, "Member 'FLDLCSaveData_Account::AppliedDLCs' has a wrong offset!");

// ScriptStruct ProjectP.LAccountData
// 0x0048 (0x0048 - 0x0000)
struct FLAccountData final
{
public:
	class FString                                 AccountName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastPlayCharacterName;                             // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        AccountPlayTime;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsNormalShutDown : 1;                             // 0x0028(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EULA_Version;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bShowEndingCredit : 1;                             // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOpenedRecollection : 1;                           // 0x0040(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SaveIndex;                                         // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAccountData) == 0x000008, "Wrong alignment on FLAccountData");
static_assert(sizeof(FLAccountData) == 0x000048, "Wrong size on FLAccountData");
static_assert(offsetof(FLAccountData, AccountName) == 0x000000, "Member 'FLAccountData::AccountName' has a wrong offset!");
static_assert(offsetof(FLAccountData, LastPlayCharacterName) == 0x000010, "Member 'FLAccountData::LastPlayCharacterName' has a wrong offset!");
static_assert(offsetof(FLAccountData, AccountPlayTime) == 0x000020, "Member 'FLAccountData::AccountPlayTime' has a wrong offset!");
static_assert(offsetof(FLAccountData, EULA_Version) == 0x000030, "Member 'FLAccountData::EULA_Version' has a wrong offset!");
static_assert(offsetof(FLAccountData, SaveIndex) == 0x000041, "Member 'FLAccountData::SaveIndex' has a wrong offset!");

// ScriptStruct ProjectP.LExiledNpcData
// 0x0010 (0x0010 - 0x0000)
struct FLExiledNpcData final
{
public:
	TArray<struct FExiledNpcContext>              ExiledNpcContextArray;                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLExiledNpcData) == 0x000008, "Wrong alignment on FLExiledNpcData");
static_assert(sizeof(FLExiledNpcData) == 0x000010, "Wrong size on FLExiledNpcData");
static_assert(offsetof(FLExiledNpcData, ExiledNpcContextArray) == 0x000000, "Member 'FLExiledNpcData::ExiledNpcContextArray' has a wrong offset!");

// ScriptStruct ProjectP.LCommonActionMontageInfo
// 0x0028 (0x0028 - 0x0000)
struct FLCommonActionMontageInfo final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Base;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Replace;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndCommonAnimCodeName;                             // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideMontageBlendIn;                            // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCommonActionMontageInfo) == 0x000008, "Wrong alignment on FLCommonActionMontageInfo");
static_assert(sizeof(FLCommonActionMontageInfo) == 0x000028, "Wrong size on FLCommonActionMontageInfo");
static_assert(offsetof(FLCommonActionMontageInfo, CodeName) == 0x000000, "Member 'FLCommonActionMontageInfo::CodeName' has a wrong offset!");
static_assert(offsetof(FLCommonActionMontageInfo, Base) == 0x000008, "Member 'FLCommonActionMontageInfo::Base' has a wrong offset!");
static_assert(offsetof(FLCommonActionMontageInfo, Replace) == 0x000010, "Member 'FLCommonActionMontageInfo::Replace' has a wrong offset!");
static_assert(offsetof(FLCommonActionMontageInfo, EndCommonAnimCodeName) == 0x000018, "Member 'FLCommonActionMontageInfo::EndCommonAnimCodeName' has a wrong offset!");
static_assert(offsetof(FLCommonActionMontageInfo, OverrideMontageBlendIn) == 0x000020, "Member 'FLCommonActionMontageInfo::OverrideMontageBlendIn' has a wrong offset!");

// ScriptStruct ProjectP.LCommonMotionInfo
// 0x0010 (0x0010 - 0x0000)
struct FLCommonMotionInfo final
{
public:
	class UAnimMontage*                           Die;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           UseItem;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCommonMotionInfo) == 0x000008, "Wrong alignment on FLCommonMotionInfo");
static_assert(sizeof(FLCommonMotionInfo) == 0x000010, "Wrong size on FLCommonMotionInfo");
static_assert(offsetof(FLCommonMotionInfo, Die) == 0x000000, "Member 'FLCommonMotionInfo::Die' has a wrong offset!");
static_assert(offsetof(FLCommonMotionInfo, UseItem) == 0x000008, "Member 'FLCommonMotionInfo::UseItem' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileAbnormalApplyInRangeInfo
// 0x0018 (0x0018 - 0x0000)
struct FLProjectileAbnormalApplyInRangeInfo final
{
public:
	class FName                                   AbnormalStateCodeName;                             // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalStartDelay;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalEndDelay;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELProjectileHitFactionType                    ApplyFaction;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLProjectileAbnormalApplyInRangeInfo) == 0x000004, "Wrong alignment on FLProjectileAbnormalApplyInRangeInfo");
static_assert(sizeof(FLProjectileAbnormalApplyInRangeInfo) == 0x000018, "Wrong size on FLProjectileAbnormalApplyInRangeInfo");
static_assert(offsetof(FLProjectileAbnormalApplyInRangeInfo, AbnormalStateCodeName) == 0x000000, "Member 'FLProjectileAbnormalApplyInRangeInfo::AbnormalStateCodeName' has a wrong offset!");
static_assert(offsetof(FLProjectileAbnormalApplyInRangeInfo, Radius) == 0x000008, "Member 'FLProjectileAbnormalApplyInRangeInfo::Radius' has a wrong offset!");
static_assert(offsetof(FLProjectileAbnormalApplyInRangeInfo, IntervalStartDelay) == 0x00000C, "Member 'FLProjectileAbnormalApplyInRangeInfo::IntervalStartDelay' has a wrong offset!");
static_assert(offsetof(FLProjectileAbnormalApplyInRangeInfo, IntervalEndDelay) == 0x000010, "Member 'FLProjectileAbnormalApplyInRangeInfo::IntervalEndDelay' has a wrong offset!");
static_assert(offsetof(FLProjectileAbnormalApplyInRangeInfo, ApplyFaction) == 0x000014, "Member 'FLProjectileAbnormalApplyInRangeInfo::ApplyFaction' has a wrong offset!");

// ScriptStruct ProjectP.PNPlayerData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FPNPlayerData final
{
public:
	float                                         MoveSpeed;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveDirection;                                     // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMovableFocused;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FocusedActor;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusedLength;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusedMoveDegree;                                 // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StaminaSprintStatus;                               // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StaminaSprintAmount;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPNPlayerData) == 0x000010, "Wrong alignment on FPNPlayerData");
static_assert(sizeof(FPNPlayerData) == 0x000080, "Wrong size on FPNPlayerData");
static_assert(offsetof(FPNPlayerData, MoveSpeed) == 0x000000, "Member 'FPNPlayerData::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FPNPlayerData, MoveDirection) == 0x000004, "Member 'FPNPlayerData::MoveDirection' has a wrong offset!");
static_assert(offsetof(FPNPlayerData, IsMovableFocused) == 0x000010, "Member 'FPNPlayerData::IsMovableFocused' has a wrong offset!");
static_assert(offsetof(FPNPlayerData, FocusedActor) == 0x000018, "Member 'FPNPlayerData::FocusedActor' has a wrong offset!");
static_assert(offsetof(FPNPlayerData, FocusedLength) == 0x000020, "Member 'FPNPlayerData::FocusedLength' has a wrong offset!");
static_assert(offsetof(FPNPlayerData, FocusedMoveDegree) == 0x000024, "Member 'FPNPlayerData::FocusedMoveDegree' has a wrong offset!");
static_assert(offsetof(FPNPlayerData, StaminaSprintStatus) == 0x000028, "Member 'FPNPlayerData::StaminaSprintStatus' has a wrong offset!");
static_assert(offsetof(FPNPlayerData, StaminaSprintAmount) == 0x00002C, "Member 'FPNPlayerData::StaminaSprintAmount' has a wrong offset!");

// ScriptStruct ProjectP.LSecondStatDiffData
// 0x000C (0x000C - 0x0000)
struct FLSecondStatDiffData final
{
public:
	ELSecondStat                                  StatType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StatData;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffData;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSecondStatDiffData) == 0x000004, "Wrong alignment on FLSecondStatDiffData");
static_assert(sizeof(FLSecondStatDiffData) == 0x00000C, "Wrong size on FLSecondStatDiffData");
static_assert(offsetof(FLSecondStatDiffData, StatType) == 0x000000, "Member 'FLSecondStatDiffData::StatType' has a wrong offset!");
static_assert(offsetof(FLSecondStatDiffData, StatData) == 0x000004, "Member 'FLSecondStatDiffData::StatData' has a wrong offset!");
static_assert(offsetof(FLSecondStatDiffData, DiffData) == 0x000008, "Member 'FLSecondStatDiffData::DiffData' has a wrong offset!");

// ScriptStruct ProjectP.EventDetailInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEventDetailInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventDetailInfo) == 0x000008, "Wrong alignment on FEventDetailInfo");
static_assert(sizeof(FEventDetailInfo) == 0x000010, "Wrong size on FEventDetailInfo");

// ScriptStruct ProjectP.EventDetailInfoList
// 0x0010 (0x0010 - 0x0000)
struct FEventDetailInfoList final
{
public:
	TArray<struct FEventDetailInfo>               Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventDetailInfoList) == 0x000008, "Wrong alignment on FEventDetailInfoList");
static_assert(sizeof(FEventDetailInfoList) == 0x000010, "Wrong size on FEventDetailInfoList");
static_assert(offsetof(FEventDetailInfoList, Items) == 0x000000, "Member 'FEventDetailInfoList::Items' has a wrong offset!");

// ScriptStruct ProjectP.LStatSimpleData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FLStatSimpleData
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELSecondStat                                  StatType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Value_ForCheat;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAppliedCheat;                                     // 0x0014(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLStatSimpleData) == 0x000008, "Wrong alignment on FLStatSimpleData");
static_assert(sizeof(FLStatSimpleData) == 0x000018, "Wrong size on FLStatSimpleData");
static_assert(offsetof(FLStatSimpleData, StatType) == 0x000008, "Member 'FLStatSimpleData::StatType' has a wrong offset!");
static_assert(offsetof(FLStatSimpleData, Value) == 0x00000C, "Member 'FLStatSimpleData::Value' has a wrong offset!");
static_assert(offsetof(FLStatSimpleData, Value_ForCheat) == 0x000010, "Member 'FLStatSimpleData::Value_ForCheat' has a wrong offset!");
static_assert(offsetof(FLStatSimpleData, bAppliedCheat) == 0x000014, "Member 'FLStatSimpleData::bAppliedCheat' has a wrong offset!");

// ScriptStruct ProjectP.LPatchRewardSaveData_Account
// 0x0050 (0x0050 - 0x0000)
struct FLPatchRewardSaveData_Account final
{
public:
	TMap<class FString, class FName>              AppliedPatchRewards;                               // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPatchRewardSaveData_Account) == 0x000008, "Wrong alignment on FLPatchRewardSaveData_Account");
static_assert(sizeof(FLPatchRewardSaveData_Account) == 0x000050, "Wrong size on FLPatchRewardSaveData_Account");
static_assert(offsetof(FLPatchRewardSaveData_Account, AppliedPatchRewards) == 0x000000, "Member 'FLPatchRewardSaveData_Account::AppliedPatchRewards' has a wrong offset!");

// ScriptStruct ProjectP.LStatData
// 0x0018 (0x0030 - 0x0018)
struct FLStatData final : public FLStatSimpleData
{
public:
	uint8                                         Pad_18[0x18];                                      // 0x0018(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLStatData) == 0x000008, "Wrong alignment on FLStatData");
static_assert(sizeof(FLStatData) == 0x000030, "Wrong size on FLStatData");

// ScriptStruct ProjectP.LNestedNameState
// 0x0010 (0x0010 - 0x0000)
struct FLNestedNameState final
{
public:
	TArray<class FName>                           StateNames;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLNestedNameState) == 0x000008, "Wrong alignment on FLNestedNameState");
static_assert(sizeof(FLNestedNameState) == 0x000010, "Wrong size on FLNestedNameState");
static_assert(offsetof(FLNestedNameState, StateNames) == 0x000000, "Member 'FLNestedNameState::StateNames' has a wrong offset!");

// ScriptStruct ProjectP.LStatGaugeContext
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FLStatGaugeContext final
{
public:
	uint8                                         Pad_0[0x15];                                       // 0x0000(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	ELSecondStat                                  StatType;                                          // 0x0015(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLStatGaugeContext) == 0x000004, "Wrong alignment on FLStatGaugeContext");
static_assert(sizeof(FLStatGaugeContext) == 0x000018, "Wrong size on FLStatGaugeContext");
static_assert(offsetof(FLStatGaugeContext, StatType) == 0x000015, "Member 'FLStatGaugeContext::StatType' has a wrong offset!");

// ScriptStruct ProjectP.LGameDataExecute
// 0x0003 (0x0003 - 0x0000)
struct FLGameDataExecute final
{
public:
	uint8                                         Pad_0[0x3];                                        // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLGameDataExecute) == 0x000001, "Wrong alignment on FLGameDataExecute");
static_assert(sizeof(FLGameDataExecute) == 0x000003, "Wrong size on FLGameDataExecute");

// ScriptStruct ProjectP.LLinkedNpcSpot
// 0x0018 (0x0018 - 0x0000)
struct FLLinkedNpcSpot final
{
public:
	class ALNPCSpot*                              LinkedNpcSpotRef;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLNpcSpotWakeUpData                    WakeUpData;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ELLinkedPropExecuteType                       PropExecuteTiming;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELLinkedNpcSpotExecuteType                    NpcExecuteType;                                    // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLinkedNpcSpot) == 0x000008, "Wrong alignment on FLLinkedNpcSpot");
static_assert(sizeof(FLLinkedNpcSpot) == 0x000018, "Wrong size on FLLinkedNpcSpot");
static_assert(offsetof(FLLinkedNpcSpot, LinkedNpcSpotRef) == 0x000000, "Member 'FLLinkedNpcSpot::LinkedNpcSpotRef' has a wrong offset!");
static_assert(offsetof(FLLinkedNpcSpot, WakeUpData) == 0x000008, "Member 'FLLinkedNpcSpot::WakeUpData' has a wrong offset!");
static_assert(offsetof(FLLinkedNpcSpot, PropExecuteTiming) == 0x000010, "Member 'FLLinkedNpcSpot::PropExecuteTiming' has a wrong offset!");
static_assert(offsetof(FLLinkedNpcSpot, NpcExecuteType) == 0x000011, "Member 'FLLinkedNpcSpot::NpcExecuteType' has a wrong offset!");

// ScriptStruct ProjectP.LSpotStorage
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLSpotStorage final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSpotStorage) == 0x000008, "Wrong alignment on FLSpotStorage");
static_assert(sizeof(FLSpotStorage) == 0x000050, "Wrong size on FLSpotStorage");

// ScriptStruct ProjectP.LHitFxTable
// 0x0008 (0x0008 - 0x0000)
struct FLHitFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLHitFxTable) == 0x000008, "Wrong alignment on FLHitFxTable");
static_assert(sizeof(FLHitFxTable) == 0x000008, "Wrong size on FLHitFxTable");
static_assert(offsetof(FLHitFxTable, Table) == 0x000000, "Member 'FLHitFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LNiagaraWithParameters
// 0x00D0 (0x00D0 - 0x0000)
struct FLNiagaraWithParameters final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ColorParameters;                                   // 0x0078(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   SocketToAttach;                                    // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNiagaraWithParameters) == 0x000008, "Wrong alignment on FLNiagaraWithParameters");
static_assert(sizeof(FLNiagaraWithParameters) == 0x0000D0, "Wrong size on FLNiagaraWithParameters");
static_assert(offsetof(FLNiagaraWithParameters, Niagara) == 0x000000, "Member 'FLNiagaraWithParameters::Niagara' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters, ScalarParameters) == 0x000028, "Member 'FLNiagaraWithParameters::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters, ColorParameters) == 0x000078, "Member 'FLNiagaraWithParameters::ColorParameters' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters, SocketToAttach) == 0x0000C8, "Member 'FLNiagaraWithParameters::SocketToAttach' has a wrong offset!");

// ScriptStruct ProjectP.LHitFxTableRowType
// 0x05A0 (0x05A8 - 0x0008)
struct FLHitFxTableRowType final : public FTableRowBase
{
public:
	ELHitFXType                                   HitFxType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitFX_SecondaryType                         Event;                                             // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Attacker_Material;                                 // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Attribute;                                         // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFxVictimType                                Victim_Type;                                       // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLNiagaraWithParameters                FX_VeryLight;                                      // 0x0018(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLNiagaraWithParameters                FX_Light;                                          // 0x00E8(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLNiagaraWithParameters                FX_Medium;                                         // 0x01B8(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLNiagaraWithParameters                FX_Heavy;                                          // 0x0288(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLNiagaraWithParameters                FX_VeryHeavy;                                      // 0x0358(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          UseElementalPartsHitFX;                            // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasPeriodicEffect;                                 // 0x0429(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42A[0x2];                                      // 0x042A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BodyStainEventName;                                // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLNiagaraWithParameters                FX_Attach_End;                                     // 0x0438(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLFxContentParameter_Scalar> FxParameters_Scalar;                               // 0x0508(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FLFxContentParameter_Color> FxParameters_Color;                                // 0x0558(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLHitFxTableRowType) == 0x000008, "Wrong alignment on FLHitFxTableRowType");
static_assert(sizeof(FLHitFxTableRowType) == 0x0005A8, "Wrong size on FLHitFxTableRowType");
static_assert(offsetof(FLHitFxTableRowType, HitFxType) == 0x000008, "Member 'FLHitFxTableRowType::HitFxType' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, Event) == 0x000009, "Member 'FLHitFxTableRowType::Event' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, Attacker_Material) == 0x00000A, "Member 'FLHitFxTableRowType::Attacker_Material' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, Attribute) == 0x00000C, "Member 'FLHitFxTableRowType::Attribute' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, Victim_Type) == 0x000014, "Member 'FLHitFxTableRowType::Victim_Type' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FX_VeryLight) == 0x000018, "Member 'FLHitFxTableRowType::FX_VeryLight' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FX_Light) == 0x0000E8, "Member 'FLHitFxTableRowType::FX_Light' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FX_Medium) == 0x0001B8, "Member 'FLHitFxTableRowType::FX_Medium' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FX_Heavy) == 0x000288, "Member 'FLHitFxTableRowType::FX_Heavy' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FX_VeryHeavy) == 0x000358, "Member 'FLHitFxTableRowType::FX_VeryHeavy' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, UseElementalPartsHitFX) == 0x000428, "Member 'FLHitFxTableRowType::UseElementalPartsHitFX' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, HasPeriodicEffect) == 0x000429, "Member 'FLHitFxTableRowType::HasPeriodicEffect' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, Duration) == 0x00042C, "Member 'FLHitFxTableRowType::Duration' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, BodyStainEventName) == 0x000430, "Member 'FLHitFxTableRowType::BodyStainEventName' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FX_Attach_End) == 0x000438, "Member 'FLHitFxTableRowType::FX_Attach_End' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FxParameters_Scalar) == 0x000508, "Member 'FLHitFxTableRowType::FxParameters_Scalar' has a wrong offset!");
static_assert(offsetof(FLHitFxTableRowType, FxParameters_Color) == 0x000558, "Member 'FLHitFxTableRowType::FxParameters_Color' has a wrong offset!");

// ScriptStruct ProjectP.LTutorialSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLTutorialSaveData final
{
public:
	TArray<struct FLTutorialDetailInfo>           DetailInfoList;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTutorialSaveData) == 0x000008, "Wrong alignment on FLTutorialSaveData");
static_assert(sizeof(FLTutorialSaveData) == 0x000010, "Wrong size on FLTutorialSaveData");
static_assert(offsetof(FLTutorialSaveData, DetailInfoList) == 0x000000, "Member 'FLTutorialSaveData::DetailInfoList' has a wrong offset!");

// ScriptStruct ProjectP.LHitLevelTable
// 0x0008 (0x0008 - 0x0000)
struct FLHitLevelTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLHitLevelTable) == 0x000008, "Wrong alignment on FLHitLevelTable");
static_assert(sizeof(FLHitLevelTable) == 0x000008, "Wrong size on FLHitLevelTable");
static_assert(offsetof(FLHitLevelTable, Table) == 0x000000, "Member 'FLHitLevelTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LHitLevelTableRow
// 0x0008 (0x0010 - 0x0008)
struct FLHitLevelTableRow final : public FTableRowBase
{
public:
	ELHitLevelTable_Attacker                      Attacker;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitLevelTable_SkillHitType                  SkillHitType;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitLevelTable_SwingPower                    AttackerHitLevel;                                  // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitLevelTable_SwingPower                    SkillHitlevel;                                     // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitLevelTable_SwingPower                    FinalHitLevel;                                     // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLHitLevelTableRow) == 0x000008, "Wrong alignment on FLHitLevelTableRow");
static_assert(sizeof(FLHitLevelTableRow) == 0x000010, "Wrong size on FLHitLevelTableRow");
static_assert(offsetof(FLHitLevelTableRow, Attacker) == 0x000008, "Member 'FLHitLevelTableRow::Attacker' has a wrong offset!");
static_assert(offsetof(FLHitLevelTableRow, SkillHitType) == 0x000009, "Member 'FLHitLevelTableRow::SkillHitType' has a wrong offset!");
static_assert(offsetof(FLHitLevelTableRow, AttackerHitLevel) == 0x00000A, "Member 'FLHitLevelTableRow::AttackerHitLevel' has a wrong offset!");
static_assert(offsetof(FLHitLevelTableRow, SkillHitlevel) == 0x00000B, "Member 'FLHitLevelTableRow::SkillHitlevel' has a wrong offset!");
static_assert(offsetof(FLHitLevelTableRow, FinalHitLevel) == 0x00000C, "Member 'FLHitLevelTableRow::FinalHitLevel' has a wrong offset!");

// ScriptStruct ProjectP.LTest_HitProcOptions
// 0x000C (0x000C - 0x0000)
struct FLTest_HitProcOptions final
{
public:
	bool                                          UseTestPivotToTrace;                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawHitPoint;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugLine;                                     // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseTestPivotToTrace_Repulse;                       // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawHitPoint_Repulse;                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugLine_Repulse;                             // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNotAdvancedSparkTest;                           // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FxSocketHitInterval;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTest_HitProcOptions) == 0x000004, "Wrong alignment on FLTest_HitProcOptions");
static_assert(sizeof(FLTest_HitProcOptions) == 0x00000C, "Wrong size on FLTest_HitProcOptions");
static_assert(offsetof(FLTest_HitProcOptions, UseTestPivotToTrace) == 0x000000, "Member 'FLTest_HitProcOptions::UseTestPivotToTrace' has a wrong offset!");
static_assert(offsetof(FLTest_HitProcOptions, DrawHitPoint) == 0x000001, "Member 'FLTest_HitProcOptions::DrawHitPoint' has a wrong offset!");
static_assert(offsetof(FLTest_HitProcOptions, DrawDebugLine) == 0x000002, "Member 'FLTest_HitProcOptions::DrawDebugLine' has a wrong offset!");
static_assert(offsetof(FLTest_HitProcOptions, UseTestPivotToTrace_Repulse) == 0x000003, "Member 'FLTest_HitProcOptions::UseTestPivotToTrace_Repulse' has a wrong offset!");
static_assert(offsetof(FLTest_HitProcOptions, DrawHitPoint_Repulse) == 0x000004, "Member 'FLTest_HitProcOptions::DrawHitPoint_Repulse' has a wrong offset!");
static_assert(offsetof(FLTest_HitProcOptions, DrawDebugLine_Repulse) == 0x000005, "Member 'FLTest_HitProcOptions::DrawDebugLine_Repulse' has a wrong offset!");
static_assert(offsetof(FLTest_HitProcOptions, UseNotAdvancedSparkTest) == 0x000006, "Member 'FLTest_HitProcOptions::UseNotAdvancedSparkTest' has a wrong offset!");
static_assert(offsetof(FLTest_HitProcOptions, FxSocketHitInterval) == 0x000008, "Member 'FLTest_HitProcOptions::FxSocketHitInterval' has a wrong offset!");

// ScriptStruct ProjectP.LHitSFXTable
// 0x0008 (0x0008 - 0x0000)
struct FLHitSFXTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLHitSFXTable) == 0x000008, "Wrong alignment on FLHitSFXTable");
static_assert(sizeof(FLHitSFXTable) == 0x000008, "Wrong size on FLHitSFXTable");
static_assert(offsetof(FLHitSFXTable, Table) == 0x000000, "Member 'FLHitSFXTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LHitSFXTableRowType
// 0x00D8 (0x00E0 - 0x0008)
struct FLHitSFXTableRowType final : public FTableRowBase
{
public:
	ELHitSoundType                                HitSoundType;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELHitSound_SecondaryType                      Event;                                             // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Attribute;                                         // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         AttackerMaterial;                                  // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Material;                                          // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELFxVictimType                                Victim_Type;                                       // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              SFX_VeryLight;                                     // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_Light;                                         // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_Medium;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_Heavy;                                         // 0x0090(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SFX_VeryHeavy;                                     // 0x00B8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLHitSFXTableRowType) == 0x000008, "Wrong alignment on FLHitSFXTableRowType");
static_assert(sizeof(FLHitSFXTableRowType) == 0x0000E0, "Wrong size on FLHitSFXTableRowType");
static_assert(offsetof(FLHitSFXTableRowType, HitSoundType) == 0x000008, "Member 'FLHitSFXTableRowType::HitSoundType' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, Event) == 0x000009, "Member 'FLHitSFXTableRowType::Event' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, Attribute) == 0x00000C, "Member 'FLHitSFXTableRowType::Attribute' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, AttackerMaterial) == 0x000014, "Member 'FLHitSFXTableRowType::AttackerMaterial' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, Material) == 0x000015, "Member 'FLHitSFXTableRowType::Material' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, Victim_Type) == 0x000016, "Member 'FLHitSFXTableRowType::Victim_Type' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, SFX_VeryLight) == 0x000018, "Member 'FLHitSFXTableRowType::SFX_VeryLight' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, SFX_Light) == 0x000040, "Member 'FLHitSFXTableRowType::SFX_Light' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, SFX_Medium) == 0x000068, "Member 'FLHitSFXTableRowType::SFX_Medium' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, SFX_Heavy) == 0x000090, "Member 'FLHitSFXTableRowType::SFX_Heavy' has a wrong offset!");
static_assert(offsetof(FLHitSFXTableRowType, SFX_VeryHeavy) == 0x0000B8, "Member 'FLHitSFXTableRowType::SFX_VeryHeavy' has a wrong offset!");

// ScriptStruct ProjectP.LDisplayableDialog
// 0x0020 (0x0020 - 0x0000)
struct FLDisplayableDialog final
{
public:
	TArray<struct FDialogInfoPtr>                 Infos;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FDialogInfoPtr                         AgentInfo;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FDialogInfoPtr                         ConditionInfo;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDisplayableDialog) == 0x000008, "Wrong alignment on FLDisplayableDialog");
static_assert(sizeof(FLDisplayableDialog) == 0x000020, "Wrong size on FLDisplayableDialog");
static_assert(offsetof(FLDisplayableDialog, Infos) == 0x000000, "Member 'FLDisplayableDialog::Infos' has a wrong offset!");
static_assert(offsetof(FLDisplayableDialog, AgentInfo) == 0x000010, "Member 'FLDisplayableDialog::AgentInfo' has a wrong offset!");
static_assert(offsetof(FLDisplayableDialog, ConditionInfo) == 0x000018, "Member 'FLDisplayableDialog::ConditionInfo' has a wrong offset!");

// ScriptStruct ProjectP.LDialogExecute
// 0x0010 (0x0010 - 0x0000)
struct FLDialogExecute final
{
public:
	bool                                          SuccessRestoredNextDialog;                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NextUIWidgetName;                                  // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime_BeforeNextUIWidget;                       // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDialogExecute) == 0x000004, "Wrong alignment on FLDialogExecute");
static_assert(sizeof(FLDialogExecute) == 0x000010, "Wrong size on FLDialogExecute");
static_assert(offsetof(FLDialogExecute, SuccessRestoredNextDialog) == 0x000000, "Member 'FLDialogExecute::SuccessRestoredNextDialog' has a wrong offset!");
static_assert(offsetof(FLDialogExecute, NextUIWidgetName) == 0x000004, "Member 'FLDialogExecute::NextUIWidgetName' has a wrong offset!");
static_assert(offsetof(FLDialogExecute, WaitTime_BeforeNextUIWidget) == 0x00000C, "Member 'FLDialogExecute::WaitTime_BeforeNextUIWidget' has a wrong offset!");

// ScriptStruct ProjectP.LSingleDialogDebugInfo
// 0x0040 (0x0040 - 0x0000)
struct FLSingleDialogDebugInfo final
{
public:
	class FName                                   DialogCodeName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionCodeName;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConditionIndependant;                              // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MenuItemVariable;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentCommandCodeName;                            // 0x0024(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ContentCommandIndependant;                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSingleDialogDebugInfo) == 0x000008, "Wrong alignment on FLSingleDialogDebugInfo");
static_assert(sizeof(FLSingleDialogDebugInfo) == 0x000040, "Wrong size on FLSingleDialogDebugInfo");
static_assert(offsetof(FLSingleDialogDebugInfo, DialogCodeName) == 0x000000, "Member 'FLSingleDialogDebugInfo::DialogCodeName' has a wrong offset!");
static_assert(offsetof(FLSingleDialogDebugInfo, ConditionCodeName) == 0x000008, "Member 'FLSingleDialogDebugInfo::ConditionCodeName' has a wrong offset!");
static_assert(offsetof(FLSingleDialogDebugInfo, ConditionIndependant) == 0x000010, "Member 'FLSingleDialogDebugInfo::ConditionIndependant' has a wrong offset!");
static_assert(offsetof(FLSingleDialogDebugInfo, MenuItemVariable) == 0x000020, "Member 'FLSingleDialogDebugInfo::MenuItemVariable' has a wrong offset!");
static_assert(offsetof(FLSingleDialogDebugInfo, ContentCommandCodeName) == 0x000024, "Member 'FLSingleDialogDebugInfo::ContentCommandCodeName' has a wrong offset!");
static_assert(offsetof(FLSingleDialogDebugInfo, ContentCommandIndependant) == 0x000030, "Member 'FLSingleDialogDebugInfo::ContentCommandIndependant' has a wrong offset!");

// ScriptStruct ProjectP.LItemRequireCount
// 0x0010 (0x0010 - 0x0000)
struct FLItemRequireCount final
{
public:
	class FName                                   ItemCodeName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentCount;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequireCount;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLItemRequireCount) == 0x000004, "Wrong alignment on FLItemRequireCount");
static_assert(sizeof(FLItemRequireCount) == 0x000010, "Wrong size on FLItemRequireCount");
static_assert(offsetof(FLItemRequireCount, ItemCodeName) == 0x000000, "Member 'FLItemRequireCount::ItemCodeName' has a wrong offset!");
static_assert(offsetof(FLItemRequireCount, CurrentCount) == 0x000008, "Member 'FLItemRequireCount::CurrentCount' has a wrong offset!");
static_assert(offsetof(FLItemRequireCount, RequireCount) == 0x00000C, "Member 'FLItemRequireCount::RequireCount' has a wrong offset!");

// ScriptStruct ProjectP.LSoundCueTableRow
// 0x0028 (0x0030 - 0x0008)
struct FLSoundCueTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSoundCueTableRow) == 0x000008, "Wrong alignment on FLSoundCueTableRow");
static_assert(sizeof(FLSoundCueTableRow) == 0x000030, "Wrong size on FLSoundCueTableRow");
static_assert(offsetof(FLSoundCueTableRow, Sound) == 0x000008, "Member 'FLSoundCueTableRow::Sound' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponPartInfoForCombine
// 0x0010 (0x0010 - 0x0000)
struct FLWeaponPartInfoForCombine final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULWeaponItem>            CombinedWeapon;                                    // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWeaponPartInfoForCombine) == 0x000008, "Wrong alignment on FLWeaponPartInfoForCombine");
static_assert(sizeof(FLWeaponPartInfoForCombine) == 0x000010, "Wrong size on FLWeaponPartInfoForCombine");
static_assert(offsetof(FLWeaponPartInfoForCombine, Item) == 0x000000, "Member 'FLWeaponPartInfoForCombine::Item' has a wrong offset!");
static_assert(offsetof(FLWeaponPartInfoForCombine, CombinedWeapon) == 0x000008, "Member 'FLWeaponPartInfoForCombine::CombinedWeapon' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponPart
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FLWeaponPart final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWeaponPart) == 0x000008, "Wrong alignment on FLWeaponPart");
static_assert(sizeof(FLWeaponPart) == 0x000030, "Wrong size on FLWeaponPart");

// ScriptStruct ProjectP.LChangeCorrectionInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FLChangeCorrectionInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLChangeCorrectionInfo) == 0x000004, "Wrong alignment on FLChangeCorrectionInfo");
static_assert(sizeof(FLChangeCorrectionInfo) == 0x000010, "Wrong size on FLChangeCorrectionInfo");

// ScriptStruct ProjectP.LInvenCategoryItemList
// 0x0018 (0x0018 - 0x0000)
struct FLInvenCategoryItemList final
{
public:
	ELItemSecondCategory                          SecondCategory;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULItem*>                         Items;                                             // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLInvenCategoryItemList) == 0x000008, "Wrong alignment on FLInvenCategoryItemList");
static_assert(sizeof(FLInvenCategoryItemList) == 0x000018, "Wrong size on FLInvenCategoryItemList");
static_assert(offsetof(FLInvenCategoryItemList, SecondCategory) == 0x000000, "Member 'FLInvenCategoryItemList::SecondCategory' has a wrong offset!");
static_assert(offsetof(FLInvenCategoryItemList, Items) == 0x000008, "Member 'FLInvenCategoryItemList::Items' has a wrong offset!");

// ScriptStruct ProjectP.LSparkFxTable
// 0x0058 (0x0058 - 0x0000)
struct FLSparkFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSparkFxTable) == 0x000008, "Wrong alignment on FLSparkFxTable");
static_assert(sizeof(FLSparkFxTable) == 0x000058, "Wrong size on FLSparkFxTable");
static_assert(offsetof(FLSparkFxTable, Table) == 0x000000, "Member 'FLSparkFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LItemCostumeTable
// 0x0008 (0x0008 - 0x0000)
struct FLItemCostumeTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLItemCostumeTable) == 0x000008, "Wrong alignment on FLItemCostumeTable");
static_assert(sizeof(FLItemCostumeTable) == 0x000008, "Wrong size on FLItemCostumeTable");
static_assert(offsetof(FLItemCostumeTable, Table) == 0x000000, "Member 'FLItemCostumeTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LItemCostumeTableRow
// 0x0030 (0x0038 - 0x0008)
struct FLItemCostumeTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLCharacterSoundType                   CharacterSoundType;                                // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLItemCostumeTableRow) == 0x000008, "Wrong alignment on FLItemCostumeTableRow");
static_assert(sizeof(FLItemCostumeTableRow) == 0x000038, "Wrong size on FLItemCostumeTableRow");
static_assert(offsetof(FLItemCostumeTableRow, Mesh) == 0x000008, "Member 'FLItemCostumeTableRow::Mesh' has a wrong offset!");
static_assert(offsetof(FLItemCostumeTableRow, CharacterSoundType) == 0x000030, "Member 'FLItemCostumeTableRow::CharacterSoundType' has a wrong offset!");

// ScriptStruct ProjectP.LSequenceMixer
// 0x0018 (0x0018 - 0x0000)
struct FLSequenceMixer final
{
public:
	class FName                                   CodeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundMix*>                      SoundMixes;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSequenceMixer) == 0x000008, "Wrong alignment on FLSequenceMixer");
static_assert(sizeof(FLSequenceMixer) == 0x000018, "Wrong size on FLSequenceMixer");
static_assert(offsetof(FLSequenceMixer, CodeName) == 0x000000, "Member 'FLSequenceMixer::CodeName' has a wrong offset!");
static_assert(offsetof(FLSequenceMixer, SoundMixes) == 0x000008, "Member 'FLSequenceMixer::SoundMixes' has a wrong offset!");

// ScriptStruct ProjectP.LSubtitleHierarchyInfo
// 0x0058 (0x0058 - 0x0000)
struct FLSubtitleHierarchyInfo final
{
public:
	class FName                                   SubtitleCodeName;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FSubtitleInfoPtr>          SubtitleTimeMap;                                   // 0x0008(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSubtitleHierarchyInfo) == 0x000008, "Wrong alignment on FLSubtitleHierarchyInfo");
static_assert(sizeof(FLSubtitleHierarchyInfo) == 0x000058, "Wrong size on FLSubtitleHierarchyInfo");
static_assert(offsetof(FLSubtitleHierarchyInfo, SubtitleCodeName) == 0x000000, "Member 'FLSubtitleHierarchyInfo::SubtitleCodeName' has a wrong offset!");
static_assert(offsetof(FLSubtitleHierarchyInfo, SubtitleTimeMap) == 0x000008, "Member 'FLSubtitleHierarchyInfo::SubtitleTimeMap' has a wrong offset!");

// ScriptStruct ProjectP.LSequenceRuntimeSettings
// 0x0005 (0x0005 - 0x0000)
struct FLSequenceRuntimeSettings final
{
public:
	bool                                          bInsitigatorViewOnStart;                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerWeaponControl;                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerWeaponOn;                                   // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipUIControl;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipUIOn;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSequenceRuntimeSettings) == 0x000001, "Wrong alignment on FLSequenceRuntimeSettings");
static_assert(sizeof(FLSequenceRuntimeSettings) == 0x000005, "Wrong size on FLSequenceRuntimeSettings");
static_assert(offsetof(FLSequenceRuntimeSettings, bInsitigatorViewOnStart) == 0x000000, "Member 'FLSequenceRuntimeSettings::bInsitigatorViewOnStart' has a wrong offset!");
static_assert(offsetof(FLSequenceRuntimeSettings, bPlayerWeaponControl) == 0x000001, "Member 'FLSequenceRuntimeSettings::bPlayerWeaponControl' has a wrong offset!");
static_assert(offsetof(FLSequenceRuntimeSettings, bPlayerWeaponOn) == 0x000002, "Member 'FLSequenceRuntimeSettings::bPlayerWeaponOn' has a wrong offset!");
static_assert(offsetof(FLSequenceRuntimeSettings, bSkipUIControl) == 0x000003, "Member 'FLSequenceRuntimeSettings::bSkipUIControl' has a wrong offset!");
static_assert(offsetof(FLSequenceRuntimeSettings, bSkipUIOn) == 0x000004, "Member 'FLSequenceRuntimeSettings::bSkipUIOn' has a wrong offset!");

// ScriptStruct ProjectP.LVariableSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLVariableSaveData final
{
public:
	TArray<struct FLVariableData>                 GlobalVariableList;                                // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLVariableSaveData) == 0x000008, "Wrong alignment on FLVariableSaveData");
static_assert(sizeof(FLVariableSaveData) == 0x000010, "Wrong size on FLVariableSaveData");
static_assert(offsetof(FLVariableSaveData, GlobalVariableList) == 0x000000, "Member 'FLVariableSaveData::GlobalVariableList' has a wrong offset!");

// ScriptStruct ProjectP.LSequenceTarget
// 0x0040 (0x0040 - 0x0000)
struct FLSequenceTarget final
{
public:
	ELSequenceTargetType                          Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SpotUniqueID;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Interp, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x20];                                      // 0x0020(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSequenceTarget) == 0x000008, "Wrong alignment on FLSequenceTarget");
static_assert(sizeof(FLSequenceTarget) == 0x000040, "Wrong size on FLSequenceTarget");
static_assert(offsetof(FLSequenceTarget, Type) == 0x000000, "Member 'FLSequenceTarget::Type' has a wrong offset!");
static_assert(offsetof(FLSequenceTarget, SpotUniqueID) == 0x000008, "Member 'FLSequenceTarget::SpotUniqueID' has a wrong offset!");
static_assert(offsetof(FLSequenceTarget, SocketName) == 0x000018, "Member 'FLSequenceTarget::SocketName' has a wrong offset!");

// ScriptStruct ProjectP.LRotationYawSectionData
// 0x0008 (0x0008 - 0x0000)
struct FLRotationYawSectionData final
{
public:
	int32                                         Yaw;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLRotationYawSectionData) == 0x000004, "Wrong alignment on FLRotationYawSectionData");
static_assert(sizeof(FLRotationYawSectionData) == 0x000008, "Wrong size on FLRotationYawSectionData");
static_assert(offsetof(FLRotationYawSectionData, Yaw) == 0x000000, "Member 'FLRotationYawSectionData::Yaw' has a wrong offset!");
static_assert(offsetof(FLRotationYawSectionData, Speed) == 0x000004, "Member 'FLRotationYawSectionData::Speed' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileDestructionConditionInfo
// 0x0002 (0x0002 - 0x0000)
struct FLProjectileDestructionConditionInfo final
{
public:
	bool                                          bDestruction;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELProjectileDestroyConditionType              Type;                                              // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProjectileDestructionConditionInfo) == 0x000001, "Wrong alignment on FLProjectileDestructionConditionInfo");
static_assert(sizeof(FLProjectileDestructionConditionInfo) == 0x000002, "Wrong size on FLProjectileDestructionConditionInfo");
static_assert(offsetof(FLProjectileDestructionConditionInfo, bDestruction) == 0x000000, "Member 'FLProjectileDestructionConditionInfo::bDestruction' has a wrong offset!");
static_assert(offsetof(FLProjectileDestructionConditionInfo, Type) == 0x000001, "Member 'FLProjectileDestructionConditionInfo::Type' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileDestructionInfo
// 0x000E (0x000E - 0x0000)
struct FLProjectileDestructionInfo final
{
public:
	struct FLProjectileDestructionConditionInfo   Destruction_Cond_Time;                             // 0x0000(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLProjectileDestructionConditionInfo   Destruction_Cond_Character_Hit;                    // 0x0002(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLProjectileDestructionConditionInfo   Destruction_Cond_Map_Hit;                          // 0x0004(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLProjectileDestructionConditionInfo   Destruction_Cond_Distance;                         // 0x0006(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLProjectileDestructionConditionInfo   Destruction_Cond_Custom_Hit;                       // 0x0008(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLProjectileDestructionConditionInfo   Destruction_Cond_Instigator_Die;                   // 0x000A(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLProjectileDestructionConditionInfo   Destruction_Cond_DestructibleObject_Hit;           // 0x000C(0x0002)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProjectileDestructionInfo) == 0x000001, "Wrong alignment on FLProjectileDestructionInfo");
static_assert(sizeof(FLProjectileDestructionInfo) == 0x00000E, "Wrong size on FLProjectileDestructionInfo");
static_assert(offsetof(FLProjectileDestructionInfo, Destruction_Cond_Time) == 0x000000, "Member 'FLProjectileDestructionInfo::Destruction_Cond_Time' has a wrong offset!");
static_assert(offsetof(FLProjectileDestructionInfo, Destruction_Cond_Character_Hit) == 0x000002, "Member 'FLProjectileDestructionInfo::Destruction_Cond_Character_Hit' has a wrong offset!");
static_assert(offsetof(FLProjectileDestructionInfo, Destruction_Cond_Map_Hit) == 0x000004, "Member 'FLProjectileDestructionInfo::Destruction_Cond_Map_Hit' has a wrong offset!");
static_assert(offsetof(FLProjectileDestructionInfo, Destruction_Cond_Distance) == 0x000006, "Member 'FLProjectileDestructionInfo::Destruction_Cond_Distance' has a wrong offset!");
static_assert(offsetof(FLProjectileDestructionInfo, Destruction_Cond_Custom_Hit) == 0x000008, "Member 'FLProjectileDestructionInfo::Destruction_Cond_Custom_Hit' has a wrong offset!");
static_assert(offsetof(FLProjectileDestructionInfo, Destruction_Cond_Instigator_Die) == 0x00000A, "Member 'FLProjectileDestructionInfo::Destruction_Cond_Instigator_Die' has a wrong offset!");
static_assert(offsetof(FLProjectileDestructionInfo, Destruction_Cond_DestructibleObject_Hit) == 0x00000C, "Member 'FLProjectileDestructionInfo::Destruction_Cond_DestructibleObject_Hit' has a wrong offset!");

// ScriptStruct ProjectP.LockOnSensitiveRotation
// 0x0014 (0x0014 - 0x0000)
struct FLockOnSensitiveRotation final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         YawAngleStopMove;                                  // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         PitchAngleStopMove;                                // 0x000C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLockOnSensitiveRotation) == 0x000004, "Wrong alignment on FLockOnSensitiveRotation");
static_assert(sizeof(FLockOnSensitiveRotation) == 0x000014, "Wrong size on FLockOnSensitiveRotation");
static_assert(offsetof(FLockOnSensitiveRotation, bEnable) == 0x000000, "Member 'FLockOnSensitiveRotation::bEnable' has a wrong offset!");
static_assert(offsetof(FLockOnSensitiveRotation, YawAngleStopMove) == 0x000004, "Member 'FLockOnSensitiveRotation::YawAngleStopMove' has a wrong offset!");
static_assert(offsetof(FLockOnSensitiveRotation, PitchAngleStopMove) == 0x00000C, "Member 'FLockOnSensitiveRotation::PitchAngleStopMove' has a wrong offset!");

// ScriptStruct ProjectP.NoneLockOnAutoGuideData
// 0x0018 (0x0018 - 0x0000)
struct FNoneLockOnAutoGuideData final
{
public:
	float                                         SearchDistance;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchDegree;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceWeight;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceExp;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWeight;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleExp;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNoneLockOnAutoGuideData) == 0x000004, "Wrong alignment on FNoneLockOnAutoGuideData");
static_assert(sizeof(FNoneLockOnAutoGuideData) == 0x000018, "Wrong size on FNoneLockOnAutoGuideData");
static_assert(offsetof(FNoneLockOnAutoGuideData, SearchDistance) == 0x000000, "Member 'FNoneLockOnAutoGuideData::SearchDistance' has a wrong offset!");
static_assert(offsetof(FNoneLockOnAutoGuideData, SearchDegree) == 0x000004, "Member 'FNoneLockOnAutoGuideData::SearchDegree' has a wrong offset!");
static_assert(offsetof(FNoneLockOnAutoGuideData, DistanceWeight) == 0x000008, "Member 'FNoneLockOnAutoGuideData::DistanceWeight' has a wrong offset!");
static_assert(offsetof(FNoneLockOnAutoGuideData, DistanceExp) == 0x00000C, "Member 'FNoneLockOnAutoGuideData::DistanceExp' has a wrong offset!");
static_assert(offsetof(FNoneLockOnAutoGuideData, AngleWeight) == 0x000010, "Member 'FNoneLockOnAutoGuideData::AngleWeight' has a wrong offset!");
static_assert(offsetof(FNoneLockOnAutoGuideData, AngleExp) == 0x000014, "Member 'FNoneLockOnAutoGuideData::AngleExp' has a wrong offset!");

// ScriptStruct ProjectP.LRepulseFxTable
// 0x0058 (0x0058 - 0x0000)
struct FLRepulseFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLRepulseFxTable) == 0x000008, "Wrong alignment on FLRepulseFxTable");
static_assert(sizeof(FLRepulseFxTable) == 0x000058, "Wrong size on FLRepulseFxTable");
static_assert(offsetof(FLRepulseFxTable, Table) == 0x000000, "Member 'FLRepulseFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LockOnImportanceFactor
// 0x001C (0x001C - 0x0000)
struct FLockOnImportanceFactor final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceWeight;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceExp;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovWeight;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovExp;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalWeight;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalWeight;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLockOnImportanceFactor) == 0x000004, "Wrong alignment on FLockOnImportanceFactor");
static_assert(sizeof(FLockOnImportanceFactor) == 0x00001C, "Wrong size on FLockOnImportanceFactor");
static_assert(offsetof(FLockOnImportanceFactor, bEnable) == 0x000000, "Member 'FLockOnImportanceFactor::bEnable' has a wrong offset!");
static_assert(offsetof(FLockOnImportanceFactor, DistanceWeight) == 0x000004, "Member 'FLockOnImportanceFactor::DistanceWeight' has a wrong offset!");
static_assert(offsetof(FLockOnImportanceFactor, DistanceExp) == 0x000008, "Member 'FLockOnImportanceFactor::DistanceExp' has a wrong offset!");
static_assert(offsetof(FLockOnImportanceFactor, FovWeight) == 0x00000C, "Member 'FLockOnImportanceFactor::FovWeight' has a wrong offset!");
static_assert(offsetof(FLockOnImportanceFactor, FovExp) == 0x000010, "Member 'FLockOnImportanceFactor::FovExp' has a wrong offset!");
static_assert(offsetof(FLockOnImportanceFactor, HorizontalWeight) == 0x000014, "Member 'FLockOnImportanceFactor::HorizontalWeight' has a wrong offset!");
static_assert(offsetof(FLockOnImportanceFactor, VerticalWeight) == 0x000018, "Member 'FLockOnImportanceFactor::VerticalWeight' has a wrong offset!");

// ScriptStruct ProjectP.LockOnFocusedTargetOffsetMove
// 0x002C (0x002C - 0x0000)
struct FLockOnFocusedTargetOffsetMove final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirectionMoveAmount;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionMoveSpeed;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveStartHoldingTime;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveMove;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InputMoveAxis;                                     // 0x0014(0x000C)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MoveOffset;                                        // 0x0020(0x000C)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLockOnFocusedTargetOffsetMove) == 0x000004, "Wrong alignment on FLockOnFocusedTargetOffsetMove");
static_assert(sizeof(FLockOnFocusedTargetOffsetMove) == 0x00002C, "Wrong size on FLockOnFocusedTargetOffsetMove");
static_assert(offsetof(FLockOnFocusedTargetOffsetMove, bEnable) == 0x000000, "Member 'FLockOnFocusedTargetOffsetMove::bEnable' has a wrong offset!");
static_assert(offsetof(FLockOnFocusedTargetOffsetMove, DirectionMoveAmount) == 0x000004, "Member 'FLockOnFocusedTargetOffsetMove::DirectionMoveAmount' has a wrong offset!");
static_assert(offsetof(FLockOnFocusedTargetOffsetMove, DirectionMoveSpeed) == 0x000008, "Member 'FLockOnFocusedTargetOffsetMove::DirectionMoveSpeed' has a wrong offset!");
static_assert(offsetof(FLockOnFocusedTargetOffsetMove, MoveStartHoldingTime) == 0x00000C, "Member 'FLockOnFocusedTargetOffsetMove::MoveStartHoldingTime' has a wrong offset!");
static_assert(offsetof(FLockOnFocusedTargetOffsetMove, bActiveMove) == 0x000010, "Member 'FLockOnFocusedTargetOffsetMove::bActiveMove' has a wrong offset!");
static_assert(offsetof(FLockOnFocusedTargetOffsetMove, InputMoveAxis) == 0x000014, "Member 'FLockOnFocusedTargetOffsetMove::InputMoveAxis' has a wrong offset!");
static_assert(offsetof(FLockOnFocusedTargetOffsetMove, MoveOffset) == 0x000020, "Member 'FLockOnFocusedTargetOffsetMove::MoveOffset' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileHitCollisionShape
// 0x0060 (0x0060 - 0x0000)
struct FLProjectileHitCollisionShape final
{
public:
	ELHitCollisionCheckType                       CollisionType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Capsule_Radius;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Capsule_Length;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sphere_Radius;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Box_Extend;                                        // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cylinder_Max_Distance;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cylinder_Min_Distance;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cylinder_Height;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitTraceDistance;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProjectileHitCollisionShape) == 0x000010, "Wrong alignment on FLProjectileHitCollisionShape");
static_assert(sizeof(FLProjectileHitCollisionShape) == 0x000060, "Wrong size on FLProjectileHitCollisionShape");
static_assert(offsetof(FLProjectileHitCollisionShape, CollisionType) == 0x000000, "Member 'FLProjectileHitCollisionShape::CollisionType' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Capsule_Radius) == 0x000004, "Member 'FLProjectileHitCollisionShape::Capsule_Radius' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Capsule_Length) == 0x000008, "Member 'FLProjectileHitCollisionShape::Capsule_Length' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Sphere_Radius) == 0x00000C, "Member 'FLProjectileHitCollisionShape::Sphere_Radius' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Box_Extend) == 0x000010, "Member 'FLProjectileHitCollisionShape::Box_Extend' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Cylinder_Max_Distance) == 0x00001C, "Member 'FLProjectileHitCollisionShape::Cylinder_Max_Distance' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Cylinder_Min_Distance) == 0x000020, "Member 'FLProjectileHitCollisionShape::Cylinder_Min_Distance' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Cylinder_Height) == 0x000024, "Member 'FLProjectileHitCollisionShape::Cylinder_Height' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, HitTraceDistance) == 0x000028, "Member 'FLProjectileHitCollisionShape::HitTraceDistance' has a wrong offset!");
static_assert(offsetof(FLProjectileHitCollisionShape, Offset) == 0x000030, "Member 'FLProjectileHitCollisionShape::Offset' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileHitInfo_V2
// 0x0030 (0x0030 - 0x0000)
struct FLProjectileHitInfo_V2 final
{
public:
	class FName                                   SkillHitCodeName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileHitGenerateEnumType                HitGenerateType;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillHitCollisionProfile;                          // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialStartDelay;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLProjectileHitCollisionShape>  HitShapeList;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProjectileHitInfo_V2) == 0x000008, "Wrong alignment on FLProjectileHitInfo_V2");
static_assert(sizeof(FLProjectileHitInfo_V2) == 0x000030, "Wrong size on FLProjectileHitInfo_V2");
static_assert(offsetof(FLProjectileHitInfo_V2, SkillHitCodeName) == 0x000000, "Member 'FLProjectileHitInfo_V2::SkillHitCodeName' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo_V2, HitGenerateType) == 0x000008, "Member 'FLProjectileHitInfo_V2::HitGenerateType' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo_V2, SkillHitCollisionProfile) == 0x00000C, "Member 'FLProjectileHitInfo_V2::SkillHitCollisionProfile' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo_V2, InitialStartDelay) == 0x000014, "Member 'FLProjectileHitInfo_V2::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo_V2, Interval) == 0x000018, "Member 'FLProjectileHitInfo_V2::Interval' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo_V2, MaxCount) == 0x00001C, "Member 'FLProjectileHitInfo_V2::MaxCount' has a wrong offset!");
static_assert(offsetof(FLProjectileHitInfo_V2, HitShapeList) == 0x000020, "Member 'FLProjectileHitInfo_V2::HitShapeList' has a wrong offset!");

// ScriptStruct ProjectP.LockOnStoreCameraData
// 0x0038 (0x0038 - 0x0000)
struct FLockOnStoreCameraData final
{
public:
	struct FRotator                               ControlRotation;                                   // 0x0000(0x000C)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraLag;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraRotationLag;                          // 0x000D(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsePawnControlRotation;                           // 0x000E(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraSocketOffset;                                // 0x0010(0x000C)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraTargetOffset;                                // 0x001C(0x000C)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraArmLength;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagSpeed;                                    // 0x002C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotationLagSpeed;                            // 0x0030(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLagMaxDistance;                              // 0x0034(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLockOnStoreCameraData) == 0x000004, "Wrong alignment on FLockOnStoreCameraData");
static_assert(sizeof(FLockOnStoreCameraData) == 0x000038, "Wrong size on FLockOnStoreCameraData");
static_assert(offsetof(FLockOnStoreCameraData, ControlRotation) == 0x000000, "Member 'FLockOnStoreCameraData::ControlRotation' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, bEnableCameraLag) == 0x00000C, "Member 'FLockOnStoreCameraData::bEnableCameraLag' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, bEnableCameraRotationLag) == 0x00000D, "Member 'FLockOnStoreCameraData::bEnableCameraRotationLag' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, bUsePawnControlRotation) == 0x00000E, "Member 'FLockOnStoreCameraData::bUsePawnControlRotation' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, CameraSocketOffset) == 0x000010, "Member 'FLockOnStoreCameraData::CameraSocketOffset' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, CameraTargetOffset) == 0x00001C, "Member 'FLockOnStoreCameraData::CameraTargetOffset' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, CameraArmLength) == 0x000028, "Member 'FLockOnStoreCameraData::CameraArmLength' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, CameraLagSpeed) == 0x00002C, "Member 'FLockOnStoreCameraData::CameraLagSpeed' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, CameraRotationLagSpeed) == 0x000030, "Member 'FLockOnStoreCameraData::CameraRotationLagSpeed' has a wrong offset!");
static_assert(offsetof(FLockOnStoreCameraData, CameraLagMaxDistance) == 0x000034, "Member 'FLockOnStoreCameraData::CameraLagMaxDistance' has a wrong offset!");

// ScriptStruct ProjectP.LMovieAudioSetting
// 0x0028 (0x0028 - 0x0000)
struct FLMovieAudioSetting final
{
public:
	float                                         Volume;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundMix*>                      SoundMixes;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundMix*>                      EndMoviePushSoundMixes;                            // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMovieAudioSetting) == 0x000008, "Wrong alignment on FLMovieAudioSetting");
static_assert(sizeof(FLMovieAudioSetting) == 0x000028, "Wrong size on FLMovieAudioSetting");
static_assert(offsetof(FLMovieAudioSetting, Volume) == 0x000000, "Member 'FLMovieAudioSetting::Volume' has a wrong offset!");
static_assert(offsetof(FLMovieAudioSetting, SoundMixes) == 0x000008, "Member 'FLMovieAudioSetting::SoundMixes' has a wrong offset!");
static_assert(offsetof(FLMovieAudioSetting, EndMoviePushSoundMixes) == 0x000018, "Member 'FLMovieAudioSetting::EndMoviePushSoundMixes' has a wrong offset!");

// ScriptStruct ProjectP.LSoundWithPS
// 0x0010 (0x0010 - 0x0000)
struct FLSoundWithPS final
{
public:
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSoundWithPS) == 0x000008, "Wrong alignment on FLSoundWithPS");
static_assert(sizeof(FLSoundWithPS) == 0x000010, "Wrong size on FLSoundWithPS");
static_assert(offsetof(FLSoundWithPS, PhysicalSurface) == 0x000000, "Member 'FLSoundWithPS::PhysicalSurface' has a wrong offset!");
static_assert(offsetof(FLSoundWithPS, Sound) == 0x000008, "Member 'FLSoundWithPS::Sound' has a wrong offset!");

// ScriptStruct ProjectP.LNiagaraWithParameters_for_Notify
// 0x00F8 (0x00F8 - 0x0000)
struct FLNiagaraWithParameters_for_Notify
{
public:
	class UNiagaraSystem*                         Niagara;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0008(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector2D>           Vector2Parameters;                                 // 0x0058(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVector>             Vector3Parameters;                                 // 0x00A8(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNiagaraWithParameters_for_Notify) == 0x000008, "Wrong alignment on FLNiagaraWithParameters_for_Notify");
static_assert(sizeof(FLNiagaraWithParameters_for_Notify) == 0x0000F8, "Wrong size on FLNiagaraWithParameters_for_Notify");
static_assert(offsetof(FLNiagaraWithParameters_for_Notify, Niagara) == 0x000000, "Member 'FLNiagaraWithParameters_for_Notify::Niagara' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters_for_Notify, ScalarParameters) == 0x000008, "Member 'FLNiagaraWithParameters_for_Notify::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters_for_Notify, Vector2Parameters) == 0x000058, "Member 'FLNiagaraWithParameters_for_Notify::Vector2Parameters' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters_for_Notify, Vector3Parameters) == 0x0000A8, "Member 'FLNiagaraWithParameters_for_Notify::Vector3Parameters' has a wrong offset!");

// ScriptStruct ProjectP.LProjectilePropSpawnParameter
// 0x0050 (0x0050 - 0x0000)
struct FLProjectilePropSpawnParameter final
{
public:
	class FName                                   ProjectileCodeName;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InitialStartDelay;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootInterval;                                     // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShootRepeatNum;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLProjectilePropSpawnParameter) == 0x000010, "Wrong alignment on FLProjectilePropSpawnParameter");
static_assert(sizeof(FLProjectilePropSpawnParameter) == 0x000050, "Wrong size on FLProjectilePropSpawnParameter");
static_assert(offsetof(FLProjectilePropSpawnParameter, ProjectileCodeName) == 0x000000, "Member 'FLProjectilePropSpawnParameter::ProjectileCodeName' has a wrong offset!");
static_assert(offsetof(FLProjectilePropSpawnParameter, Offset) == 0x000010, "Member 'FLProjectilePropSpawnParameter::Offset' has a wrong offset!");
static_assert(offsetof(FLProjectilePropSpawnParameter, InitialStartDelay) == 0x000040, "Member 'FLProjectilePropSpawnParameter::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(FLProjectilePropSpawnParameter, ShootInterval) == 0x000044, "Member 'FLProjectilePropSpawnParameter::ShootInterval' has a wrong offset!");
static_assert(offsetof(FLProjectilePropSpawnParameter, ShootRepeatNum) == 0x000048, "Member 'FLProjectilePropSpawnParameter::ShootRepeatNum' has a wrong offset!");

// ScriptStruct ProjectP.LNiagaraWithParametersWithPS_for_Notify
// 0x0008 (0x0100 - 0x00F8)
struct FLNiagaraWithParametersWithPS_for_Notify final : public FLNiagaraWithParameters_for_Notify
{
public:
	ELPhysicalSurfaceType                         PhysicalSurface;                                   // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNiagaraWithParametersWithPS_for_Notify) == 0x000008, "Wrong alignment on FLNiagaraWithParametersWithPS_for_Notify");
static_assert(sizeof(FLNiagaraWithParametersWithPS_for_Notify) == 0x000100, "Wrong size on FLNiagaraWithParametersWithPS_for_Notify");
static_assert(offsetof(FLNiagaraWithParametersWithPS_for_Notify, PhysicalSurface) == 0x0000F8, "Member 'FLNiagaraWithParametersWithPS_for_Notify::PhysicalSurface' has a wrong offset!");

// ScriptStruct ProjectP.LNiagaraWithParameters_Simple
// 0x00C8 (0x00C8 - 0x0000)
struct FLNiagaraWithParameters_Simple final
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ColorParameters;                                   // 0x0078(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNiagaraWithParameters_Simple) == 0x000008, "Wrong alignment on FLNiagaraWithParameters_Simple");
static_assert(sizeof(FLNiagaraWithParameters_Simple) == 0x0000C8, "Wrong size on FLNiagaraWithParameters_Simple");
static_assert(offsetof(FLNiagaraWithParameters_Simple, Niagara) == 0x000000, "Member 'FLNiagaraWithParameters_Simple::Niagara' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters_Simple, ScalarParameters) == 0x000028, "Member 'FLNiagaraWithParameters_Simple::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FLNiagaraWithParameters_Simple, ColorParameters) == 0x000078, "Member 'FLNiagaraWithParameters_Simple::ColorParameters' has a wrong offset!");

// ScriptStruct ProjectP.LSplashBloodFxTable
// 0x0008 (0x0008 - 0x0000)
struct FLSplashBloodFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLSplashBloodFxTable) == 0x000008, "Wrong alignment on FLSplashBloodFxTable");
static_assert(sizeof(FLSplashBloodFxTable) == 0x000008, "Wrong size on FLSplashBloodFxTable");
static_assert(offsetof(FLSplashBloodFxTable, Table) == 0x000000, "Member 'FLSplashBloodFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LNPCAssetTable
// 0x0008 (0x0008 - 0x0000)
struct FLNPCAssetTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLNPCAssetTable) == 0x000008, "Wrong alignment on FLNPCAssetTable");
static_assert(sizeof(FLNPCAssetTable) == 0x000008, "Wrong size on FLNPCAssetTable");
static_assert(offsetof(FLNPCAssetTable, Table) == 0x000000, "Member 'FLNPCAssetTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LNPCAssetTableRowType
// 0x0098 (0x00A0 - 0x0008)
struct FLNPCAssetTableRowType final : public FTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NPC_Blueprint;                                     // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionGroupCodeName;                               // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeadExplosionCodeName;                             // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LoadActionGroupCodeNames;                          // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   FloatingActionGroupCodeName;                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AI_StateMachine;                                   // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLCharacterSoundType                   CharacterSoundType;                                // 0x0090(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FLCharacterFxType                      CharacterFxType;                                   // 0x0098(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCAssetTableRowType) == 0x000008, "Wrong alignment on FLNPCAssetTableRowType");
static_assert(sizeof(FLNPCAssetTableRowType) == 0x0000A0, "Wrong size on FLNPCAssetTableRowType");
static_assert(offsetof(FLNPCAssetTableRowType, Description) == 0x000008, "Member 'FLNPCAssetTableRowType::Description' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, NPC_Blueprint) == 0x000018, "Member 'FLNPCAssetTableRowType::NPC_Blueprint' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, ActionGroupCodeName) == 0x000040, "Member 'FLNPCAssetTableRowType::ActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, DeadExplosionCodeName) == 0x000048, "Member 'FLNPCAssetTableRowType::DeadExplosionCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, LoadActionGroupCodeNames) == 0x000050, "Member 'FLNPCAssetTableRowType::LoadActionGroupCodeNames' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, FloatingActionGroupCodeName) == 0x000060, "Member 'FLNPCAssetTableRowType::FloatingActionGroupCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, AI_StateMachine) == 0x000068, "Member 'FLNPCAssetTableRowType::AI_StateMachine' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, CharacterSoundType) == 0x000090, "Member 'FLNPCAssetTableRowType::CharacterSoundType' has a wrong offset!");
static_assert(offsetof(FLNPCAssetTableRowType, CharacterFxType) == 0x000098, "Member 'FLNPCAssetTableRowType::CharacterFxType' has a wrong offset!");

// ScriptStruct ProjectP.LQuartzPocketSynergy
// 0x000C (0x000C - 0x0000)
struct FLQuartzPocketSynergy final
{
public:
	class FName                                   SpecialBuffCodeName;                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivated;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLQuartzPocketSynergy) == 0x000004, "Wrong alignment on FLQuartzPocketSynergy");
static_assert(sizeof(FLQuartzPocketSynergy) == 0x00000C, "Wrong size on FLQuartzPocketSynergy");
static_assert(offsetof(FLQuartzPocketSynergy, SpecialBuffCodeName) == 0x000000, "Member 'FLQuartzPocketSynergy::SpecialBuffCodeName' has a wrong offset!");
static_assert(offsetof(FLQuartzPocketSynergy, bActivated) == 0x000008, "Member 'FLQuartzPocketSynergy::bActivated' has a wrong offset!");

// ScriptStruct ProjectP.LCharacterExitFunction
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FLCharacterExitFunction final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCharacterExitFunction) == 0x000004, "Wrong alignment on FLCharacterExitFunction");
static_assert(sizeof(FLCharacterExitFunction) == 0x000014, "Wrong size on FLCharacterExitFunction");

// ScriptStruct ProjectP.LNPCAimToTarget
// 0x0028 (0x0028 - 0x0000)
struct FLNPCAimToTarget final
{
public:
	class FName                                   FireBoneName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FireLocationOffset;                                // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetBoneName;                                    // 0x0014(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocationOffset;                              // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCAimToTarget) == 0x000004, "Wrong alignment on FLNPCAimToTarget");
static_assert(sizeof(FLNPCAimToTarget) == 0x000028, "Wrong size on FLNPCAimToTarget");
static_assert(offsetof(FLNPCAimToTarget, FireBoneName) == 0x000000, "Member 'FLNPCAimToTarget::FireBoneName' has a wrong offset!");
static_assert(offsetof(FLNPCAimToTarget, FireLocationOffset) == 0x000008, "Member 'FLNPCAimToTarget::FireLocationOffset' has a wrong offset!");
static_assert(offsetof(FLNPCAimToTarget, TargetBoneName) == 0x000014, "Member 'FLNPCAimToTarget::TargetBoneName' has a wrong offset!");
static_assert(offsetof(FLNPCAimToTarget, TargetLocationOffset) == 0x00001C, "Member 'FLNPCAimToTarget::TargetLocationOffset' has a wrong offset!");

// ScriptStruct ProjectP.LSmashFxTableRowType
// 0x0100 (0x0108 - 0x0008)
struct FLSmashFxTableRowType final : public FTableRowBase
{
public:
	ELPhysicalSurfaceType                         Attacker_Material;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Ground_Material;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELSwingPowerType                              Power;                                             // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ColorParameters;                                   // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x00D8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CameraShakeTableCodeName;                          // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSmashFxTableRowType) == 0x000008, "Wrong alignment on FLSmashFxTableRowType");
static_assert(sizeof(FLSmashFxTableRowType) == 0x000108, "Wrong size on FLSmashFxTableRowType");
static_assert(offsetof(FLSmashFxTableRowType, Attacker_Material) == 0x000008, "Member 'FLSmashFxTableRowType::Attacker_Material' has a wrong offset!");
static_assert(offsetof(FLSmashFxTableRowType, Ground_Material) == 0x000009, "Member 'FLSmashFxTableRowType::Ground_Material' has a wrong offset!");
static_assert(offsetof(FLSmashFxTableRowType, Power) == 0x00000A, "Member 'FLSmashFxTableRowType::Power' has a wrong offset!");
static_assert(offsetof(FLSmashFxTableRowType, Niagara) == 0x000010, "Member 'FLSmashFxTableRowType::Niagara' has a wrong offset!");
static_assert(offsetof(FLSmashFxTableRowType, ScalarParameters) == 0x000038, "Member 'FLSmashFxTableRowType::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FLSmashFxTableRowType, ColorParameters) == 0x000088, "Member 'FLSmashFxTableRowType::ColorParameters' has a wrong offset!");
static_assert(offsetof(FLSmashFxTableRowType, Sound) == 0x0000D8, "Member 'FLSmashFxTableRowType::Sound' has a wrong offset!");
static_assert(offsetof(FLSmashFxTableRowType, CameraShakeTableCodeName) == 0x000100, "Member 'FLSmashFxTableRowType::CameraShakeTableCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LMonsterCameraModifier
// 0x0020 (0x0020 - 0x0000)
struct FLMonsterCameraModifier final
{
public:
	uint8                                         bLockOnUseLookAtUpperLocation : 1;                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bModifyCameraDistance : 1;                         // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bModifyLockOnPitch : 1;                            // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bModifyLockOnLocationOffset : 1;                   // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bModifyLockOnCollectDistance : 1;                  // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraDistance;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnPitchMin;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockOnPitchMax;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockOnLocationOffset;                              // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectDistance;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMonsterCameraModifier) == 0x000004, "Wrong alignment on FLMonsterCameraModifier");
static_assert(sizeof(FLMonsterCameraModifier) == 0x000020, "Wrong size on FLMonsterCameraModifier");
static_assert(offsetof(FLMonsterCameraModifier, CameraDistance) == 0x000004, "Member 'FLMonsterCameraModifier::CameraDistance' has a wrong offset!");
static_assert(offsetof(FLMonsterCameraModifier, LockOnPitchMin) == 0x000008, "Member 'FLMonsterCameraModifier::LockOnPitchMin' has a wrong offset!");
static_assert(offsetof(FLMonsterCameraModifier, LockOnPitchMax) == 0x00000C, "Member 'FLMonsterCameraModifier::LockOnPitchMax' has a wrong offset!");
static_assert(offsetof(FLMonsterCameraModifier, LockOnLocationOffset) == 0x000010, "Member 'FLMonsterCameraModifier::LockOnLocationOffset' has a wrong offset!");
static_assert(offsetof(FLMonsterCameraModifier, CollectDistance) == 0x00001C, "Member 'FLMonsterCameraModifier::CollectDistance' has a wrong offset!");

// ScriptStruct ProjectP.LWeatherSoundTable
// 0x0008 (0x0008 - 0x0000)
struct FLWeatherSoundTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLWeatherSoundTable) == 0x000008, "Wrong alignment on FLWeatherSoundTable");
static_assert(sizeof(FLWeatherSoundTable) == 0x000008, "Wrong size on FLWeatherSoundTable");
static_assert(offsetof(FLWeatherSoundTable, Table) == 0x000000, "Member 'FLWeatherSoundTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LAngleInterval
// 0x0008 (0x0008 - 0x0000)
struct FLAngleInterval final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAngleInterval) == 0x000004, "Wrong alignment on FLAngleInterval");
static_assert(sizeof(FLAngleInterval) == 0x000008, "Wrong size on FLAngleInterval");
static_assert(offsetof(FLAngleInterval, Min) == 0x000000, "Member 'FLAngleInterval::Min' has a wrong offset!");
static_assert(offsetof(FLAngleInterval, Max) == 0x000004, "Member 'FLAngleInterval::Max' has a wrong offset!");

// ScriptStruct ProjectP.LTalkerStorage
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLTalkerStorage final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLTalkerStorage) == 0x000008, "Wrong alignment on FLTalkerStorage");
static_assert(sizeof(FLTalkerStorage) == 0x000050, "Wrong size on FLTalkerStorage");

// ScriptStruct ProjectP.LAIObjective
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FLAIObjective
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAIObjective) == 0x000004, "Wrong alignment on FLAIObjective");
static_assert(sizeof(FLAIObjective) == 0x000024, "Wrong size on FLAIObjective");

// ScriptStruct ProjectP.LAISettings
// 0x0001 (0x0001 - 0x0000)
struct FLAISettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAISettings) == 0x000001, "Wrong alignment on FLAISettings");
static_assert(sizeof(FLAISettings) == 0x000001, "Wrong size on FLAISettings");

// ScriptStruct ProjectP.LWeatherFxTableRow
// 0x00D8 (0x00E0 - 0x0008)
struct FLWeatherFxTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      DefaultScalarParameters;                           // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              DefaultColorParameters;                            // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWeatherFxTableRow) == 0x000008, "Wrong alignment on FLWeatherFxTableRow");
static_assert(sizeof(FLWeatherFxTableRow) == 0x0000E0, "Wrong size on FLWeatherFxTableRow");
static_assert(offsetof(FLWeatherFxTableRow, Niagara) == 0x000008, "Member 'FLWeatherFxTableRow::Niagara' has a wrong offset!");
static_assert(offsetof(FLWeatherFxTableRow, Offset) == 0x000030, "Member 'FLWeatherFxTableRow::Offset' has a wrong offset!");
static_assert(offsetof(FLWeatherFxTableRow, DefaultScalarParameters) == 0x000040, "Member 'FLWeatherFxTableRow::DefaultScalarParameters' has a wrong offset!");
static_assert(offsetof(FLWeatherFxTableRow, DefaultColorParameters) == 0x000090, "Member 'FLWeatherFxTableRow::DefaultColorParameters' has a wrong offset!");

// ScriptStruct ProjectP.LAISenseTakeLocation
// 0x0018 (0x0018 - 0x0000)
struct FLAISenseTakeLocation final
{
public:
	ELAISense                                     Sense;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TakeLocation;                                      // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAISenseTakeLocation) == 0x000004, "Wrong alignment on FLAISenseTakeLocation");
static_assert(sizeof(FLAISenseTakeLocation) == 0x000018, "Wrong size on FLAISenseTakeLocation");
static_assert(offsetof(FLAISenseTakeLocation, Sense) == 0x000000, "Member 'FLAISenseTakeLocation::Sense' has a wrong offset!");
static_assert(offsetof(FLAISenseTakeLocation, TargetActor) == 0x000004, "Member 'FLAISenseTakeLocation::TargetActor' has a wrong offset!");
static_assert(offsetof(FLAISenseTakeLocation, TakeLocation) == 0x00000C, "Member 'FLAISenseTakeLocation::TakeLocation' has a wrong offset!");

// ScriptStruct ProjectP.LSectionRotationSpeed
// 0x000C (0x000C - 0x0000)
struct FLSectionRotationSpeed final
{
public:
	float                                         Speed0to60;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed60To120;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed120To180;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSectionRotationSpeed) == 0x000004, "Wrong alignment on FLSectionRotationSpeed");
static_assert(sizeof(FLSectionRotationSpeed) == 0x00000C, "Wrong size on FLSectionRotationSpeed");
static_assert(offsetof(FLSectionRotationSpeed, Speed0to60) == 0x000000, "Member 'FLSectionRotationSpeed::Speed0to60' has a wrong offset!");
static_assert(offsetof(FLSectionRotationSpeed, Speed60To120) == 0x000004, "Member 'FLSectionRotationSpeed::Speed60To120' has a wrong offset!");
static_assert(offsetof(FLSectionRotationSpeed, Speed120To180) == 0x000008, "Member 'FLSectionRotationSpeed::Speed120To180' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSpawnIdleOverride
// 0x0018 (0x0018 - 0x0000)
struct FLNPCSpawnIdleOverride final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightDistance;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDetectRange;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitiveRange;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitiveSpeed;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitiveTime;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCSpawnIdleOverride) == 0x000004, "Wrong alignment on FLNPCSpawnIdleOverride");
static_assert(sizeof(FLNPCSpawnIdleOverride) == 0x000018, "Wrong size on FLNPCSpawnIdleOverride");
static_assert(offsetof(FLNPCSpawnIdleOverride, SightDistance) == 0x000004, "Member 'FLNPCSpawnIdleOverride::SightDistance' has a wrong offset!");
static_assert(offsetof(FLNPCSpawnIdleOverride, TargetDetectRange) == 0x000008, "Member 'FLNPCSpawnIdleOverride::TargetDetectRange' has a wrong offset!");
static_assert(offsetof(FLNPCSpawnIdleOverride, SensitiveRange) == 0x00000C, "Member 'FLNPCSpawnIdleOverride::SensitiveRange' has a wrong offset!");
static_assert(offsetof(FLNPCSpawnIdleOverride, SensitiveSpeed) == 0x000010, "Member 'FLNPCSpawnIdleOverride::SensitiveSpeed' has a wrong offset!");
static_assert(offsetof(FLNPCSpawnIdleOverride, SensitiveTime) == 0x000014, "Member 'FLNPCSpawnIdleOverride::SensitiveTime' has a wrong offset!");

// ScriptStruct ProjectP.LNPCInfoOverride
// 0x003C (0x003C - 0x0000)
struct FLNPCInfoOverride final
{
public:
	bool                                          DataExist;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ArriveCheckRange;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnDistance;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PursuitDistance;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HelpSignalRange;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HelpSignalEnable;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetDetectRangePeace;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightDistancePeace;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightHeight;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightAngle;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitiveRange;                                    // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitiveSpeed;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensitiveTime;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoamRange;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bRoamRangeOverride : 1;                            // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCInfoOverride) == 0x000004, "Wrong alignment on FLNPCInfoOverride");
static_assert(sizeof(FLNPCInfoOverride) == 0x00003C, "Wrong size on FLNPCInfoOverride");
static_assert(offsetof(FLNPCInfoOverride, DataExist) == 0x000000, "Member 'FLNPCInfoOverride::DataExist' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, ArriveCheckRange) == 0x000004, "Member 'FLNPCInfoOverride::ArriveCheckRange' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, ReturnDistance) == 0x000008, "Member 'FLNPCInfoOverride::ReturnDistance' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, PursuitDistance) == 0x00000C, "Member 'FLNPCInfoOverride::PursuitDistance' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, HelpSignalRange) == 0x000010, "Member 'FLNPCInfoOverride::HelpSignalRange' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, HelpSignalEnable) == 0x000014, "Member 'FLNPCInfoOverride::HelpSignalEnable' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, TargetDetectRangePeace) == 0x000018, "Member 'FLNPCInfoOverride::TargetDetectRangePeace' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, SightDistancePeace) == 0x00001C, "Member 'FLNPCInfoOverride::SightDistancePeace' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, SightHeight) == 0x000020, "Member 'FLNPCInfoOverride::SightHeight' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, SightAngle) == 0x000024, "Member 'FLNPCInfoOverride::SightAngle' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, SensitiveRange) == 0x000028, "Member 'FLNPCInfoOverride::SensitiveRange' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, SensitiveSpeed) == 0x00002C, "Member 'FLNPCInfoOverride::SensitiveSpeed' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, SensitiveTime) == 0x000030, "Member 'FLNPCInfoOverride::SensitiveTime' has a wrong offset!");
static_assert(offsetof(FLNPCInfoOverride, RoamRange) == 0x000034, "Member 'FLNPCInfoOverride::RoamRange' has a wrong offset!");

// ScriptStruct ProjectP.TweenEase
// 0x000C (0x000C - 0x0000)
struct FTweenEase final
{
public:
	ETweenEasingType                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Steps;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTweenEase) == 0x000004, "Wrong alignment on FTweenEase");
static_assert(sizeof(FTweenEase) == 0x00000C, "Wrong size on FTweenEase");
static_assert(offsetof(FTweenEase, Type) == 0x000000, "Member 'FTweenEase::Type' has a wrong offset!");
static_assert(offsetof(FTweenEase, BlendExp) == 0x000004, "Member 'FTweenEase::BlendExp' has a wrong offset!");
static_assert(offsetof(FTweenEase, Steps) == 0x000008, "Member 'FTweenEase::Steps' has a wrong offset!");

// ScriptStruct ProjectP.LAIMoveReduceChecker
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLAIMoveReduceChecker final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAIMoveReduceChecker) == 0x000008, "Wrong alignment on FLAIMoveReduceChecker");
static_assert(sizeof(FLAIMoveReduceChecker) == 0x000028, "Wrong size on FLAIMoveReduceChecker");

// ScriptStruct ProjectP.LPathWayMovement
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x08) FLPathWayMovement final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bStartPathWayMove : 1;                             // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bArriveLastWayPointAndFinished : 1;                // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForwardDirection : 1;                             // 0x00A0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WayPointIndexToMove;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPathWayMovement) == 0x000008, "Wrong alignment on FLPathWayMovement");
static_assert(sizeof(FLPathWayMovement) == 0x0000B0, "Wrong size on FLPathWayMovement");
static_assert(offsetof(FLPathWayMovement, WayPointIndexToMove) == 0x0000A8, "Member 'FLPathWayMovement::WayPointIndexToMove' has a wrong offset!");

// ScriptStruct ProjectP.LNPCMovement
// 0x03C0 (0x03C0 - 0x0000)
struct FLNPCMovement final
{
public:
	struct FLPathWayMovement                      PathWayMovement;                                   // 0x0000(0x00B0)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bMovementDesiredRotation : 1;                      // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C1[0x47];                                      // 0x00C1(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      AdditiveSpeedRates;                                // 0x0108(0x0050)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         TotalSpeedRate;                                    // 0x0158(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseSpeedRate;                                     // 0x015C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x260];                                    // 0x0160(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCMovement) == 0x000008, "Wrong alignment on FLNPCMovement");
static_assert(sizeof(FLNPCMovement) == 0x0003C0, "Wrong size on FLNPCMovement");
static_assert(offsetof(FLNPCMovement, PathWayMovement) == 0x000000, "Member 'FLNPCMovement::PathWayMovement' has a wrong offset!");
static_assert(offsetof(FLNPCMovement, AdditiveSpeedRates) == 0x000108, "Member 'FLNPCMovement::AdditiveSpeedRates' has a wrong offset!");
static_assert(offsetof(FLNPCMovement, TotalSpeedRate) == 0x000158, "Member 'FLNPCMovement::TotalSpeedRate' has a wrong offset!");
static_assert(offsetof(FLNPCMovement, BaseSpeedRate) == 0x00015C, "Member 'FLNPCMovement::BaseSpeedRate' has a wrong offset!");

// ScriptStruct ProjectP.LWeaponTranformData
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FLWeaponTranformData final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWeaponTranformData) == 0x000008, "Wrong alignment on FLWeaponTranformData");
static_assert(sizeof(FLWeaponTranformData) == 0x000038, "Wrong size on FLWeaponTranformData");

// ScriptStruct ProjectP.LMoveSpeedLayers
// 0x0010 (0x0010 - 0x0000)
struct FLMoveSpeedLayers final
{
public:
	float                                         NPCSpeedRatio;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorSpeedRatio;                                // 0x0004(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSpeedRatio;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditiveSpeedRatio;                                // 0x000C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLMoveSpeedLayers) == 0x000004, "Wrong alignment on FLMoveSpeedLayers");
static_assert(sizeof(FLMoveSpeedLayers) == 0x000010, "Wrong size on FLMoveSpeedLayers");
static_assert(offsetof(FLMoveSpeedLayers, NPCSpeedRatio) == 0x000000, "Member 'FLMoveSpeedLayers::NPCSpeedRatio' has a wrong offset!");
static_assert(offsetof(FLMoveSpeedLayers, BehaviorSpeedRatio) == 0x000004, "Member 'FLMoveSpeedLayers::BehaviorSpeedRatio' has a wrong offset!");
static_assert(offsetof(FLMoveSpeedLayers, BaseSpeedRatio) == 0x000008, "Member 'FLMoveSpeedLayers::BaseSpeedRatio' has a wrong offset!");
static_assert(offsetof(FLMoveSpeedLayers, AdditiveSpeedRatio) == 0x00000C, "Member 'FLMoveSpeedLayers::AdditiveSpeedRatio' has a wrong offset!");

// ScriptStruct ProjectP.ContentCommandInfoList
// 0x0010 (0x0010 - 0x0000)
struct FContentCommandInfoList final
{
public:
	TArray<struct FContentCommandInfoPtr>         Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentCommandInfoList) == 0x000008, "Wrong alignment on FContentCommandInfoList");
static_assert(sizeof(FContentCommandInfoList) == 0x000010, "Wrong size on FContentCommandInfoList");
static_assert(offsetof(FContentCommandInfoList, Items) == 0x000000, "Member 'FContentCommandInfoList::Items' has a wrong offset!");

// ScriptStruct ProjectP.LPathLengthCache
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x08) FLPathLengthCache final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPathLengthCache) == 0x000008, "Wrong alignment on FLPathLengthCache");
static_assert(sizeof(FLPathLengthCache) == 0x000040, "Wrong size on FLPathLengthCache");

// ScriptStruct ProjectP.LNaviOnMovement
// 0x00C8 (0x00C8 - 0x0000)
struct alignas(0x08) FLNaviOnMovement final
{
public:
	uint8                                         Pad_0[0xC8];                                       // 0x0000(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNaviOnMovement) == 0x000008, "Wrong alignment on FLNaviOnMovement");
static_assert(sizeof(FLNaviOnMovement) == 0x0000C8, "Wrong size on FLNaviOnMovement");

// ScriptStruct ProjectP.LSwingSFXTable
// 0x0060 (0x0060 - 0x0000)
struct FLSwingSFXTable
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             Table;                                             // 0x0008(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSwingSFXTable) == 0x000008, "Wrong alignment on FLSwingSFXTable");
static_assert(sizeof(FLSwingSFXTable) == 0x000060, "Wrong size on FLSwingSFXTable");
static_assert(offsetof(FLSwingSFXTable, Table) == 0x000008, "Member 'FLSwingSFXTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LAIBaseMovement
// 0x0110 (0x0110 - 0x0000)
struct alignas(0x08) FLAIBaseMovement final
{
public:
	uint8                                         Pad_0[0x110];                                      // 0x0000(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAIBaseMovement) == 0x000008, "Wrong alignment on FLAIBaseMovement");
static_assert(sizeof(FLAIBaseMovement) == 0x000110, "Wrong size on FLAIBaseMovement");

// ScriptStruct ProjectP.LAIMovementID
// 0x004C (0x004C - 0x0000)
struct alignas(0x04) FLAIMovementID final
{
public:
	uint8                                         Pad_0[0x4C];                                       // 0x0000(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAIMovementID) == 0x000004, "Wrong alignment on FLAIMovementID");
static_assert(sizeof(FLAIMovementID) == 0x00004C, "Wrong size on FLAIMovementID");

// ScriptStruct ProjectP.LAIMoveBehaviorID
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FLAIMoveBehaviorID final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAIMoveBehaviorID) == 0x000004, "Wrong alignment on FLAIMoveBehaviorID");
static_assert(sizeof(FLAIMoveBehaviorID) == 0x000004, "Wrong size on FLAIMoveBehaviorID");

// ScriptStruct ProjectP.LAIMovementDirection
// 0x0004 (0x0028 - 0x0024)
struct FLAIMovementDirection final : public FLAIObjective
{
public:
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAIMovementDirection) == 0x000004, "Wrong alignment on FLAIMovementDirection");
static_assert(sizeof(FLAIMovementDirection) == 0x000028, "Wrong size on FLAIMovementDirection");

// ScriptStruct ProjectP.LWidgetTable
// 0x0070 (0x0070 - 0x0000)
struct FLWidgetTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         WidgetClasses;                                     // 0x0008(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class UClass*>              WidgetClassMap;                                    // 0x0018(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWidgetTable) == 0x000008, "Wrong alignment on FLWidgetTable");
static_assert(sizeof(FLWidgetTable) == 0x000070, "Wrong size on FLWidgetTable");
static_assert(offsetof(FLWidgetTable, Table) == 0x000000, "Member 'FLWidgetTable::Table' has a wrong offset!");
static_assert(offsetof(FLWidgetTable, WidgetClasses) == 0x000008, "Member 'FLWidgetTable::WidgetClasses' has a wrong offset!");
static_assert(offsetof(FLWidgetTable, WidgetClassMap) == 0x000018, "Member 'FLWidgetTable::WidgetClassMap' has a wrong offset!");

// ScriptStruct ProjectP.LAIMovementGoal
// 0x0008 (0x002C - 0x0024)
struct FLAIMovementGoal final : public FLAIObjective
{
public:
	uint8                                         Pad_24[0x8];                                       // 0x0024(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAIMovementGoal) == 0x000004, "Wrong alignment on FLAIMovementGoal");
static_assert(sizeof(FLAIMovementGoal) == 0x00002C, "Wrong size on FLAIMovementGoal");

// ScriptStruct ProjectP.LNPCPerception
// 0x0130 (0x0130 - 0x0000)
struct alignas(0x08) FLNPCPerception final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayTime_ActiveSensitiveWalk;                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayTime_ActiveSensitiveRun;                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayTime_ActiveSensitiveSprint;                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SensitiveSpeed_RunCheckThreshold;                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bEnable_AllSenses : 1;                             // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnable_Damage : 1;                                // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnable_Sensitive : 1;                             // 0x0020(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnable_Sight : 1;                                 // 0x0020(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnable_Warning : 1;                               // 0x0020(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSeeThrough : 1;                                   // 0x0020(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_21[0x10F];                                     // 0x0021(0x010F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCPerception) == 0x000008, "Wrong alignment on FLNPCPerception");
static_assert(sizeof(FLNPCPerception) == 0x000130, "Wrong size on FLNPCPerception");
static_assert(offsetof(FLNPCPerception, DelayTime_ActiveSensitiveWalk) == 0x000010, "Member 'FLNPCPerception::DelayTime_ActiveSensitiveWalk' has a wrong offset!");
static_assert(offsetof(FLNPCPerception, DelayTime_ActiveSensitiveRun) == 0x000014, "Member 'FLNPCPerception::DelayTime_ActiveSensitiveRun' has a wrong offset!");
static_assert(offsetof(FLNPCPerception, DelayTime_ActiveSensitiveSprint) == 0x000018, "Member 'FLNPCPerception::DelayTime_ActiveSensitiveSprint' has a wrong offset!");
static_assert(offsetof(FLNPCPerception, SensitiveSpeed_RunCheckThreshold) == 0x00001C, "Member 'FLNPCPerception::SensitiveSpeed_RunCheckThreshold' has a wrong offset!");

// ScriptStruct ProjectP.LNPCStandbySkill
// 0x000C (0x000C - 0x0000)
struct FLNPCStandbySkill final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Percent;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCStandbySkill) == 0x000004, "Wrong alignment on FLNPCStandbySkill");
static_assert(sizeof(FLNPCStandbySkill) == 0x00000C, "Wrong size on FLNPCStandbySkill");
static_assert(offsetof(FLNPCStandbySkill, SkillCodeName) == 0x000000, "Member 'FLNPCStandbySkill::SkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCStandbySkill, Percent) == 0x000008, "Member 'FLNPCStandbySkill::Percent' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSkillLaunch
// 0x00C0 (0x00C0 - 0x0000)
struct FLNPCSkillLaunch final
{
public:
	uint8                                         bUseSkillCooltime : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseGlobalCooltime : 1;                            // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillCodeName;                                     // 0x0004(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContinueSkillCodeName;                             // 0x000C(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LaunchActionId;                                    // 0x0014(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULActBase>               LaunchAction;                                      // 0x001C(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ULActBase>               LastAction;                                        // 0x0024(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RequestActionIdList;                               // 0x0030(0x0010)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	TSet<class FName>                             LinkSkillUseCooltimeList;                          // 0x0040(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)
	struct FLAIObjective                          SkillTarget;                                       // 0x0090(0x0024)(Edit, Transient, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0xC];                                       // 0x00B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCSkillLaunch) == 0x000008, "Wrong alignment on FLNPCSkillLaunch");
static_assert(sizeof(FLNPCSkillLaunch) == 0x0000C0, "Wrong size on FLNPCSkillLaunch");
static_assert(offsetof(FLNPCSkillLaunch, SkillCodeName) == 0x000004, "Member 'FLNPCSkillLaunch::SkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLaunch, ContinueSkillCodeName) == 0x00000C, "Member 'FLNPCSkillLaunch::ContinueSkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLaunch, LaunchActionId) == 0x000014, "Member 'FLNPCSkillLaunch::LaunchActionId' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLaunch, LaunchAction) == 0x00001C, "Member 'FLNPCSkillLaunch::LaunchAction' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLaunch, LastAction) == 0x000024, "Member 'FLNPCSkillLaunch::LastAction' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLaunch, RequestActionIdList) == 0x000030, "Member 'FLNPCSkillLaunch::RequestActionIdList' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLaunch, LinkSkillUseCooltimeList) == 0x000040, "Member 'FLNPCSkillLaunch::LinkSkillUseCooltimeList' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLaunch, SkillTarget) == 0x000090, "Member 'FLNPCSkillLaunch::SkillTarget' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSkillLinkConditionCheck
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FLNPCSkillLinkConditionCheck final
{
public:
	uint8                                         CheckOnce : 1;                                     // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCheckPercentInFirstRun : 1;                       // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPercentResult : 1;                                // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bRecieveHit : 1;                                   // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillLinkCodeName;                                 // 0x0004(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x84];                                       // 0x000C(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCSkillLinkConditionCheck) == 0x000008, "Wrong alignment on FLNPCSkillLinkConditionCheck");
static_assert(sizeof(FLNPCSkillLinkConditionCheck) == 0x000090, "Wrong size on FLNPCSkillLinkConditionCheck");
static_assert(offsetof(FLNPCSkillLinkConditionCheck, SkillLinkCodeName) == 0x000004, "Member 'FLNPCSkillLinkConditionCheck::SkillLinkCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSelectedSkill
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLNPCSelectedSkill final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCSelectedSkill) == 0x000008, "Wrong alignment on FLNPCSelectedSkill");
static_assert(sizeof(FLNPCSelectedSkill) == 0x000010, "Wrong size on FLNPCSelectedSkill");
static_assert(offsetof(FLNPCSelectedSkill, SkillCodeName) == 0x000000, "Member 'FLNPCSelectedSkill::SkillCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSkillModifyCooltime
// 0x0008 (0x0008 - 0x0000)
struct FLNPCSkillModifyCooltime final
{
public:
	bool                                          bModified;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELAIFloatValueType                            ValueType;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCSkillModifyCooltime) == 0x000004, "Wrong alignment on FLNPCSkillModifyCooltime");
static_assert(sizeof(FLNPCSkillModifyCooltime) == 0x000008, "Wrong size on FLNPCSkillModifyCooltime");
static_assert(offsetof(FLNPCSkillModifyCooltime, bModified) == 0x000000, "Member 'FLNPCSkillModifyCooltime::bModified' has a wrong offset!");
static_assert(offsetof(FLNPCSkillModifyCooltime, ValueType) == 0x000001, "Member 'FLNPCSkillModifyCooltime::ValueType' has a wrong offset!");
static_assert(offsetof(FLNPCSkillModifyCooltime, Value) == 0x000004, "Member 'FLNPCSkillModifyCooltime::Value' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSkillLauncher
// 0x0260 (0x0260 - 0x0000)
struct FLNPCSkillLauncher final
{
public:
	ELAIDamageType                                LastHitDamageType;                                 // 0x0000(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastHitDamageSkillCodeName;                        // 0x0004(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ALNPCController*                        Controller;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALNPCCharacter*                         Character;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLNPCSkillLaunch                       LaunchedSkill;                                     // 0x0020(0x00C0)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLNPCStandbySkill>              OriginalSkillList;                                 // 0x00E0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLNPCStandbySkill>              StandbySkillList;                                  // 0x00F0(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         PossibleStandbySkillListCount;                     // 0x0100(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLNPCSkillLinkConditionCheck>   SkillLinkConditionChecks;                          // 0x0108(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLNPCSkillLinkConditionCheck>   SpawnIdleConditionChecks;                          // 0x0118(0x0010)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class FName                                   SpawnIdleNextSkillCodeName;                        // 0x0128(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLNPCSelectedSkill                     SelectedSkill;                                     // 0x0130(0x0010)(Edit, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      SkillCooltimes;                                    // 0x0140(0x0050)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         GlobalSkillCooltime;                               // 0x0190(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FLNPCSkillModifyCooltime> ModifySkillCooltimes;                              // 0x0198(0x0050)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FLNPCSkillModifyCooltime               ModifyGlobalSkillCooltime;                         // 0x01E8(0x0008)(Edit, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             HitTargetActionEventInLaunchSkill;                 // 0x01F0(0x0050)(Edit, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class FName                                   LastUsedSkillCodeName;                             // 0x0240(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AIUseSkilllCount;                                  // 0x0248(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SkillLinkSkillCount;                               // 0x024C(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCSkillLauncher) == 0x000008, "Wrong alignment on FLNPCSkillLauncher");
static_assert(sizeof(FLNPCSkillLauncher) == 0x000260, "Wrong size on FLNPCSkillLauncher");
static_assert(offsetof(FLNPCSkillLauncher, LastHitDamageType) == 0x000000, "Member 'FLNPCSkillLauncher::LastHitDamageType' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, LastHitDamageSkillCodeName) == 0x000004, "Member 'FLNPCSkillLauncher::LastHitDamageSkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, Controller) == 0x000010, "Member 'FLNPCSkillLauncher::Controller' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, Character) == 0x000018, "Member 'FLNPCSkillLauncher::Character' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, LaunchedSkill) == 0x000020, "Member 'FLNPCSkillLauncher::LaunchedSkill' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, OriginalSkillList) == 0x0000E0, "Member 'FLNPCSkillLauncher::OriginalSkillList' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, StandbySkillList) == 0x0000F0, "Member 'FLNPCSkillLauncher::StandbySkillList' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, PossibleStandbySkillListCount) == 0x000100, "Member 'FLNPCSkillLauncher::PossibleStandbySkillListCount' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, SkillLinkConditionChecks) == 0x000108, "Member 'FLNPCSkillLauncher::SkillLinkConditionChecks' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, SpawnIdleConditionChecks) == 0x000118, "Member 'FLNPCSkillLauncher::SpawnIdleConditionChecks' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, SpawnIdleNextSkillCodeName) == 0x000128, "Member 'FLNPCSkillLauncher::SpawnIdleNextSkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, SelectedSkill) == 0x000130, "Member 'FLNPCSkillLauncher::SelectedSkill' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, SkillCooltimes) == 0x000140, "Member 'FLNPCSkillLauncher::SkillCooltimes' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, GlobalSkillCooltime) == 0x000190, "Member 'FLNPCSkillLauncher::GlobalSkillCooltime' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, ModifySkillCooltimes) == 0x000198, "Member 'FLNPCSkillLauncher::ModifySkillCooltimes' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, ModifyGlobalSkillCooltime) == 0x0001E8, "Member 'FLNPCSkillLauncher::ModifyGlobalSkillCooltime' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, HitTargetActionEventInLaunchSkill) == 0x0001F0, "Member 'FLNPCSkillLauncher::HitTargetActionEventInLaunchSkill' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, LastUsedSkillCodeName) == 0x000240, "Member 'FLNPCSkillLauncher::LastUsedSkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, AIUseSkilllCount) == 0x000248, "Member 'FLNPCSkillLauncher::AIUseSkilllCount' has a wrong offset!");
static_assert(offsetof(FLNPCSkillLauncher, SkillLinkSkillCount) == 0x00024C, "Member 'FLNPCSkillLauncher::SkillLinkSkillCount' has a wrong offset!");

// ScriptStruct ProjectP.LTutorialCoolTime
// 0x0010 (0x0010 - 0x0000)
struct FLTutorialCoolTime final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemainCoolTime;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GroupData;                                         // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLTutorialCoolTime) == 0x000004, "Wrong alignment on FLTutorialCoolTime");
static_assert(sizeof(FLTutorialCoolTime) == 0x000010, "Wrong size on FLTutorialCoolTime");
static_assert(offsetof(FLTutorialCoolTime, TutorialCodeName) == 0x000000, "Member 'FLTutorialCoolTime::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(FLTutorialCoolTime, RemainCoolTime) == 0x000008, "Member 'FLTutorialCoolTime::RemainCoolTime' has a wrong offset!");
static_assert(offsetof(FLTutorialCoolTime, GroupData) == 0x00000C, "Member 'FLTutorialCoolTime::GroupData' has a wrong offset!");

// ScriptStruct ProjectP.ContentConditionInfoList
// 0x0010 (0x0010 - 0x0000)
struct FContentConditionInfoList final
{
public:
	TArray<struct FContentConditionInfoPtr>       Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentConditionInfoList) == 0x000008, "Wrong alignment on FContentConditionInfoList");
static_assert(sizeof(FContentConditionInfoList) == 0x000010, "Wrong size on FContentConditionInfoList");
static_assert(offsetof(FContentConditionInfoList, Items) == 0x000000, "Member 'FContentConditionInfoList::Items' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSkillHistory_Skill
// 0x0014 (0x0014 - 0x0000)
struct FLNPCSkillHistory_Skill final
{
public:
	class FName                                   SkillCodeName;                                     // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillLinkCodeName;                                 // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectedSkill;                                    // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckRange_Try;                                   // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckRange_Result;                                // 0x0012(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCSkillHistory_Skill) == 0x000004, "Wrong alignment on FLNPCSkillHistory_Skill");
static_assert(sizeof(FLNPCSkillHistory_Skill) == 0x000014, "Wrong size on FLNPCSkillHistory_Skill");
static_assert(offsetof(FLNPCSkillHistory_Skill, SkillCodeName) == 0x000000, "Member 'FLNPCSkillHistory_Skill::SkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillHistory_Skill, SkillLinkCodeName) == 0x000008, "Member 'FLNPCSkillHistory_Skill::SkillLinkCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillHistory_Skill, bSelectedSkill) == 0x000010, "Member 'FLNPCSkillHistory_Skill::bSelectedSkill' has a wrong offset!");
static_assert(offsetof(FLNPCSkillHistory_Skill, bCheckRange_Try) == 0x000011, "Member 'FLNPCSkillHistory_Skill::bCheckRange_Try' has a wrong offset!");
static_assert(offsetof(FLNPCSkillHistory_Skill, bCheckRange_Result) == 0x000012, "Member 'FLNPCSkillHistory_Skill::bCheckRange_Result' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSkillHistoryInfo
// 0x0020 (0x0020 - 0x0000)
struct FLNPCSkillHistoryInfo final
{
public:
	int32                                         HistoryIndex;                                      // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSkillCodeName;                                // 0x0004(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLNPCSkillHistory_Skill>        Skills;                                            // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCSkillHistoryInfo) == 0x000008, "Wrong alignment on FLNPCSkillHistoryInfo");
static_assert(sizeof(FLNPCSkillHistoryInfo) == 0x000020, "Wrong size on FLNPCSkillHistoryInfo");
static_assert(offsetof(FLNPCSkillHistoryInfo, HistoryIndex) == 0x000000, "Member 'FLNPCSkillHistoryInfo::HistoryIndex' has a wrong offset!");
static_assert(offsetof(FLNPCSkillHistoryInfo, StartSkillCodeName) == 0x000004, "Member 'FLNPCSkillHistoryInfo::StartSkillCodeName' has a wrong offset!");
static_assert(offsetof(FLNPCSkillHistoryInfo, Skills) == 0x000010, "Member 'FLNPCSkillHistoryInfo::Skills' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSkillLaunchResult
// 0x0008 (0x0008 - 0x0000)
struct FLNPCSkillLaunchResult final
{
public:
	class ULActBase*                              Action;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLNPCSkillLaunchResult) == 0x000008, "Wrong alignment on FLNPCSkillLaunchResult");
static_assert(sizeof(FLNPCSkillLaunchResult) == 0x000008, "Wrong size on FLNPCSkillLaunchResult");
static_assert(offsetof(FLNPCSkillLaunchResult, Action) == 0x000000, "Member 'FLNPCSkillLaunchResult::Action' has a wrong offset!");

// ScriptStruct ProjectP.LNPCSpecCondActivator
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FLNPCSpecCondActivator final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCSpecCondActivator) == 0x000004, "Wrong alignment on FLNPCSpecCondActivator");
static_assert(sizeof(FLNPCSpecCondActivator) == 0x000018, "Wrong size on FLNPCSpecCondActivator");

// ScriptStruct ProjectP.LEnvSoundTableRow
// 0x0038 (0x0040 - 0x0008)
struct FLEnvSoundTableRow final : public FTableRowBase
{
public:
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Material;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLEnvSoundTableRow) == 0x000008, "Wrong alignment on FLEnvSoundTableRow");
static_assert(sizeof(FLEnvSoundTableRow) == 0x000040, "Wrong size on FLEnvSoundTableRow");
static_assert(offsetof(FLEnvSoundTableRow, EventName) == 0x000008, "Member 'FLEnvSoundTableRow::EventName' has a wrong offset!");
static_assert(offsetof(FLEnvSoundTableRow, Material) == 0x000010, "Member 'FLEnvSoundTableRow::Material' has a wrong offset!");
static_assert(offsetof(FLEnvSoundTableRow, Sound) == 0x000018, "Member 'FLEnvSoundTableRow::Sound' has a wrong offset!");

// ScriptStruct ProjectP.LNPCAssetCollector
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FLNPCAssetCollector final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCAssetCollector) == 0x000008, "Wrong alignment on FLNPCAssetCollector");
static_assert(sizeof(FLNPCAssetCollector) == 0x000090, "Wrong size on FLNPCAssetCollector");

// ScriptStruct ProjectP.LCachedCollectAssets
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLCachedCollectAssets final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLCachedCollectAssets) == 0x000008, "Wrong alignment on FLCachedCollectAssets");
static_assert(sizeof(FLCachedCollectAssets) == 0x000050, "Wrong size on FLCachedCollectAssets");

// ScriptStruct ProjectP.LButterflyNPCGroupMember
// 0x000C (0x000C - 0x0000)
struct FLButterflyNPCGroupMember final
{
public:
	TWeakObjectPtr<class ALNPCSpot>               ButterFlyNPCSpotRef;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncActiveDelay;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLButterflyNPCGroupMember) == 0x000004, "Wrong alignment on FLButterflyNPCGroupMember");
static_assert(sizeof(FLButterflyNPCGroupMember) == 0x00000C, "Wrong size on FLButterflyNPCGroupMember");
static_assert(offsetof(FLButterflyNPCGroupMember, ButterFlyNPCSpotRef) == 0x000000, "Member 'FLButterflyNPCGroupMember::ButterFlyNPCSpotRef' has a wrong offset!");
static_assert(offsetof(FLButterflyNPCGroupMember, SyncActiveDelay) == 0x000008, "Member 'FLButterflyNPCGroupMember::SyncActiveDelay' has a wrong offset!");

// ScriptStruct ProjectP.LNPCTargetEntity
// 0x000C (0x000C - 0x0000)
struct FLNPCTargetEntity final
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPendingDestory;                                   // 0x0008(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNPCTargetEntity) == 0x000004, "Wrong alignment on FLNPCTargetEntity");
static_assert(sizeof(FLNPCTargetEntity) == 0x00000C, "Wrong size on FLNPCTargetEntity");
static_assert(offsetof(FLNPCTargetEntity, Actor) == 0x000000, "Member 'FLNPCTargetEntity::Actor' has a wrong offset!");
static_assert(offsetof(FLNPCTargetEntity, bPendingDestory) == 0x000008, "Member 'FLNPCTargetEntity::bPendingDestory' has a wrong offset!");

// ScriptStruct ProjectP.LNPCTargeting
// 0x0050 (0x0050 - 0x0000)
struct FLNPCTargeting final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDetectPCFirst : 1;                                // 0x0010(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSelectedPrimaryTarget : 1;                        // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bValidWarningLocation : 1;                         // 0x0010(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLNPCTargetEntity>              ManagedTargetList;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FLNPCTargetEntity                      ForcePrimaryTarget;                                // 0x0028(0x000C)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLNPCTargetEntity                      PrimaryTargetEntity;                               // 0x0034(0x000C)(Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                WarningLocation;                                   // 0x0040(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangePrimaryTargetTime;                           // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FLNPCTargeting) == 0x000008, "Wrong alignment on FLNPCTargeting");
static_assert(sizeof(FLNPCTargeting) == 0x000050, "Wrong size on FLNPCTargeting");
static_assert(offsetof(FLNPCTargeting, ManagedTargetList) == 0x000018, "Member 'FLNPCTargeting::ManagedTargetList' has a wrong offset!");
static_assert(offsetof(FLNPCTargeting, ForcePrimaryTarget) == 0x000028, "Member 'FLNPCTargeting::ForcePrimaryTarget' has a wrong offset!");
static_assert(offsetof(FLNPCTargeting, PrimaryTargetEntity) == 0x000034, "Member 'FLNPCTargeting::PrimaryTargetEntity' has a wrong offset!");
static_assert(offsetof(FLNPCTargeting, WarningLocation) == 0x000040, "Member 'FLNPCTargeting::WarningLocation' has a wrong offset!");
static_assert(offsetof(FLNPCTargeting, ChangePrimaryTargetTime) == 0x00004C, "Member 'FLNPCTargeting::ChangePrimaryTargetTime' has a wrong offset!");

// ScriptStruct ProjectP.LLoadDetailStat
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FLLoadDetailStat final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLoadDetailStat) == 0x000004, "Wrong alignment on FLLoadDetailStat");
static_assert(sizeof(FLLoadDetailStat) == 0x00000C, "Wrong size on FLLoadDetailStat");

// ScriptStruct ProjectP.LSpotManagementSettings
// 0x001C (0x001C - 0x0000)
struct FLSpotManagementSettings final
{
public:
	int32                                         NumToCheckOutbound;                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotInOutBoundOffset;                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsyncLoadDistance;                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCountToAsyncLoad;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDistance;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCountToSpawn;                                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnHoldTime;                                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSpotManagementSettings) == 0x000004, "Wrong alignment on FLSpotManagementSettings");
static_assert(sizeof(FLSpotManagementSettings) == 0x00001C, "Wrong size on FLSpotManagementSettings");
static_assert(offsetof(FLSpotManagementSettings, NumToCheckOutbound) == 0x000000, "Member 'FLSpotManagementSettings::NumToCheckOutbound' has a wrong offset!");
static_assert(offsetof(FLSpotManagementSettings, SpotInOutBoundOffset) == 0x000004, "Member 'FLSpotManagementSettings::SpotInOutBoundOffset' has a wrong offset!");
static_assert(offsetof(FLSpotManagementSettings, AsyncLoadDistance) == 0x000008, "Member 'FLSpotManagementSettings::AsyncLoadDistance' has a wrong offset!");
static_assert(offsetof(FLSpotManagementSettings, MaxCountToAsyncLoad) == 0x00000C, "Member 'FLSpotManagementSettings::MaxCountToAsyncLoad' has a wrong offset!");
static_assert(offsetof(FLSpotManagementSettings, SpawnDistance) == 0x000010, "Member 'FLSpotManagementSettings::SpawnDistance' has a wrong offset!");
static_assert(offsetof(FLSpotManagementSettings, MaxCountToSpawn) == 0x000014, "Member 'FLSpotManagementSettings::MaxCountToSpawn' has a wrong offset!");
static_assert(offsetof(FLSpotManagementSettings, SpawnHoldTime) == 0x000018, "Member 'FLSpotManagementSettings::SpawnHoldTime' has a wrong offset!");

// ScriptStruct ProjectP.LLoadingScreenData
// 0x00A0 (0x00A0 - 0x0000)
struct FLLoadingScreenData final
{
public:
	TSet<class FName>                             ConsumedFirstDrawPriorityCodeNames;                // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TSet<class FName>                             ConsumedFirstDrawChainTipCodeNames;                // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLoadingScreenData) == 0x000008, "Wrong alignment on FLLoadingScreenData");
static_assert(sizeof(FLLoadingScreenData) == 0x0000A0, "Wrong size on FLLoadingScreenData");
static_assert(offsetof(FLLoadingScreenData, ConsumedFirstDrawPriorityCodeNames) == 0x000000, "Member 'FLLoadingScreenData::ConsumedFirstDrawPriorityCodeNames' has a wrong offset!");
static_assert(offsetof(FLLoadingScreenData, ConsumedFirstDrawChainTipCodeNames) == 0x000050, "Member 'FLLoadingScreenData::ConsumedFirstDrawChainTipCodeNames' has a wrong offset!");

// ScriptStruct ProjectP.LNpcDeadbodySettings
// 0x000C (0x000C - 0x0000)
struct FLNpcDeadbodySettings final
{
public:
	int32                                         MaxCount;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DespawnDistance;                                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveFromSpot;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLNpcDeadbodySettings) == 0x000004, "Wrong alignment on FLNpcDeadbodySettings");
static_assert(sizeof(FLNpcDeadbodySettings) == 0x00000C, "Wrong size on FLNpcDeadbodySettings");
static_assert(offsetof(FLNpcDeadbodySettings, MaxCount) == 0x000000, "Member 'FLNpcDeadbodySettings::MaxCount' has a wrong offset!");
static_assert(offsetof(FLNpcDeadbodySettings, DespawnDistance) == 0x000004, "Member 'FLNpcDeadbodySettings::DespawnDistance' has a wrong offset!");
static_assert(offsetof(FLNpcDeadbodySettings, bRemoveFromSpot) == 0x000008, "Member 'FLNpcDeadbodySettings::bRemoveFromSpot' has a wrong offset!");

// ScriptStruct ProjectP.LPreloadAssetTableRow
// 0x0010 (0x0018 - 0x0008)
struct FLPreloadAssetTableRow final : public FTableRowBase
{
public:
	TArray<TSoftObjectPtr<class UObject>>         Assets;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPreloadAssetTableRow) == 0x000008, "Wrong alignment on FLPreloadAssetTableRow");
static_assert(sizeof(FLPreloadAssetTableRow) == 0x000018, "Wrong size on FLPreloadAssetTableRow");
static_assert(offsetof(FLPreloadAssetTableRow, Assets) == 0x000008, "Member 'FLPreloadAssetTableRow::Assets' has a wrong offset!");

// ScriptStruct ProjectP.LPoolingObjectHolder
// 0x0010 (0x0010 - 0x0000)
struct FLPoolingObjectHolder final
{
public:
	TArray<class UObject*>                        ObjectList;                                        // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPoolingObjectHolder) == 0x000008, "Wrong alignment on FLPoolingObjectHolder");
static_assert(sizeof(FLPoolingObjectHolder) == 0x000010, "Wrong size on FLPoolingObjectHolder");
static_assert(offsetof(FLPoolingObjectHolder, ObjectList) == 0x000000, "Member 'FLPoolingObjectHolder::ObjectList' has a wrong offset!");

// ScriptStruct ProjectP.LLockOnImportanceWeight
// 0x0008 (0x0008 - 0x0000)
struct FLLockOnImportanceWeight final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLockOnImportanceWeight) == 0x000004, "Wrong alignment on FLLockOnImportanceWeight");
static_assert(sizeof(FLLockOnImportanceWeight) == 0x000008, "Wrong size on FLLockOnImportanceWeight");
static_assert(offsetof(FLLockOnImportanceWeight, Distance) == 0x000000, "Member 'FLLockOnImportanceWeight::Distance' has a wrong offset!");
static_assert(offsetof(FLLockOnImportanceWeight, FOV) == 0x000004, "Member 'FLLockOnImportanceWeight::FOV' has a wrong offset!");

// ScriptStruct ProjectP.LScalabilityValue
// 0x0008 (0x0008 - 0x0000)
struct FLScalabilityValue final
{
public:
	EScalabilityType                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLScalabilityValue) == 0x000004, "Wrong alignment on FLScalabilityValue");
static_assert(sizeof(FLScalabilityValue) == 0x000008, "Wrong size on FLScalabilityValue");
static_assert(offsetof(FLScalabilityValue, Type) == 0x000000, "Member 'FLScalabilityValue::Type' has a wrong offset!");
static_assert(offsetof(FLScalabilityValue, Value) == 0x000004, "Member 'FLScalabilityValue::Value' has a wrong offset!");

// ScriptStruct ProjectP.LPartsBuildData
// 0x0048 (0x0048 - 0x0000)
struct FLPartsBuildData final
{
public:
	uint8                                         bDropItemAlreadyDroped : 1;                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnTemplate, Transient, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DestructionIndex;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALPartsActor*                           PartsActor;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PartsActorBP;                                      // 0x0010(0x0028)(Edit, DisableEditOnTemplate, Transient, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPartsBuildData) == 0x000008, "Wrong alignment on FLPartsBuildData");
static_assert(sizeof(FLPartsBuildData) == 0x000048, "Wrong size on FLPartsBuildData");
static_assert(offsetof(FLPartsBuildData, DestructionIndex) == 0x000004, "Member 'FLPartsBuildData::DestructionIndex' has a wrong offset!");
static_assert(offsetof(FLPartsBuildData, PartsActor) == 0x000008, "Member 'FLPartsBuildData::PartsActor' has a wrong offset!");
static_assert(offsetof(FLPartsBuildData, PartsActorBP) == 0x000010, "Member 'FLPartsBuildData::PartsActorBP' has a wrong offset!");

// ScriptStruct ProjectP.LPartsAssetTable
// 0x0008 (0x0008 - 0x0000)
struct FLPartsAssetTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLPartsAssetTable) == 0x000008, "Wrong alignment on FLPartsAssetTable");
static_assert(sizeof(FLPartsAssetTable) == 0x000008, "Wrong size on FLPartsAssetTable");
static_assert(offsetof(FLPartsAssetTable, Table) == 0x000000, "Member 'FLPartsAssetTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LPartsAssetTableRowType
// 0x0038 (0x0040 - 0x0008)
struct FLPartsAssetTableRowType final : public FTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Parts_BP;                                          // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPartsAssetTableRowType) == 0x000008, "Wrong alignment on FLPartsAssetTableRowType");
static_assert(sizeof(FLPartsAssetTableRowType) == 0x000040, "Wrong size on FLPartsAssetTableRowType");
static_assert(offsetof(FLPartsAssetTableRowType, Description) == 0x000008, "Member 'FLPartsAssetTableRowType::Description' has a wrong offset!");
static_assert(offsetof(FLPartsAssetTableRowType, Parts_BP) == 0x000018, "Member 'FLPartsAssetTableRowType::Parts_BP' has a wrong offset!");

// ScriptStruct ProjectP.LWorldMapInfo
// 0x000C (0x000C - 0x0000)
struct FLWorldMapInfo final
{
public:
	ELWorldMapType                                MapType;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapName;                                           // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLWorldMapInfo) == 0x000004, "Wrong alignment on FLWorldMapInfo");
static_assert(sizeof(FLWorldMapInfo) == 0x00000C, "Wrong size on FLWorldMapInfo");
static_assert(offsetof(FLWorldMapInfo, MapType) == 0x000000, "Member 'FLWorldMapInfo::MapType' has a wrong offset!");
static_assert(offsetof(FLWorldMapInfo, MapName) == 0x000004, "Member 'FLWorldMapInfo::MapName' has a wrong offset!");

// ScriptStruct ProjectP.LPatchRewardItemInOrder
// 0x0010 (0x0010 - 0x0000)
struct FLPatchRewardItemInOrder final
{
public:
	class ULItem*                                 Item;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPatchRewardItemInOrder) == 0x000008, "Wrong alignment on FLPatchRewardItemInOrder");
static_assert(sizeof(FLPatchRewardItemInOrder) == 0x000010, "Wrong size on FLPatchRewardItemInOrder");
static_assert(offsetof(FLPatchRewardItemInOrder, Item) == 0x000000, "Member 'FLPatchRewardItemInOrder::Item' has a wrong offset!");

// ScriptStruct ProjectP.LPathWay
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FLPathWay final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPathWay) == 0x000008, "Wrong alignment on FLPathWay");
static_assert(sizeof(FLPathWay) == 0x000020, "Wrong size on FLPathWay");

// ScriptStruct ProjectP.RespawnPayload
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FRespawnPayload final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRespawnPayload) == 0x000004, "Wrong alignment on FRespawnPayload");
static_assert(sizeof(FRespawnPayload) == 0x000010, "Wrong size on FRespawnPayload");

// ScriptStruct ProjectP.LWayPoint
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FLWayPoint final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLWayPoint) == 0x000004, "Wrong alignment on FLWayPoint");
static_assert(sizeof(FLWayPoint) == 0x000014, "Wrong size on FLWayPoint");

// ScriptStruct ProjectP.LPathWayPointData
// 0x0008 (0x0008 - 0x0000)
struct FLPathWayPointData final
{
public:
	float                                         WaitTime;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivalRadius;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPathWayPointData) == 0x000004, "Wrong alignment on FLPathWayPointData");
static_assert(sizeof(FLPathWayPointData) == 0x000008, "Wrong size on FLPathWayPointData");
static_assert(offsetof(FLPathWayPointData, WaitTime) == 0x000000, "Member 'FLPathWayPointData::WaitTime' has a wrong offset!");
static_assert(offsetof(FLPathWayPointData, ArrivalRadius) == 0x000004, "Member 'FLPathWayPointData::ArrivalRadius' has a wrong offset!");

// ScriptStruct ProjectP.LPCAssetCollector
// 0x0001 (0x0001 - 0x0000)
struct FLPCAssetCollector final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPCAssetCollector) == 0x000001, "Wrong alignment on FLPCAssetCollector");
static_assert(sizeof(FLPCAssetCollector) == 0x000001, "Wrong size on FLPCAssetCollector");

// ScriptStruct ProjectP.LAudioListenerPosition
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x04) FLAudioListenerPosition final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAudioListenerPosition) == 0x000004, "Wrong alignment on FLAudioListenerPosition");
static_assert(sizeof(FLAudioListenerPosition) == 0x000050, "Wrong size on FLAudioListenerPosition");

// ScriptStruct ProjectP.LSwingSFX_PC_Table
// 0x0000 (0x0060 - 0x0060)
struct FLSwingSFX_PC_Table final : public FLSwingSFXTable
{
};
static_assert(alignof(FLSwingSFX_PC_Table) == 0x000008, "Wrong alignment on FLSwingSFX_PC_Table");
static_assert(sizeof(FLSwingSFX_PC_Table) == 0x000060, "Wrong size on FLSwingSFX_PC_Table");

// ScriptStruct ProjectP.LPhysicsInfo_PhysicsAsset
// 0x0008 (0x0008 - 0x0000)
struct FLPhysicsInfo_PhysicsAsset final
{
public:
	TWeakObjectPtr<class UPhysicsAsset>           PhysicsAsset;                                      // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPhysicsInfo_PhysicsAsset) == 0x000004, "Wrong alignment on FLPhysicsInfo_PhysicsAsset");
static_assert(sizeof(FLPhysicsInfo_PhysicsAsset) == 0x000008, "Wrong size on FLPhysicsInfo_PhysicsAsset");
static_assert(offsetof(FLPhysicsInfo_PhysicsAsset, PhysicsAsset) == 0x000000, "Member 'FLPhysicsInfo_PhysicsAsset::PhysicsAsset' has a wrong offset!");

// ScriptStruct ProjectP.LPhysicsInfo_Explosion
// 0x0200 (0x0200 - 0x0000)
struct FLPhysicsInfo_Explosion final
{
public:
	struct FLHitInfo                              HitInfo;                                           // 0x0000(0x0150)(BlueprintVisible, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FLExplosionMeshInfo                    ExplosionMeshInfo;                                 // 0x0150(0x00A8)(BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  Murderer;                                          // 0x01F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPhysicsInfo_Explosion) == 0x000008, "Wrong alignment on FLPhysicsInfo_Explosion");
static_assert(sizeof(FLPhysicsInfo_Explosion) == 0x000200, "Wrong size on FLPhysicsInfo_Explosion");
static_assert(offsetof(FLPhysicsInfo_Explosion, HitInfo) == 0x000000, "Member 'FLPhysicsInfo_Explosion::HitInfo' has a wrong offset!");
static_assert(offsetof(FLPhysicsInfo_Explosion, ExplosionMeshInfo) == 0x000150, "Member 'FLPhysicsInfo_Explosion::ExplosionMeshInfo' has a wrong offset!");
static_assert(offsetof(FLPhysicsInfo_Explosion, Murderer) == 0x0001F8, "Member 'FLPhysicsInfo_Explosion::Murderer' has a wrong offset!");

// ScriptStruct ProjectP.LPhysicsInfo_RagDoll
// 0x0001 (0x0001 - 0x0000)
struct FLPhysicsInfo_RagDoll final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPhysicsInfo_RagDoll) == 0x000001, "Wrong alignment on FLPhysicsInfo_RagDoll");
static_assert(sizeof(FLPhysicsInfo_RagDoll) == 0x000001, "Wrong size on FLPhysicsInfo_RagDoll");

// ScriptStruct ProjectP.LPhysicsInfo_PhysicalAnimation
// 0x0001 (0x0001 - 0x0000)
struct FLPhysicsInfo_PhysicalAnimation final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPhysicsInfo_PhysicalAnimation) == 0x000001, "Wrong alignment on FLPhysicsInfo_PhysicalAnimation");
static_assert(sizeof(FLPhysicsInfo_PhysicalAnimation) == 0x000001, "Wrong size on FLPhysicsInfo_PhysicalAnimation");

// ScriptStruct ProjectP.LTutorialHierarchyInfo
// 0x0068 (0x0068 - 0x0000)
struct FLTutorialHierarchyInfo final
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStep;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayCount;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayCount;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FTutorialInfoPtr>          SetpInfoMap;                                       // 0x0018(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTutorialHierarchyInfo) == 0x000008, "Wrong alignment on FLTutorialHierarchyInfo");
static_assert(sizeof(FLTutorialHierarchyInfo) == 0x000068, "Wrong size on FLTutorialHierarchyInfo");
static_assert(offsetof(FLTutorialHierarchyInfo, TutorialCodeName) == 0x000000, "Member 'FLTutorialHierarchyInfo::TutorialCodeName' has a wrong offset!");
static_assert(offsetof(FLTutorialHierarchyInfo, MaxStep) == 0x000008, "Member 'FLTutorialHierarchyInfo::MaxStep' has a wrong offset!");
static_assert(offsetof(FLTutorialHierarchyInfo, MaxPlayCount) == 0x00000C, "Member 'FLTutorialHierarchyInfo::MaxPlayCount' has a wrong offset!");
static_assert(offsetof(FLTutorialHierarchyInfo, PlayCount) == 0x000010, "Member 'FLTutorialHierarchyInfo::PlayCount' has a wrong offset!");
static_assert(offsetof(FLTutorialHierarchyInfo, SetpInfoMap) == 0x000018, "Member 'FLTutorialHierarchyInfo::SetpInfoMap' has a wrong offset!");

// ScriptStruct ProjectP.LPhysicsInfo_NoPhysics
// 0x0001 (0x0001 - 0x0000)
struct FLPhysicsInfo_NoPhysics final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPhysicsInfo_NoPhysics) == 0x000001, "Wrong alignment on FLPhysicsInfo_NoPhysics");
static_assert(sizeof(FLPhysicsInfo_NoPhysics) == 0x000001, "Wrong size on FLPhysicsInfo_NoPhysics");

// ScriptStruct ProjectP.LPhysicalSurfaceSoundTable
// 0x0058 (0x0058 - 0x0000)
struct FLPhysicalSurfaceSoundTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPhysicalSurfaceSoundTable) == 0x000008, "Wrong alignment on FLPhysicalSurfaceSoundTable");
static_assert(sizeof(FLPhysicalSurfaceSoundTable) == 0x000058, "Wrong size on FLPhysicalSurfaceSoundTable");
static_assert(offsetof(FLPhysicalSurfaceSoundTable, Table) == 0x000000, "Member 'FLPhysicalSurfaceSoundTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LPhysicalSurfaceSoundRow
// 0x00C8 (0x00D0 - 0x0008)
struct FLPhysicalSurfaceSoundRow final : public FTableRowBase
{
public:
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         MaterialType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceFXConditionType              Condition;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCurve;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     VolumeCurve;                                       // 0x0048(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPhysicalSurfaceSoundRow) == 0x000008, "Wrong alignment on FLPhysicalSurfaceSoundRow");
static_assert(sizeof(FLPhysicalSurfaceSoundRow) == 0x0000D0, "Wrong size on FLPhysicalSurfaceSoundRow");
static_assert(offsetof(FLPhysicalSurfaceSoundRow, EventName) == 0x000008, "Member 'FLPhysicalSurfaceSoundRow::EventName' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceSoundRow, MaterialType) == 0x000010, "Member 'FLPhysicalSurfaceSoundRow::MaterialType' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceSoundRow, Condition) == 0x000011, "Member 'FLPhysicalSurfaceSoundRow::Condition' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceSoundRow, Sound) == 0x000018, "Member 'FLPhysicalSurfaceSoundRow::Sound' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceSoundRow, bUseCurve) == 0x000040, "Member 'FLPhysicalSurfaceSoundRow::bUseCurve' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceSoundRow, VolumeCurve) == 0x000048, "Member 'FLPhysicalSurfaceSoundRow::VolumeCurve' has a wrong offset!");

// ScriptStruct ProjectP.LPhysicalSurfaceFxTable
// 0x0058 (0x0058 - 0x0000)
struct FLPhysicalSurfaceFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPhysicalSurfaceFxTable) == 0x000008, "Wrong alignment on FLPhysicalSurfaceFxTable");
static_assert(sizeof(FLPhysicalSurfaceFxTable) == 0x000058, "Wrong size on FLPhysicalSurfaceFxTable");
static_assert(offsetof(FLPhysicalSurfaceFxTable, Table) == 0x000000, "Member 'FLPhysicalSurfaceFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LLoadingScreenContext
// 0x000C (0x000C - 0x0000)
struct FLLoadingScreenContext final
{
public:
	ELLoadingScreenUsage                          Usage;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LoadingScreenTableCodeName;                        // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLoadingScreenContext) == 0x000004, "Wrong alignment on FLLoadingScreenContext");
static_assert(sizeof(FLLoadingScreenContext) == 0x00000C, "Wrong size on FLLoadingScreenContext");
static_assert(offsetof(FLLoadingScreenContext, Usage) == 0x000000, "Member 'FLLoadingScreenContext::Usage' has a wrong offset!");
static_assert(offsetof(FLLoadingScreenContext, LoadingScreenTableCodeName) == 0x000004, "Member 'FLLoadingScreenContext::LoadingScreenTableCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LPhysicalSurfaceFxRow
// 0x01A0 (0x01A8 - 0x0008)
struct FLPhysicalSurfaceFxRow final : public FTableRowBase
{
public:
	class FName                                   EventName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         MaterialType;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceFXConditionType              Condition;                                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0040(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ColorParameters;                                   // 0x0090(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FLNiagaraWithParameters_Simple         Niagara_when_speed_up;                             // 0x00E0(0x00C8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPhysicalSurfaceFxRow) == 0x000008, "Wrong alignment on FLPhysicalSurfaceFxRow");
static_assert(sizeof(FLPhysicalSurfaceFxRow) == 0x0001A8, "Wrong size on FLPhysicalSurfaceFxRow");
static_assert(offsetof(FLPhysicalSurfaceFxRow, EventName) == 0x000008, "Member 'FLPhysicalSurfaceFxRow::EventName' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceFxRow, MaterialType) == 0x000010, "Member 'FLPhysicalSurfaceFxRow::MaterialType' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceFxRow, Condition) == 0x000011, "Member 'FLPhysicalSurfaceFxRow::Condition' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceFxRow, Niagara) == 0x000018, "Member 'FLPhysicalSurfaceFxRow::Niagara' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceFxRow, ScalarParameters) == 0x000040, "Member 'FLPhysicalSurfaceFxRow::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceFxRow, ColorParameters) == 0x000090, "Member 'FLPhysicalSurfaceFxRow::ColorParameters' has a wrong offset!");
static_assert(offsetof(FLPhysicalSurfaceFxRow, Niagara_when_speed_up) == 0x0000E0, "Member 'FLPhysicalSurfaceFxRow::Niagara_when_speed_up' has a wrong offset!");

// ScriptStruct ProjectP.LAssistUseItemSlot
// 0x000C (0x000C - 0x0000)
struct FLAssistUseItemSlot final
{
public:
	ELAssistUseItemSlotType                       SlotType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemCodeName;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAssistUseItemSlot) == 0x000004, "Wrong alignment on FLAssistUseItemSlot");
static_assert(sizeof(FLAssistUseItemSlot) == 0x00000C, "Wrong size on FLAssistUseItemSlot");
static_assert(offsetof(FLAssistUseItemSlot, SlotType) == 0x000000, "Member 'FLAssistUseItemSlot::SlotType' has a wrong offset!");
static_assert(offsetof(FLAssistUseItemSlot, ItemCodeName) == 0x000004, "Member 'FLAssistUseItemSlot::ItemCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LInputAxisSpeedMapping
// 0x0010 (0x0010 - 0x0000)
struct FLInputAxisSpeedMapping final
{
public:
	float                                         AxisValue;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpTransitionTime;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownTransitionTime;                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLInputAxisSpeedMapping) == 0x000004, "Wrong alignment on FLInputAxisSpeedMapping");
static_assert(sizeof(FLInputAxisSpeedMapping) == 0x000010, "Wrong size on FLInputAxisSpeedMapping");
static_assert(offsetof(FLInputAxisSpeedMapping, AxisValue) == 0x000000, "Member 'FLInputAxisSpeedMapping::AxisValue' has a wrong offset!");
static_assert(offsetof(FLInputAxisSpeedMapping, MaxSpeed) == 0x000004, "Member 'FLInputAxisSpeedMapping::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FLInputAxisSpeedMapping, UpTransitionTime) == 0x000008, "Member 'FLInputAxisSpeedMapping::UpTransitionTime' has a wrong offset!");
static_assert(offsetof(FLInputAxisSpeedMapping, DownTransitionTime) == 0x00000C, "Member 'FLInputAxisSpeedMapping::DownTransitionTime' has a wrong offset!");

// ScriptStruct ProjectP.LSpecialShopExchangeNeeds
// 0x0018 (0x0018 - 0x0000)
struct FLSpecialShopExchangeNeeds final
{
public:
	TArray<struct FLVariableData>                 Items;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         Ergos;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSpecialShopExchangeNeeds) == 0x000008, "Wrong alignment on FLSpecialShopExchangeNeeds");
static_assert(sizeof(FLSpecialShopExchangeNeeds) == 0x000018, "Wrong size on FLSpecialShopExchangeNeeds");
static_assert(offsetof(FLSpecialShopExchangeNeeds, Items) == 0x000000, "Member 'FLSpecialShopExchangeNeeds::Items' has a wrong offset!");
static_assert(offsetof(FLSpecialShopExchangeNeeds, Ergos) == 0x000010, "Member 'FLSpecialShopExchangeNeeds::Ergos' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileSpawnParameter
// 0x0090 (0x0090 - 0x0000)
struct FLProjectileSpawnParameter final
{
public:
	int64                                         HandleId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProjectileCodeName;                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 RootParentActor;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetActor;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseOverrideSpawnTransform;                        // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OverrideSpawnTransform;                            // 0x0060(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProjectileSpawnParameter) == 0x000010, "Wrong alignment on FLProjectileSpawnParameter");
static_assert(sizeof(FLProjectileSpawnParameter) == 0x000090, "Wrong size on FLProjectileSpawnParameter");
static_assert(offsetof(FLProjectileSpawnParameter, HandleId) == 0x000000, "Member 'FLProjectileSpawnParameter::HandleId' has a wrong offset!");
static_assert(offsetof(FLProjectileSpawnParameter, ProjectileCodeName) == 0x000008, "Member 'FLProjectileSpawnParameter::ProjectileCodeName' has a wrong offset!");
static_assert(offsetof(FLProjectileSpawnParameter, RootParentActor) == 0x000010, "Member 'FLProjectileSpawnParameter::RootParentActor' has a wrong offset!");
static_assert(offsetof(FLProjectileSpawnParameter, TargetActor) == 0x000018, "Member 'FLProjectileSpawnParameter::TargetActor' has a wrong offset!");
static_assert(offsetof(FLProjectileSpawnParameter, Offset) == 0x000020, "Member 'FLProjectileSpawnParameter::Offset' has a wrong offset!");
static_assert(offsetof(FLProjectileSpawnParameter, bUseOverrideSpawnTransform) == 0x000050, "Member 'FLProjectileSpawnParameter::bUseOverrideSpawnTransform' has a wrong offset!");
static_assert(offsetof(FLProjectileSpawnParameter, OverrideSpawnTransform) == 0x000060, "Member 'FLProjectileSpawnParameter::OverrideSpawnTransform' has a wrong offset!");

// ScriptStruct ProjectP.LChildProjectileSpawnInfo
// 0x0050 (0x0050 - 0x0000)
struct FLChildProjectileSpawnInfo final
{
public:
	class FName                                   ProjectileCodeName;                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileSpawnGenerateEnumType              SpawnGenerateType;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InitialStartDelay;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLChildProjectileSpawnInfo) == 0x000010, "Wrong alignment on FLChildProjectileSpawnInfo");
static_assert(sizeof(FLChildProjectileSpawnInfo) == 0x000050, "Wrong size on FLChildProjectileSpawnInfo");
static_assert(offsetof(FLChildProjectileSpawnInfo, ProjectileCodeName) == 0x000000, "Member 'FLChildProjectileSpawnInfo::ProjectileCodeName' has a wrong offset!");
static_assert(offsetof(FLChildProjectileSpawnInfo, SpawnGenerateType) == 0x000008, "Member 'FLChildProjectileSpawnInfo::SpawnGenerateType' has a wrong offset!");
static_assert(offsetof(FLChildProjectileSpawnInfo, OffsetTransform) == 0x000010, "Member 'FLChildProjectileSpawnInfo::OffsetTransform' has a wrong offset!");
static_assert(offsetof(FLChildProjectileSpawnInfo, InitialStartDelay) == 0x000040, "Member 'FLChildProjectileSpawnInfo::InitialStartDelay' has a wrong offset!");
static_assert(offsetof(FLChildProjectileSpawnInfo, Interval) == 0x000044, "Member 'FLChildProjectileSpawnInfo::Interval' has a wrong offset!");
static_assert(offsetof(FLChildProjectileSpawnInfo, MaxCount) == 0x000048, "Member 'FLChildProjectileSpawnInfo::MaxCount' has a wrong offset!");

// ScriptStruct ProjectP.LProjectileCollisionData_Cylinder
// 0x001C (0x001C - 0x0000)
struct FLProjectileCollisionData_Cylinder final
{
public:
	float                                         Height;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Outer_Radius;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Outer_Expansion_Speed;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Outer_Expansion_Duration;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inner_Radius;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inner_Expansion_Speed;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inner_Expansion_Duration;                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLProjectileCollisionData_Cylinder) == 0x000004, "Wrong alignment on FLProjectileCollisionData_Cylinder");
static_assert(sizeof(FLProjectileCollisionData_Cylinder) == 0x00001C, "Wrong size on FLProjectileCollisionData_Cylinder");
static_assert(offsetof(FLProjectileCollisionData_Cylinder, Height) == 0x000000, "Member 'FLProjectileCollisionData_Cylinder::Height' has a wrong offset!");
static_assert(offsetof(FLProjectileCollisionData_Cylinder, Outer_Radius) == 0x000004, "Member 'FLProjectileCollisionData_Cylinder::Outer_Radius' has a wrong offset!");
static_assert(offsetof(FLProjectileCollisionData_Cylinder, Outer_Expansion_Speed) == 0x000008, "Member 'FLProjectileCollisionData_Cylinder::Outer_Expansion_Speed' has a wrong offset!");
static_assert(offsetof(FLProjectileCollisionData_Cylinder, Outer_Expansion_Duration) == 0x00000C, "Member 'FLProjectileCollisionData_Cylinder::Outer_Expansion_Duration' has a wrong offset!");
static_assert(offsetof(FLProjectileCollisionData_Cylinder, Inner_Radius) == 0x000010, "Member 'FLProjectileCollisionData_Cylinder::Inner_Radius' has a wrong offset!");
static_assert(offsetof(FLProjectileCollisionData_Cylinder, Inner_Expansion_Speed) == 0x000014, "Member 'FLProjectileCollisionData_Cylinder::Inner_Expansion_Speed' has a wrong offset!");
static_assert(offsetof(FLProjectileCollisionData_Cylinder, Inner_Expansion_Duration) == 0x000018, "Member 'FLProjectileCollisionData_Cylinder::Inner_Expansion_Duration' has a wrong offset!");

// ScriptStruct ProjectP.LPropState
// 0x0018 (0x0018 - 0x0000)
struct FLPropState final
{
public:
	ELSpotType                                    SpotType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PropCodeName;                                      // 0x0004(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrState;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLPropState) == 0x000004, "Wrong alignment on FLPropState");
static_assert(sizeof(FLPropState) == 0x000018, "Wrong size on FLPropState");
static_assert(offsetof(FLPropState, SpotType) == 0x000000, "Member 'FLPropState::SpotType' has a wrong offset!");
static_assert(offsetof(FLPropState, PropCodeName) == 0x000004, "Member 'FLPropState::PropCodeName' has a wrong offset!");
static_assert(offsetof(FLPropState, CurrState) == 0x00000C, "Member 'FLPropState::CurrState' has a wrong offset!");

// ScriptStruct ProjectP.LLinkedPropInfo
// 0x0010 (0x0010 - 0x0000)
struct FLLinkedPropInfo final
{
public:
	class ALPropSpot*                             LinkedPropRef;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LinkedPropState;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LinkedPropChangeAnim;                              // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELLinkedPropExecuteType                       ExecuteTiming;                                     // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLLinkedPropInfo) == 0x000008, "Wrong alignment on FLLinkedPropInfo");
static_assert(sizeof(FLLinkedPropInfo) == 0x000010, "Wrong size on FLLinkedPropInfo");
static_assert(offsetof(FLLinkedPropInfo, LinkedPropRef) == 0x000000, "Member 'FLLinkedPropInfo::LinkedPropRef' has a wrong offset!");
static_assert(offsetof(FLLinkedPropInfo, LinkedPropState) == 0x000008, "Member 'FLLinkedPropInfo::LinkedPropState' has a wrong offset!");
static_assert(offsetof(FLLinkedPropInfo, LinkedPropChangeAnim) == 0x00000C, "Member 'FLLinkedPropInfo::LinkedPropChangeAnim' has a wrong offset!");
static_assert(offsetof(FLLinkedPropInfo, ExecuteTiming) == 0x00000D, "Member 'FLLinkedPropInfo::ExecuteTiming' has a wrong offset!");

// ScriptStruct ProjectP.LQuartzSlot
// 0x0010 (0x0010 - 0x0000)
struct FLQuartzSlot final
{
public:
	int32                                         SlotIndex;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELQuartzSlotStatusType                        Status;                                            // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuartzEffectInfoPtr                   QuartzEffectInfo;                                  // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLQuartzSlot) == 0x000008, "Wrong alignment on FLQuartzSlot");
static_assert(sizeof(FLQuartzSlot) == 0x000010, "Wrong size on FLQuartzSlot");
static_assert(offsetof(FLQuartzSlot, SlotIndex) == 0x000000, "Member 'FLQuartzSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(FLQuartzSlot, Status) == 0x000004, "Member 'FLQuartzSlot::Status' has a wrong offset!");
static_assert(offsetof(FLQuartzSlot, QuartzEffectInfo) == 0x000008, "Member 'FLQuartzSlot::QuartzEffectInfo' has a wrong offset!");

// ScriptStruct ProjectP.LAutoQuestInfoList
// 0x0050 (0x0050 - 0x0000)
struct FLAutoQuestInfoList final
{
public:
	TMap<class FString, struct FLNameList>        QuestParamMap;                                     // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAutoQuestInfoList) == 0x000008, "Wrong alignment on FLAutoQuestInfoList");
static_assert(sizeof(FLAutoQuestInfoList) == 0x000050, "Wrong size on FLAutoQuestInfoList");
static_assert(offsetof(FLAutoQuestInfoList, QuestParamMap) == 0x000000, "Member 'FLAutoQuestInfoList::QuestParamMap' has a wrong offset!");

// ScriptStruct ProjectP.LPatchRewardSaveData_Character
// 0x0050 (0x0050 - 0x0000)
struct FLPatchRewardSaveData_Character final
{
public:
	TMap<class FString, class FName>              AppliedPatchRewards;                               // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLPatchRewardSaveData_Character) == 0x000008, "Wrong alignment on FLPatchRewardSaveData_Character");
static_assert(sizeof(FLPatchRewardSaveData_Character) == 0x000050, "Wrong size on FLPatchRewardSaveData_Character");
static_assert(offsetof(FLPatchRewardSaveData_Character, AppliedPatchRewards) == 0x000000, "Member 'FLPatchRewardSaveData_Character::AppliedPatchRewards' has a wrong offset!");

// ScriptStruct ProjectP.LDLCSaveData_Character
// 0x0050 (0x0050 - 0x0000)
struct FLDLCSaveData_Character final
{
public:
	TMap<class FString, class FName>              AppliedDLCs;                                       // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDLCSaveData_Character) == 0x000008, "Wrong alignment on FLDLCSaveData_Character");
static_assert(sizeof(FLDLCSaveData_Character) == 0x000050, "Wrong size on FLDLCSaveData_Character");
static_assert(offsetof(FLDLCSaveData_Character, AppliedDLCs) == 0x000000, "Member 'FLDLCSaveData_Character::AppliedDLCs' has a wrong offset!");

// ScriptStruct ProjectP.LCinematicData
// 0x00A0 (0x00A0 - 0x0000)
struct FLCinematicData final
{
public:
	TSet<class FName>                             PlayedSequenceCodeNames;                           // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TSet<class FName>                             PlayedMovieCodeNames;                              // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLCinematicData) == 0x000008, "Wrong alignment on FLCinematicData");
static_assert(sizeof(FLCinematicData) == 0x0000A0, "Wrong size on FLCinematicData");
static_assert(offsetof(FLCinematicData, PlayedSequenceCodeNames) == 0x000000, "Member 'FLCinematicData::PlayedSequenceCodeNames' has a wrong offset!");
static_assert(offsetof(FLCinematicData, PlayedMovieCodeNames) == 0x000050, "Member 'FLCinematicData::PlayedMovieCodeNames' has a wrong offset!");

// ScriptStruct ProjectP.LDropItemSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLDropItemSaveData final
{
public:
	TArray<struct FLDropItemData>                 DropItemList;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLDropItemSaveData) == 0x000008, "Wrong alignment on FLDropItemSaveData");
static_assert(sizeof(FLDropItemSaveData) == 0x000010, "Wrong size on FLDropItemSaveData");
static_assert(offsetof(FLDropItemSaveData, DropItemList) == 0x000000, "Member 'FLDropItemSaveData::DropItemList' has a wrong offset!");

// ScriptStruct ProjectP.LQuestSaveData
// 0x0010 (0x0010 - 0x0000)
struct FLQuestSaveData final
{
public:
	TArray<struct FQuestDetailInfo>               QuestList;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLQuestSaveData) == 0x000008, "Wrong alignment on FLQuestSaveData");
static_assert(sizeof(FLQuestSaveData) == 0x000010, "Wrong size on FLQuestSaveData");
static_assert(offsetof(FLQuestSaveData, QuestList) == 0x000000, "Member 'FLQuestSaveData::QuestList' has a wrong offset!");

// ScriptStruct ProjectP.LSpotSaveData
// 0x00E0 (0x00E0 - 0x0000)
struct FLSpotSaveData final
{
public:
	TArray<struct FLNpcSpotData>                  NpcSpotList;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLPropSpotData>                 PropSpotList;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLPropItemSpotData>             PropItemSpotList;                                  // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLHelpMateSpotData>             HelpMateSpotList;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLTeleportObjectSpotData>       TeleportObjectSpotList;                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLShapeObjectSpotData>          ShapeObjectSpotList;                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLLadderSpotData>               LadderSpotList;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLLiftSpotData>                 LiftSpotList;                                      // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLLevelSequenceSpotData>        LevelSequenceSpotList;                             // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLBossRoomSpotData>             BossRoomSpotList;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLDoorSpotData>                 DoorSpotList;                                      // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLVolumeSpotData>               VolumeSpotList;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLDestructionSpotData>          DestructionSpotList;                               // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FLSpotEventData>                SpotEventDataList;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSpotSaveData) == 0x000008, "Wrong alignment on FLSpotSaveData");
static_assert(sizeof(FLSpotSaveData) == 0x0000E0, "Wrong size on FLSpotSaveData");
static_assert(offsetof(FLSpotSaveData, NpcSpotList) == 0x000000, "Member 'FLSpotSaveData::NpcSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, PropSpotList) == 0x000010, "Member 'FLSpotSaveData::PropSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, PropItemSpotList) == 0x000020, "Member 'FLSpotSaveData::PropItemSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, HelpMateSpotList) == 0x000030, "Member 'FLSpotSaveData::HelpMateSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, TeleportObjectSpotList) == 0x000040, "Member 'FLSpotSaveData::TeleportObjectSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, ShapeObjectSpotList) == 0x000050, "Member 'FLSpotSaveData::ShapeObjectSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, LadderSpotList) == 0x000060, "Member 'FLSpotSaveData::LadderSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, LiftSpotList) == 0x000070, "Member 'FLSpotSaveData::LiftSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, LevelSequenceSpotList) == 0x000080, "Member 'FLSpotSaveData::LevelSequenceSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, BossRoomSpotList) == 0x000090, "Member 'FLSpotSaveData::BossRoomSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, DoorSpotList) == 0x0000A0, "Member 'FLSpotSaveData::DoorSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, VolumeSpotList) == 0x0000B0, "Member 'FLSpotSaveData::VolumeSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, DestructionSpotList) == 0x0000C0, "Member 'FLSpotSaveData::DestructionSpotList' has a wrong offset!");
static_assert(offsetof(FLSpotSaveData, SpotEventDataList) == 0x0000D0, "Member 'FLSpotSaveData::SpotEventDataList' has a wrong offset!");

// ScriptStruct ProjectP.LSlaveArmInfoHolder
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLSlaveArmInfoHolder final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSlaveArmInfoHolder) == 0x000008, "Wrong alignment on FLSlaveArmInfoHolder");
static_assert(sizeof(FLSlaveArmInfoHolder) == 0x000010, "Wrong size on FLSlaveArmInfoHolder");

// ScriptStruct ProjectP.LSmashFxTable
// 0x0008 (0x0008 - 0x0000)
struct FLSmashFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLSmashFxTable) == 0x000008, "Wrong alignment on FLSmashFxTable");
static_assert(sizeof(FLSmashFxTable) == 0x000008, "Wrong size on FLSmashFxTable");
static_assert(offsetof(FLSmashFxTable, Table) == 0x000000, "Member 'FLSmashFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LSoundCueTable
// 0x0008 (0x0008 - 0x0000)
struct FLSoundCueTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLSoundCueTable) == 0x000008, "Wrong alignment on FLSoundCueTable");
static_assert(sizeof(FLSoundCueTable) == 0x000008, "Wrong size on FLSoundCueTable");
static_assert(offsetof(FLSoundCueTable, Table) == 0x000000, "Member 'FLSoundCueTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LRepulseSoundTable
// 0x0058 (0x0058 - 0x0000)
struct FLRepulseSoundTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLRepulseSoundTable) == 0x000008, "Wrong alignment on FLRepulseSoundTable");
static_assert(sizeof(FLRepulseSoundTable) == 0x000058, "Wrong size on FLRepulseSoundTable");
static_assert(offsetof(FLRepulseSoundTable, Table) == 0x000000, "Member 'FLRepulseSoundTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LSparkSoundTable
// 0x0058 (0x0058 - 0x0000)
struct FLSparkSoundTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8[0x50];                                       // 0x0008(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLSparkSoundTable) == 0x000008, "Wrong alignment on FLSparkSoundTable");
static_assert(sizeof(FLSparkSoundTable) == 0x000058, "Wrong size on FLSparkSoundTable");
static_assert(offsetof(FLSparkSoundTable, Table) == 0x000000, "Member 'FLSparkSoundTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LRepulseSoundTableRowType
// 0x0030 (0x0038 - 0x0008)
struct FLRepulseSoundTableRowType final : public FTableRowBase
{
public:
	ELPhysicalSurfaceType                         Attacker_Material;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Ground_Material;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLRepulseSoundTableRowType) == 0x000008, "Wrong alignment on FLRepulseSoundTableRowType");
static_assert(sizeof(FLRepulseSoundTableRowType) == 0x000038, "Wrong size on FLRepulseSoundTableRowType");
static_assert(offsetof(FLRepulseSoundTableRowType, Attacker_Material) == 0x000008, "Member 'FLRepulseSoundTableRowType::Attacker_Material' has a wrong offset!");
static_assert(offsetof(FLRepulseSoundTableRowType, Ground_Material) == 0x000009, "Member 'FLRepulseSoundTableRowType::Ground_Material' has a wrong offset!");
static_assert(offsetof(FLRepulseSoundTableRowType, Sound) == 0x000010, "Member 'FLRepulseSoundTableRowType::Sound' has a wrong offset!");

// ScriptStruct ProjectP.LSparkSoundTableRowType
// 0x0030 (0x0038 - 0x0008)
struct FLSparkSoundTableRowType final : public FTableRowBase
{
public:
	ELPhysicalSurfaceType                         Attacker_Material;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Ground_Material;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSparkSoundTableRowType) == 0x000008, "Wrong alignment on FLSparkSoundTableRowType");
static_assert(sizeof(FLSparkSoundTableRowType) == 0x000038, "Wrong size on FLSparkSoundTableRowType");
static_assert(offsetof(FLSparkSoundTableRowType, Attacker_Material) == 0x000008, "Member 'FLSparkSoundTableRowType::Attacker_Material' has a wrong offset!");
static_assert(offsetof(FLSparkSoundTableRowType, Ground_Material) == 0x000009, "Member 'FLSparkSoundTableRowType::Ground_Material' has a wrong offset!");
static_assert(offsetof(FLSparkSoundTableRowType, Sound) == 0x000010, "Member 'FLSparkSoundTableRowType::Sound' has a wrong offset!");

// ScriptStruct ProjectP.LSparkFxTableRowType
// 0x00D0 (0x00D8 - 0x0008)
struct FLSparkFxTableRowType final : public FTableRowBase
{
public:
	ELPhysicalSurfaceType                         Attacker_Material;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELPhysicalSurfaceType                         Ground_Material;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          Niagara;                                           // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ScalarParameters;                                  // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FName, struct FColor>              ColorParameters;                                   // 0x0088(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSparkFxTableRowType) == 0x000008, "Wrong alignment on FLSparkFxTableRowType");
static_assert(sizeof(FLSparkFxTableRowType) == 0x0000D8, "Wrong size on FLSparkFxTableRowType");
static_assert(offsetof(FLSparkFxTableRowType, Attacker_Material) == 0x000008, "Member 'FLSparkFxTableRowType::Attacker_Material' has a wrong offset!");
static_assert(offsetof(FLSparkFxTableRowType, Ground_Material) == 0x000009, "Member 'FLSparkFxTableRowType::Ground_Material' has a wrong offset!");
static_assert(offsetof(FLSparkFxTableRowType, Niagara) == 0x000010, "Member 'FLSparkFxTableRowType::Niagara' has a wrong offset!");
static_assert(offsetof(FLSparkFxTableRowType, ScalarParameters) == 0x000038, "Member 'FLSparkFxTableRowType::ScalarParameters' has a wrong offset!");
static_assert(offsetof(FLSparkFxTableRowType, ColorParameters) == 0x000088, "Member 'FLSparkFxTableRowType::ColorParameters' has a wrong offset!");

// ScriptStruct ProjectP.LSpecialBuffContainer
// 0x0010 (0x0010 - 0x0000)
struct FLSpecialBuffContainer final
{
public:
	TArray<class ULSpecialBuff*>                  BuffList;                                          // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSpecialBuffContainer) == 0x000008, "Wrong alignment on FLSpecialBuffContainer");
static_assert(sizeof(FLSpecialBuffContainer) == 0x000010, "Wrong size on FLSpecialBuffContainer");
static_assert(offsetof(FLSpecialBuffContainer, BuffList) == 0x000000, "Member 'FLSpecialBuffContainer::BuffList' has a wrong offset!");

// ScriptStruct ProjectP.LSplashBloodFxTableRowType
// 0x0058 (0x0060 - 0x0008)
struct FLSplashBloodFxTableRowType final : public FTableRowBase
{
public:
	ELBloodEffectType                             BloodType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          Particle;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         Trail;                                             // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSplashBloodFxTableRowType) == 0x000008, "Wrong alignment on FLSplashBloodFxTableRowType");
static_assert(sizeof(FLSplashBloodFxTableRowType) == 0x000060, "Wrong size on FLSplashBloodFxTableRowType");
static_assert(offsetof(FLSplashBloodFxTableRowType, BloodType) == 0x000008, "Member 'FLSplashBloodFxTableRowType::BloodType' has a wrong offset!");
static_assert(offsetof(FLSplashBloodFxTableRowType, Particle) == 0x000010, "Member 'FLSplashBloodFxTableRowType::Particle' has a wrong offset!");
static_assert(offsetof(FLSplashBloodFxTableRowType, Trail) == 0x000038, "Member 'FLSplashBloodFxTableRowType::Trail' has a wrong offset!");

// ScriptStruct ProjectP.LSpotOptionInfo
// 0x0001 (0x0001 - 0x0000)
struct FLSpotOptionInfo final
{
public:
	bool                                          PreviewInEditor;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLSpotOptionInfo) == 0x000001, "Wrong alignment on FLSpotOptionInfo");
static_assert(sizeof(FLSpotOptionInfo) == 0x000001, "Wrong size on FLSpotOptionInfo");
static_assert(offsetof(FLSpotOptionInfo, PreviewInEditor) == 0x000000, "Member 'FLSpotOptionInfo::PreviewInEditor' has a wrong offset!");

// ScriptStruct ProjectP.LSwingSFX_NPC_Table
// 0x0000 (0x0060 - 0x0060)
struct FLSwingSFX_NPC_Table final : public FLSwingSFXTable
{
};
static_assert(alignof(FLSwingSFX_NPC_Table) == 0x000008, "Wrong alignment on FLSwingSFX_NPC_Table");
static_assert(sizeof(FLSwingSFX_NPC_Table) == 0x000060, "Wrong size on FLSwingSFX_NPC_Table");

// ScriptStruct ProjectP.LAutoTutorialInfoList
// 0x0050 (0x0050 - 0x0000)
struct FLAutoTutorialInfoList final
{
public:
	TMap<class FString, struct FLNameList>        TutorialParamMap;                                  // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FLAutoTutorialInfoList) == 0x000008, "Wrong alignment on FLAutoTutorialInfoList");
static_assert(sizeof(FLAutoTutorialInfoList) == 0x000050, "Wrong size on FLAutoTutorialInfoList");
static_assert(offsetof(FLAutoTutorialInfoList, TutorialParamMap) == 0x000000, "Member 'FLAutoTutorialInfoList::TutorialParamMap' has a wrong offset!");

// ScriptStruct ProjectP.LTutorialTaskInfo
// 0x0008 (0x0038 - 0x0030)
struct FLTutorialTaskInfo final : public FLCallBackEventData
{
public:
	class FName                                   TutorialCodeName;                                  // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLTutorialTaskInfo) == 0x000008, "Wrong alignment on FLTutorialTaskInfo");
static_assert(sizeof(FLTutorialTaskInfo) == 0x000038, "Wrong size on FLTutorialTaskInfo");
static_assert(offsetof(FLTutorialTaskInfo, TutorialCodeName) == 0x000030, "Member 'FLTutorialTaskInfo::TutorialCodeName' has a wrong offset!");

// ScriptStruct ProjectP.LLoadingScreenAttribute
// 0x0008 (0x0008 - 0x0000)
struct FLLoadingScreenAttribute final
{
public:
	ELLoadingScreenType                           Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFlushLevelStreamingOnStart : 1;                   // 0x0001(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayTime;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLLoadingScreenAttribute) == 0x000004, "Wrong alignment on FLLoadingScreenAttribute");
static_assert(sizeof(FLLoadingScreenAttribute) == 0x000008, "Wrong size on FLLoadingScreenAttribute");
static_assert(offsetof(FLLoadingScreenAttribute, Type) == 0x000000, "Member 'FLLoadingScreenAttribute::Type' has a wrong offset!");
static_assert(offsetof(FLLoadingScreenAttribute, DisplayTime) == 0x000004, "Member 'FLLoadingScreenAttribute::DisplayTime' has a wrong offset!");

// ScriptStruct ProjectP.LWeatherFxTable
// 0x0008 (0x0008 - 0x0000)
struct FLWeatherFxTable final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FLWeatherFxTable) == 0x000008, "Wrong alignment on FLWeatherFxTable");
static_assert(sizeof(FLWeatherFxTable) == 0x000008, "Wrong size on FLWeatherFxTable");
static_assert(offsetof(FLWeatherFxTable, Table) == 0x000000, "Member 'FLWeatherFxTable::Table' has a wrong offset!");

// ScriptStruct ProjectP.LAsyncLoadRequestedTexture
// 0x0048 (0x0048 - 0x0000)
struct FLAsyncLoadRequestedTexture final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UObject>                 Object;                                            // 0x0018(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLAsyncLoadRequestedTexture) == 0x000008, "Wrong alignment on FLAsyncLoadRequestedTexture");
static_assert(sizeof(FLAsyncLoadRequestedTexture) == 0x000048, "Wrong size on FLAsyncLoadRequestedTexture");
static_assert(offsetof(FLAsyncLoadRequestedTexture, Object) == 0x000018, "Member 'FLAsyncLoadRequestedTexture::Object' has a wrong offset!");

// ScriptStruct ProjectP.WorldEventInfoList
// 0x0010 (0x0010 - 0x0000)
struct FWorldEventInfoList final
{
public:
	TArray<struct FWorldEventInfoPtr>             Items;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldEventInfoList) == 0x000008, "Wrong alignment on FWorldEventInfoList");
static_assert(sizeof(FWorldEventInfoList) == 0x000010, "Wrong size on FWorldEventInfoList");
static_assert(offsetof(FWorldEventInfoList, Items) == 0x000000, "Member 'FWorldEventInfoList::Items' has a wrong offset!");

}

